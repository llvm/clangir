---
sort : 2
---

# Types

* toc
{:toc}

---

<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### ArrayType

_CIR array type_

Syntax:

```
!cir.array<
  mlir::Type,   # elementType
  uint64_t   # size
>
```

`CIR.array` represents C/C++ constant arrays.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `mlir::Type` |  |
| size | `uint64_t` |  |

### BF16Type

_CIR type that represents_

Syntax: `!cir.bf16`

Floating-point type that represents the bfloat16 format.


### BoolType

_CIR bool type_

Syntax: `!cir.bool`

`cir.bool` represent's C++ bool type.


### ComplexType

_CIR complex type_

Syntax:

```
!cir.complex<
  ::mlir::Type   # elementType
>
```

CIR type that represents a C complex number. `cir.complex` models the C type
`T _Complex`.

The type models complex values, per C99 6.2.5p11. It supports the C99
complex float types as well as the GCC integer complex extensions.

The parameter `elementType` gives the type of the real and imaginary part of
the complex number. `elementType` must be either a CIR integer type or a CIR
floating-point type.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `::mlir::Type` | integer or floating point type |

### DataMemberType

_CIR type that represents pointer-to-data-member type in C++_

Syntax:

```
!cir.data_member<
  mlir::Type,   # memberTy
  cir::RecordType   # clsTy
>
```

`cir.data_member` models the pointer-to-data-member type in C++. Values of
this type are essentially offsets of the pointed-to member within one of
its containing record.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| memberTy | `mlir::Type` |  |
| clsTy | `cir::RecordType` |  |

### DoubleType

_CIR double-precision float type_

Syntax: `!cir.double`

Floating-point type that represents the `double` type in C/C++. Its
underlying floating-point format is the IEEE-754 binary64 format.


### ExceptionInfoType

_CIR exception info_

Syntax: `!cir.exception`

In presence of an inflight exception, this type holds all specific
information for an exception: the associated type id, and the exception
object pointer. These are materialzed from this type through other
specific operations.


### FP16Type

_CIR type that represents IEEE-754 binary16 format_

Syntax: `!cir.f16`

Floating-point type that represents the IEEE-754 binary16 format.


### FP80Type

_CIR type that represents x87 80-bit floating-point format_

Syntax: `!cir.f80`

Floating-point type that represents the x87 80-bit floating-point format.


### FP128Type

_CIR type that represents IEEEquad 128-bit floating-point format_

Syntax: `!cir.f128`

Floating-point type that represents the IEEEquad 128-bit floating-point format.


### FuncType

_CIR function type_

Syntax:

```
!cir.func<
  ::llvm::ArrayRef<mlir::Type>,   # inputs
  mlir::Type,   # optionalReturnType
  bool   # varArg
>
```

The `!cir.func` is a function type. It consists of an optional return type,
a list of parameter types and can optionally be variadic.

Example:

```mlir
!cir.func<()>
!cir.func<() -> !bool>
!cir.func<(!s8i, !s8i)>
!cir.func<(!s8i, !s8i) -> !s32i>
!cir.func<(!s32i, ...) -> !s32i>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| inputs | `::llvm::ArrayRef<mlir::Type>` |  |
| optionalReturnType | `mlir::Type` |  |
| varArg | `bool` |  |

### IntType

_Integer type with arbitrary precision up to a fixed limit_

CIR type that represents integer types with arbitrary precision.

Those integer types that are directly available in C/C++ standard are called
fundamental integer types. Said types are: `signed char`, `short`, `int`,
`long`, `long long`, and their unsigned variations.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| width | `unsigned` |  |
| isSigned | `bool` |  |

### LongDoubleType

_CIR extended-precision float type_

Syntax:

```
!cir.long_double<
  ::mlir::Type   # underlying
>
```

Floating-point type that represents the `long double` type in C/C++.

The underlying floating-point format of a long double value depends on the
implementation. The `underlying` parameter specifies the CIR floating-point
type that corresponds to this format.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| underlying | `::mlir::Type` | expects !cir.double, !cir.fp80 or !cir.fp128 |

### MethodType

_CIR type that represents C++ pointer-to-member-function type_

Syntax:

```
!cir.method<
  cir::FuncType,   # memberFuncTy
  cir::RecordType   # clsTy
>
```

`cir.method` models the pointer-to-member-function type in C++. The layout
of this type is ABI-dependent.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| memberFuncTy | `cir::FuncType` |  |
| clsTy | `cir::RecordType` |  |

### PointerType

_CIR pointer type_

Syntax:

```
!cir.ptr<
  mlir::Type,   # pointee
  ::cir::AddressSpace   # addrSpace
>
```

The `!cir.ptr` type is a typed pointer type. It is used to represent
pointers to objects in C/C++. The type of the pointed-to object is given by
the `pointee` parameter. The `addrSpace` parameter is an optional address
space attribute that specifies the address space of the pointer. If not
specified, the pointer is assumed to be in the default address space.

The `!cir.ptr` type can point to any type, including fundamental types,
records, arrays, vectors, functions, and other pointers. It can also point
to incomplete types, such as incomplete records.

Note: Data-member pointers and method pointers are represented by
`!cir.data_member` and `!cir.method` types, respectively not by
`!cir.ptr` type.

Examples:

```mlir
!cir.ptr<!cir.int<u, 8>>
!cir.ptr<!cir.float>
!cir.ptr<!cir.record<struct "MyStruct">>
!cir.ptr<!cir.record<struct "MyStruct">, addrspace(offload_private)>
!cir.ptr<!cir.int<u, 8>, addrspace(target<1>)>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| pointee | `mlir::Type` |  |
| addrSpace | `::cir::AddressSpace` | an enum of type AddressSpace |

### RecordType

_CIR record type_

Each unique clang::RecordDecl is mapped to a `cir.record` and any object in
C/C++ that has a struct or class type will have a `cir.record` in CIR.

There are three possible formats for this type:

 - Identified and complete records: unique name and a known body.
 - Identified and incomplete records: unique name and unknown body.
 - Anonymous records: no name and a known body.

Identified records are uniqued by their name, and anonymous records are
uniqued by their body. This means that two anonymous records with the same
body will be the same type, and two identified records with the same name
will be the same type. Attempting to build a record with an existing name,
but a different body will result in an error.

A few examples:

```mlir
    !complete = !cir.record<struct {!cir.int<u, 8>}>
    !incomplete = !cir.record<struct "incomplete" incomplete>
    !anonymous = !cir.record<struct {!cir.int<u, 8>}>
```

Incomplete records are mutable, meaning they can be later completed with a
body automatically updating in place every type in the code that uses the
incomplete record. Mutability allows for recursive types to be represented,
meaning the record can have members that refer to itself. This is useful for
representing recursive records and is implemented through a special syntax.
In the example below, the `Node` record has a member that is a pointer to a
`Node` record:

```mlir
    !s = !cir.record<struct "Node" {!cir.ptr<!cir.record<struct "Node">>}>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| members | `::llvm::ArrayRef<mlir::Type>` |  |
| name | `mlir::StringAttr` |  |
| complete | `bool` |  |
| packed | `bool` |  |
| padded | `bool` |  |
| kind | `RecordType::RecordKind` |  |
| ast | `ASTRecordDeclInterface` |  |

### SingleType

_CIR single-precision float type_

Syntax: `!cir.float`

Floating-point type that represents the `float` type in C/C++. Its
underlying floating-point format is the IEEE-754 binary32 format.


### VPtrType

_CIR type that is used for the vptr member of C++ objects_

Syntax: `!cir.vptr`

`cir.vptr` is a special type used as the type for the vptr member of a C++
object. This avoids using arbitrary pointer types to declare vptr values
and allows stronger type-based checking for operations that use or provide
access to the vptr.

This type will be the element type of the 'vptr' member of structures that
require a vtable pointer. A pointer to this type is returned by the
`cir.vtable.address_point` and `cir.vtable.get_vptr` operations, and this
pointer may be passed to the `cir.vtable.get_virtual_fn_addr` operation to
get the address of a virtual function pointer.

The pointer may also be cast to other pointer types in order to perform
pointer arithmetic based on information encoded in the AST layout to get
the offset from a pointer to a dynamic object to the base object pointer,
the base object offset value from the vtable, or the type information
entry for an object.
TODO: We should have special operations to do that too.


### VectorType

_CIR vector type_

Syntax:

```
!cir.vector<
  ::mlir::Type,   # elementType
  uint64_t   # size
>
```

The `!cir.vector` type represents a fixed-size, one-dimensional vector.
It takes two parameters: the element type and the number of elements.

Syntax:

```mlir
vector-type ::= !cir.vector<element-type x size>
element-type ::= float-type | integer-type | pointer-type
```

The `element-type` must be a scalar CIR type. Zero-sized vectors are not
allowed. The `size` must be a positive integer.

Examples:

```mlir
!cir.vector<!cir.int<u, 8> x 4>
!cir.vector<!cir.float x 2>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elementType | `::mlir::Type` | any cir integer, floating point or pointer type |
| size | `uint64_t` |  |

### VoidType

_CIR void type_

Syntax: `!cir.void`

The `!cir.void` type represents the C/C++ `void` type.

