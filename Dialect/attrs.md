---
sort : 3
---

# Attributes

* toc
{:toc}

---

<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### ASTCXXConstructorDeclAttr

_Wraps a 'const clang::CXXConstructorDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::CXXConstructorDecl *` |  |

### ASTCXXConversionDeclAttr

_Wraps a 'const clang::CXXConversionDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::CXXConversionDecl *` |  |

### ASTCXXDestructorDeclAttr

_Wraps a 'const clang::CXXDestructorDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::CXXDestructorDecl *` |  |

### ASTCXXMethodDeclAttr

_Wraps a 'const clang::CXXMethodDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::CXXMethodDecl *` |  |

### ASTCallExprAttr

_Wraps a 'const clang::CallExpr *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::CallExpr *` |  |

### ASTDeclAttr

_Wraps a 'const clang::Decl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::Decl *` |  |

### ASTExprAttr

_Wraps a 'const clang::Expr *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::Expr *` |  |

### ASTFunctionDeclAttr

_Wraps a 'const clang::FunctionDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::FunctionDecl *` |  |

### ASTRecordDeclAttr

_Wraps a 'const clang::RecordDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::RecordDecl *` |  |

### ASTTagDeclAttr

_Wraps a 'const clang::TagDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::TagDecl *` |  |

### ASTTypeDeclAttr

_Wraps a 'const clang::TypeDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::TypeDecl *` |  |

### ASTVarDeclAttr

_Wraps a 'const clang::VarDecl *' AST node._

Operations optionally refer to this node, they could be available depending
on the CIR lowering stage. Whether it's attached to the appropriated
CIR operation is delegated to the operation verifier.

This always implies a non-null AST reference (verified).

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ast | `const clang::VarDecl *` |  |

### AddressPointAttr

_Address point attribute_

Syntax:

```
#cir.address_point<
  int32_t,   # index
  int32_t   # offset
>
```

Attribute specifying the address point within a C++ virtual table (vtable).

The `index` (vtable index) parameter identifies which vtable to use within a vtable
group, while the `offset` (address point index) specifies the offset within
that vtable where the address begins.

Example:
```mlir
cir.global linkonce_odr @_ZTV1B = ...
...
%3 = cir.vtable.address_point(@_ZTV1B, address_point = <index = 0, offset = 2>)) : !cir.ptr<!cir.ptr<() -> i32>>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| index | `int32_t` |  |
| offset | `int32_t` |  |

### AddressSpaceAttr

_Address space attribute for pointer types_

Syntax:

```
#cir.addrspace<
  int32_t   # value
>
```

The address space attribute is used in pointer types. It essentially
provides a unified model on top of `clang::LangAS`, rather than LLVM address
spaces.

The representation is further simplified: `LangAS::Default` is encoded as
a null attribute; many address spaces from different offloading languages
are unified as `offload_*`; etc.

The meaning of `value` parameter is defined as an extensible enum `Kind`,
which encodes target AS as offset to the last language AS.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `int32_t` |  |

### AnnotationAttr

_Annotation attribute for global variables and functions_

Syntax:

```
#cir.annotation<
  mlir::StringAttr,   # name
  mlir::ArrayAttr   # args
>
```

Represent C/C++ attribute of annotate in CIR.
Example C code:
```
 int *a __attribute__((annotate("testptr", "21", 12 )));
```
In this example code, the `AnnotationAttr` has annotation name "testptr",
and arguments "21" and 12 constitutes an `ArrayAttr` type parameter `args`
for global variable `a`.
In CIR, the attribute for above annotation looks like:
```
[#cir.annotation<name = "withargs", args = ["21", 12 : i32]>]
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `mlir::StringAttr` |  |
| args | `mlir::ArrayAttr` |  |

### BitfieldInfoAttr

_Represents a bit field info_

Syntax:

```
#cir.bitfield_info<
  mlir::StringAttr,   # name
  mlir::Type,   # storage_type
  uint64_t,   # size
  uint64_t,   # offset
  bool   # is_signed
>
```

Holds the next information about bitfields: name, storage type, a bitfield size
and position in the storage, if the bitfield is signed or not.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `mlir::StringAttr` |  |
| storage_type | `mlir::Type` |  |
| size | `uint64_t` |  |
| offset | `uint64_t` |  |
| is_signed | `bool` |  |

### BoolAttr

_Represent true/false for !cir.bool types_

Syntax:

```
#cir.bool<
  cir::BoolType,   # type
  bool   # value
>
```

The BoolAttr represents a 'true' or 'false' value.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `cir::BoolType` |  |
| value | `bool` |  |

### InlineAttr

_Inline attribute_

Syntax:

```
#cir.inline<
  ::cir::InlineKind   # value
>
```

Inline attributes represents user directives.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::cir::InlineKind` | an enum of type InlineKind |

### OptInfoAttr

_A module-level attribute that holds the optimization information_

Syntax:

```
#cir.opt_info<
  unsigned,   # level
  unsigned   # size
>
```

The `#cir.opt_info` attribute holds the optimization related information.
Currently this attribute is a module-level attribute that gets attached to
the module operation during CIRGen.

The `level` parameter gives the optimization level. It must be an integer
between 0 and 3, inclusive. It corresponds to the `OptimizationLevel` field
within the `clang::CodeGenOptions` structure.

The `size` parameter gives the code size optimization level. It must be an
integer between 0 and 2, inclusive. It corresponds to the `OptimizeSize`
field within the `clang::CodeGenOptions` structure.

The `level` and `size` parameters correspond to the optimization level
command line options passed to clang driver. The table below lists the
current correspondance relationship:

| Flag             | `level` | `size` |
|------------------|---------|--------|
| `-O0` or nothing | 0       | 0      |
| `-O1`            | 1       | 0      |
| `-O2`            | 2       | 0      |
| `-O3`            | 3       | 0      |
| `-Os`            | 2       | 1      |
| `-Oz`            | 2       | 2      |

Examples:

```mlir
#cir.opt_info<level = 2, size = 0>  // -O2
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| level | `unsigned` |  |
| size | `unsigned` |  |

### SourceLanguageAttr

_Module source language_

Syntax:

```
#cir.lang<
  ::cir::SourceLanguage   # value
>
```

Represents the source language used to generate the module.

Example:
```
// Module compiled from C.
module attributes {cir.lang = cir.lang<c>} {}
// Module compiled from C++.
module attributes {cir.lang = cir.lang<cxx>} {}
```

Module source language attribute name is `cir.lang` is defined by
`getSourceLanguageAttrName` method in CIRDialect class.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::cir::SourceLanguage` | an enum of type SourceLanguage |

### TBAAAttr

_CIR dialect TBAA base attribute_

Syntax: `#cir.tbaa`


### TBAAMemberAttr

_Attribute representing a member of a TBAA structured type._

Syntax:

```
#cir.tbaa_member<
  TBAAAttr,   # type_desc
  int64_t   # offset
>
```

Define a TBAA struct attribute.

Example:
```mlir
!rec_StructS = !cir.record<struct "StructS" {!u16i, !u32i} #cir.record.decl.ast>
#tbaa_scalar = #cir.tbaa_scalar<id = "int", type = !s32i>
#tbaa_scalar1 = #cir.tbaa_scalar<id = "short", type = !s16i>
#tbaa_struct = #cir.tbaa_struct<id = "_ZTS7StructS", members = {<#tbaa_scalar1, 0>, <#tbaa_scalar, 4>}>
```

See the following link for more details:
https://llvm.org/docs/LangRef.html#tbaa-metadata

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type_desc | `TBAAAttr` |  |
| offset | `int64_t` |  |

### TBAAOmnipotentCharAttr

_Describes a special scalar type, the omnipotent char type._

Syntax: `#cir.tbaa_omnipotent_char`


### TBAAScalarAttr

_Describes a scalar type in TBAA with an identifier._

Syntax:

```
#cir.tbaa_scalar<
  ::llvm::StringRef,   # id
  ::mlir::Type,   # type
  cir::TBAAScalarAttr   # parent
>
```

Define a TBAA scalar attribute.
The optional `parent` attribute is used to describe the parent type of the 
scalar type. If the `parent` is null or omitted, the parent type is the 
`omnipotent char` type.

Example:
```mlir
// CIR_TBAAScalarAttr
#tbaa_scalar = #cir.tbaa_scalar<id = "int", type = !s32i>
#tbaa_scalar1 = #cir.tbaa_scalar<id = "long long", type = !s64i>

#tbaa_scalar2 = #cir.tbaa_scalar<id = "any pointer", type = !cir.ptr<!s32i>>
#tbaa_scalar3 = #cir.tbaa_scalar<id = "p1 int", type = !cir.ptr<!s32i>, 
                                 parent = #tbaa_scalar2>
```

See the following link for more details:
https://llvm.org/docs/LangRef.html#tbaa-metadata

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| id | `::llvm::StringRef` |  |
| type | `::mlir::Type` | Integer type with arbitrary precision up to a fixed limit or CIR pointer type or CIR type that represents pointer-to-data-member type in C++ or CIR type that represents C++ pointer-to-member-function type or CIR bool type or CIR array type or CIR vector type or CIR function type or CIR void type or CIR record type or CIR exception info or single float type or double float type or f16 type or bf16 type or f80 type or f128 type or long double type or CIR complex type |
| parent | `cir::TBAAScalarAttr` |  |

### TBAAStructAttr

_Describes a struct type in TBAA_

Syntax:

```
#cir.tbaa_struct<
  ::llvm::StringRef,   # id
  ::llvm::ArrayRef<TBAAMemberAttr>   # members
>
```

Define a TBAA struct attribute.

Example:
```mlir
!rec_StructS = !cir.record<struct "StructS" {!u16i, !u32i} #cir.record.decl.ast>
#tbaa_scalar = #cir.tbaa_scalar<id = "int", type = !s32i>
#tbaa_scalar1 = #cir.tbaa_scalar<id = "short", type = !s16i>
// CIR_TBAAStructAttr
#tbaa_struct = #cir.tbaa_struct<id = "_ZTS7StructS", members = {<#tbaa_scalar1, 0>, <#tbaa_scalar, 4>}>
```

See the following link for more details:
https://llvm.org/docs/LangRef.html#tbaa-metadata

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| id | `::llvm::StringRef` |  |
| members | `::llvm::ArrayRef<TBAAMemberAttr>` | Array of TBAAMemberAttr attributes. |

### TBAATagAttr

Syntax:

```
#cir.tbaa_tag<
  ::cir::TBAAAttr,   # base
  ::cir::TBAAAttr,   # access
  int64_t   # offset
>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| base | `::cir::TBAAAttr` | CIR dialect TBAA base attribute |
| access | `::cir::TBAAAttr` | CIR dialect TBAA base attribute |
| offset | `int64_t` |  |

### TBAAVTablePointerAttr

_Describes a special scalar type, the vtable pointer type._

Syntax:

```
#cir.tbaa_vptr<
  ::mlir::Type   # type
>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` | Integer type with arbitrary precision up to a fixed limit or CIR pointer type or CIR type that represents pointer-to-data-member type in C++ or CIR type that represents C++ pointer-to-member-function type or CIR bool type or CIR array type or CIR vector type or CIR function type or CIR void type or CIR record type or CIR exception info or single float type or double float type or f16 type or bf16 type or f80 type or f128 type or long double type or CIR complex type |

### TypeSizeInfoAttr

_The size of types in bits_

Syntax:

```
#cir.type_size_info<
  unsigned,   # char_size
  unsigned,   # int_size
  unsigned   # size_t_size
>
```

The `cir.type_size` attribute is attached to a module, recording lengths
of various types if their names don't include it.

It is worth noticing that size_t and pointers are considered to have the
same length in Clang IR.

Float and double types are represented by cir::SingleType and cir::
DoubleType respectively, whose constructos don't need the type size as an
argument. So their lengths are not stored here.

Examples:

```mlir
// sizeof(int) == 4, sizeof(size_t) == 8
module attributes {
  cir.type_size = #cir.type_size<
    char = 8,
    int = 32,
    size_t = 64
  >
} {}
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| char_size | `unsigned` |  |
| int_size | `unsigned` |  |
| size_t_size | `unsigned` |  |

### UWTableAttr

_Unwind table kind attribute_

Syntax:

```
#cir.uwtable<
  ::cir::UWTableKind   # value
>
```

The kind of unwind tables to generate for a function. `none` means no unwind
tables are generated; `sync` means synchronous unwind tables (that are only
valid at call boundaries), and `async` means asynchronous unwind tables
(that are valid at all instructions). When applied to a module, this
controls the unwind table generation for any synthesized functions.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::cir::UWTableKind` | an enum of type UWTableKind |

### VisibilityAttr

_Visibility attribute_

Syntax:

```
#cir.visibility<
  ::cir::VisibilityKind   # value
>
```

Visibility attributes.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| value | `::cir::VisibilityKind` | an enum of type VisibilityKind |

### CUDABinaryHandleAttr

_Fat binary handle for device code._

Syntax:

```
#cir.cu.binary_handle<
  std::string   # name
>
```

This attribute is attached to the ModuleOp and records the binary file
name passed to host.

CUDA first compiles device-side code into a fat binary file. The file
name is then passed into host-side code, which is used to create a handle
and then generate various registration functions.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `std::string` |  |

### CUDAExternallyInitializedAttr

_The marked variable is externally initialized._

Syntax: `#cir.cu.externally_initialized`

CUDA __device__ and __constant__ variables, along with surface and
textures, might be initialized by host, hence "externally initialized".
Therefore they must be emitted even if they are not referenced.

The attribute corresponds to the attribute on LLVM with the same name.


### CUDAKernelNameAttr

_Device-side function name for this stub._

Syntax:

```
#cir.cu.kernel_name<
  std::string   # kernel_name
>
```

This attribute is attached to function definitions and records the
mangled name of the kernel function used on the device.

In CUDA, global functions (kernels) are processed differently for host
and device. On host, Clang generates device stubs; on device, they are
treated as normal functions. As they probably have different mangled
names, we must record the corresponding device-side name for a stub.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| kernel_name | `std::string` |  |

### CUDAShadowNameAttr

_Device-side global variable name for this shadow._

Syntax:

```
#cir.cu.shadow_name<
  std::string   # device_side_name
>
```

This attribute is attached to global variable definitions and records the
mangled name of the global variable used on the device.

In CUDA, __device__, __constant__ and __shared__ variables, as well as 
surface and texture variables, will generate a shadow symbol on host.
We must preserve the correspodence in order to generate registration
functions.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| device_side_name | `std::string` |  |

### CmpThreeWayInfoAttr

_Holds information about a three-way comparison operation_

Syntax:

```
#cir.cmp3way_info<
  ::cir::CmpOrdering,   # ordering
  int64_t,   # lt
  int64_t,   # eq
  int64_t,   # gt
  std::optional<int64_t>   # unordered
>
```

The `#cmp3way_info` attribute contains information about a three-way
comparison operation `cir.cmp3way`.

The `ordering` parameter gives the ordering kind of the three-way comparison
operation. It may be either strong ordering or partial ordering.

Given the two input operands of the three-way comparison operation `lhs` and
`rhs`, the `lt`, `eq`, `gt`, and `unordered` parameters gives the result
value that should be produced by the three-way comparison operation when the
ordering between `lhs` and `rhs` is `lhs < rhs`, `lhs == rhs`, `lhs > rhs`,
or neither, respectively.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| ordering | `::cir::CmpOrdering` | an enum of type CmpOrdering |
| lt | `int64_t` |  |
| eq | `int64_t` |  |
| gt | `int64_t` |  |
| unordered | `std::optional<int64_t>` |  |

### ComplexAttr

_An attribute that contains a constant complex value_

Syntax:

```
#cir.complex<
  cir::ComplexType,   # type
  mlir::TypedAttr,   # real
  mlir::TypedAttr   # imag
>
```

The `#cir.complex` attribute contains a constant value of complex number
type. The `real` parameter gives the real part of the complex number and the
`imag` parameter gives the imaginary part of the complex number.

The `real` and `imag` parameter must be either an IntAttr or an FPAttr that
contains values of the same CIR type.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `cir::ComplexType` |  |
| real | `mlir::TypedAttr` |  |
| imag | `mlir::TypedAttr` |  |

### ConstArrayAttr

_A constant array from ArrayAttr or StringRefAttr_

An CIR array attribute is an array of literals of the specified attr types.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| elts | `mlir::Attribute` |  |
| trailingZerosNum | `int` |  |

### ConstPtrAttr

_Holds a constant pointer value_

Syntax:

```
#cir.ptr<
  ::cir::PointerType,   # type
  mlir::IntegerAttr   # value
>
```

A pointer attribute is a literal attribute that represents an integral
value of a pointer type.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::cir::PointerType` |  |
| value | `mlir::IntegerAttr` |  |

### ConstRecordAttr

_Represents a constant record_

Syntax:

```
#cir.const_record<
  ::mlir::Type,   # type
  mlir::ArrayAttr   # members
>
```

Effectively supports "struct-like" constants. It's must be built from
an `mlir::ArrayAttr `instance where each elements is a typed attribute
(`mlir::TypedAttribute`).

Example:
```
cir.global external @rgb2 = #cir.const_record<{0 : i8,
                                               5 : i64, #cir.null : !cir.ptr<i8>
                                              }> : !cir.record<"", i8, i64, !cir.ptr<i8>>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| members | `mlir::ArrayAttr` |  |

### ConstVectorAttr

_A constant vector from ArrayAttr_

A CIR vector attribute is an array of literals of the specified attribute
types.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| elts | `mlir::ArrayAttr` |  |

### ConvergentAttr

Syntax: `#cir.convergent`


### DataMemberAttr

_Holds a constant data member pointer value_

Syntax:

```
#cir.data_member<
  cir::DataMemberType,   # type
  std::optional<unsigned>   # member_index
>
```

A data member attribute is a literal attribute that represents a constant
pointer-to-data-member value.

The `member_index` parameter represents the index of the pointed-to member
within its containing record. It is an optional parameter; lack of this
parameter indicates a null pointer-to-data-member value.

Example:
```
#ptr = #cir.data_member<1> : !cir.data_member<!s32i in !rec_22Point22>

#null = #cir.data_member<null> : !cir.data_member<!s32i in !rec_22Point22>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `cir::DataMemberType` |  |
| member_index | `std::optional<unsigned>` |  |

### DynamicCastInfoAttr

_ABI specific information about a dynamic cast_

Syntax:

```
#cir.dyn_cast_info<
  ::cir::GlobalViewAttr,   # srcRtti
  ::cir::GlobalViewAttr,   # destRtti
  mlir::FlatSymbolRefAttr,   # runtimeFunc
  mlir::FlatSymbolRefAttr,   # badCastFunc
  ::cir::IntAttr   # offsetHint
>
```

Provide ABI specific information about a dynamic cast operation.

The `srcRtti` and the `destRtti` parameters give the RTTI of the source
record type and the destination record type, respectively.

The `runtimeFunc` parameter gives the `__dynamic_cast` function which is
provided by the runtime. The `badCastFunc` parameter gives the
`__cxa_bad_cast` function which is also provided by the runtime.

The `offsetHint` parameter gives the hint value that should be passed to the
`__dynamic_cast` runtime function.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| srcRtti | `::cir::GlobalViewAttr` | Provides constant access to a global address |
| destRtti | `::cir::GlobalViewAttr` | Provides constant access to a global address |
| runtimeFunc | `mlir::FlatSymbolRefAttr` |  |
| badCastFunc | `mlir::FlatSymbolRefAttr` |  |
| offsetHint | `::cir::IntAttr` | An Attribute containing a integer value |

### ExtraFuncAttributesAttr

_Represents aggregated attributes for a function_

Syntax:

```
#cir.extra<
  mlir::DictionaryAttr   # elements
>
```

This is a wrapper of attribute dictionary that contains extra attributes of
a function.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| elements | `mlir::DictionaryAttr` |  |

### FPAttr

_An attribute containing a floating-point value_

Syntax:

```
#cir.fp<
  ::cir::FPTypeInterface,   # type
  ::llvm::APFloat   # value
>
```

An fp attribute is a literal attribute that represents a floating-point
value of the specified floating-point type. Supporting only CIR FP types.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::cir::FPTypeInterface` |  |
| value | `::llvm::APFloat` |  |

### GlobalAnnotationValuesAttr

_Array of annotations, each element consists of name ofa global var or func and one of its annotations_

Syntax:

```
#cir.global_annotations<
  mlir::ArrayAttr   # annotations
>
```

This is annotation value array, which holds the annotation
values for all global variables and functions in a module.
This array is used to create the initial value of a global annotation
metadata variable in LLVM IR.
Example C code:
```
double *a __attribute__((annotate("withargs", "21", 12 )));
int *b __attribute__((annotate("withargs", "21", 12 )));
void *c __attribute__((annotate("noargvar")));
void foo(int i) __attribute__((annotate("noargfunc"))) {}
```
After CIR lowering prepare pass, compiler generates a
`GlobalAnnotationValuesAttr` like the following:
```
#cir<global_annotations [
  ["a", #cir.annotation<name = "withargs", args = ["21", 12 : i32]>],
  ["b", #cir.annotation<name = "withargs", args = ["21", 12 : i32]>],
  ["c", #cir.annotation<name = "noargvar", args = []>],
  ["foo", #cir.annotation<name = "noargfunc", args = []>]]>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| annotations | `mlir::ArrayAttr` |  |

### GlobalCtorAttr

_Marks a function as a global constructor_

Syntax:

```
#cir.global_ctor<
  mlir::StringAttr,   # name
  int   # priority
>
```

A function with this attribute executes before main()

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `mlir::StringAttr` |  |
| priority | `int` |  |

### GlobalDtorAttr

_Marks a function as a global destructor_

Syntax:

```
#cir.global_dtor<
  mlir::StringAttr,   # name
  int   # priority
>
```

A function with this attribute excutes before module unloading

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| name | `mlir::StringAttr` |  |
| priority | `int` |  |

### GlobalViewAttr

_Provides constant access to a global address_

Syntax:

```
#cir.global_view<
  ::mlir::Type,   # type
  mlir::FlatSymbolRefAttr,   # symbol
  mlir::ArrayAttr   # indices
>
```

Get constant address of global `symbol` and optionally apply offsets to
access existing subelements. It provides a way to access globals from other
global and always produces a pointer.

The type of the input symbol can be different from `#cir.global_view`
output type, since a given view of the global might require a static
cast for initializing other globals.

A list of indices can be optionally passed and each element subsequently
indexes underlying types. For `symbol` types like `!cir.array`
and `!cir.record`, it leads to the constant address of sub-elements, while
for `!cir.ptr`, an offset is applied. The first index is relative to the
original symbol type, not the produced one.

The result type of this attribute may be an integer type. In such a case,
the pointer to the referenced global is casted to an integer and this
attribute represents the casted result.

Example:

```
  cir.global external @s = @".str2": !cir.ptr<i8>
  cir.global external @x = #cir.global_view<@s> : !cir.ptr<i8>
  cir.global external @s_addr = #cir.global_view<@s> : !s64i

  cir.global external @rgb = #cir.const_array<[0 : i8, -23 : i8, 33 : i8] : !cir.array<i8 x 3>>
  cir.global external @elt_ptr = #cir.global_view<@rgb, [1]> : !cir.ptr<i8>
  cir.global external @table_of_ptrs = #cir.const_array<[#cir.global_view<@rgb, [1]> : !cir.ptr<i8>] : !cir.array<!cir.ptr<i8> x 1>>
```

Note, that unlike LLVM IR's gep instruction, CIR doesn't add the leading zero index
when it's known to be constant zero, e.g. for pointers, i.e. we use indexes exactly
to access sub elements or for the offset. The leading zero index is added later in
the lowering.

Example:
```
struct A {
  int a;
};

struct B:  virtual A {
  int b;
};
```
VTT for B:
```
cir.global linkonce_odr @_ZTT1B = #cir.const_array<[#cir.global_view<@_ZTV1B, [0 : i32, 3 : i32]> : !cir.ptr<!u8i>]> : !cir.array<!cir.ptr<!u8i> x 1>
```
The same for LLVM IR after CIR:
```
@_ZTT1B = linkonce_odr global [1 x ptr] [ptr getelementptr inbounds ({ [3 x ptr] }, ptr @_ZTV1B, i32 0, i32 0, i32 3)], align 8
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| symbol | `mlir::FlatSymbolRefAttr` |  |
| indices | `mlir::ArrayAttr` |  |

### IntAttr

_An Attribute containing a integer value_

An integer attribute is a literal attribute that represents an integral
value of the specified integer type.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| value | `llvm::APInt` |  |

### MethodAttr

_Holds a constant pointer-to-member-function value_

A method attribute is a literal attribute that represents a constant
pointer-to-member-function value.

If the member function is a non-virtual function, the `symbol` parameter
gives the global symbol for the non-virtual member function.

If the member function is a virtual function, the `vtable_offset` parameter
gives the offset of the vtable entry corresponding to the virtual member
function.

`symbol` and `vtable_offset` cannot be present at the same time. If both of
`symbol` and `vtable_offset` are not present, the attribute represents a
null pointer constant.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `cir::MethodType` |  |
| symbol | `std::optional<mlir::FlatSymbolRefAttr>` |  |
| vtable_offset | `std::optional<uint64_t>` |  |

### NoThrowAttr

Syntax: `#cir.nothrow`


### OpenCLKernelArgMetadataAttr

_OpenCL kernel argument metadata_

Syntax:

```
#cir.cl.kernel_arg_metadata<
  mlir::ArrayAttr,   # addr_space
  mlir::ArrayAttr,   # access_qual
  mlir::ArrayAttr,   # type
  mlir::ArrayAttr,   # base_type
  mlir::ArrayAttr,   # type_qual
  mlir::ArrayAttr   # name
>
```

Provide the required information of an OpenCL kernel argument for the SPIR-V
backend.

All parameters are arrays, containing the information of the argument in
the same order as they appear in the source code.

The `addr_space` parameter is an array of I32 that provides the address
space of the argument. It's useful for special types like `image`, which
have implicit global address space.

Other parameters are arrays of strings that pass through the information
from the source code correspondingly.

All the fields are mandatory except for `name`, which is optional.

Example:
```
#fn_attr = #cir<extra({cl.kernel_arg_metadata = #cir.cl.kernel_arg_metadata<
  addr_space = [1 : i32],
  access_qual = ["none"],
  type = ["char*"],
  base_type = ["char*"],
  type_qual = [""],
  name = ["in"]
>})>

cir.func @kernel(%arg0: !s32i) extra(#fn_attr) {
  cir.return
}
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| addr_space | `mlir::ArrayAttr` |  |
| access_qual | `mlir::ArrayAttr` |  |
| type | `mlir::ArrayAttr` |  |
| base_type | `mlir::ArrayAttr` |  |
| type_qual | `mlir::ArrayAttr` |  |
| name | `mlir::ArrayAttr` |  |

### OpenCLKernelAttr

_OpenCL kernel_

Syntax: `#cir.cl.kernel`

Indicate the function is a OpenCL kernel.


### OpenCLKernelMetadataAttr

_OpenCL kernel metadata_

Syntax:

```
#cir.cl.kernel_metadata<
  mlir::ArrayAttr,   # work_group_size_hint
  mlir::ArrayAttr,   # reqd_work_group_size
  mlir::TypeAttr,   # vec_type_hint
  std::optional<bool>,   # vec_type_hint_signedness
  mlir::IntegerAttr   # intel_reqd_sub_group_size
>
```

Provide the required information of an OpenCL kernel for the SPIR-V backend.

The `work_group_size_hint` and `reqd_work_group_size` parameter are integer
arrays with 3 elements that provide hints for the work-group size and the
required work-group size, respectively.

The `vec_type_hint` parameter is a type attribute that provides a hint for
the vectorization. It can be a CIR or LLVM type, depending on the lowering
stage.

The `vec_type_hint_signedness` parameter is a boolean that indicates the
signedness of the vector type hint. It's useful when LLVM type is set in
`vec_type_hint`, which is signless by design. It should be set if and only
if the `vec_type_hint` is present.

The `intel_reqd_sub_group_size` parameter is an integer that restricts the
sub-group size to the specified value.

Example:
```
#fn_attr = #cir<extra({cl.kernel_metadata = #cir.cl.kernel_metadata<
  work_group_size_hint = [8 : i32, 16 : i32, 32 : i32],
  reqd_work_group_size = [1 : i32, 2 : i32, 4 : i32],
  vec_type_hint = !s32i,
  vec_type_hint_signedness = 1,
  intel_reqd_sub_group_size = 8 : i32
>})>

cir.func @kernel(%arg0: !s32i) extra(#fn_attr) {
  cir.return
}
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| work_group_size_hint | `mlir::ArrayAttr` |  |
| reqd_work_group_size | `mlir::ArrayAttr` |  |
| vec_type_hint | `mlir::TypeAttr` |  |
| vec_type_hint_signedness | `std::optional<bool>` |  |
| intel_reqd_sub_group_size | `mlir::IntegerAttr` |  |

### OpenCLKernelUniformWorkGroupSizeAttr

_OpenCL kernel work-group uniformity_

Syntax: `#cir.cl.uniform_work_group_size`

In OpenCL v2.0, work groups can either be uniform or non-uniform.
This attribute is associated with kernels to represent the work group type.
Non-kernel entities should not interact with this attribute.

Clang's `-cl-uniform-work-group-size` compilation option provides a hint to
the compiler, indicating that the global work size should be a multiple of
the work-group size specified in the `clEnqueueNDRangeKernel` function,
thereby ensuring that the work groups are uniform.


### OpenCLVersionAttr

_OpenCL version_

Syntax:

```
#cir.cl.version<
  int32_t,   # major_version
  int32_t   # minor_version
>
```

Represents the version of OpenCL.

Example:
```
// Module compiled from OpenCL 1.2.
module attributes {cir.cl.version = cir.cl.version<1, 2>} {}
// Module compiled from OpenCL 3.0.
module attributes {cir.cl.version = cir.cl.version<3, 0>} {}
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| major_version | `int32_t` |  |
| minor_version | `int32_t` |  |

### OptNoneAttr

Syntax: `#cir.optnone`


### PoisonAttr

_Represent a typed poison constant_

Syntax:

```
#cir.poison<
  ::mlir::Type   # type
>
```

The PoisonAttr represents a typed poison constant, corresponding to LLVM's
notion of poison.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |

### TypeInfoAttr

_Represents a typeinfo used for RTTI_

Syntax:

```
#cir.typeinfo<
  ::mlir::Type,   # type
  mlir::ArrayAttr   # data
>
```

The typeinfo data for a given class is stored into an ArrayAttr. The
layout is determined by the C++ ABI used (clang only implements
itanium on CIRGen).

The verifier enforces that the output type is always a `!cir.record`,
and that the ArrayAttr element types match the equivalent member type
for the resulting record, i.e, a GlobalViewAttr for symbol reference or
an IntAttr for flags.

Example:

```
cir.global "private" external @_ZTVN10__cxxabiv120__si_class_type_infoE : !cir.ptr<i32>

cir.global external @type_info_B = #cir.typeinfo<<
  {#cir.global_view<@_ZTVN10__cxxabiv120__si_class_type_infoE, [2]> : !cir.ptr<i8>}
>> : !cir.record<"", !cir.ptr<i8>>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| data | `mlir::ArrayAttr` |  |

### UndefAttr

_Represent an undef constant_

Syntax:

```
#cir.undef<
  ::mlir::Type   # type
>
```

The UndefAttr represents an undef constant, corresponding to LLVM's notion
of undef.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |

### VTableAttr

_Represents a C++ vtable_

Syntax:

```
#cir.vtable<
  ::mlir::Type,   # type
  mlir::ArrayAttr   # vtable_data
>
```

Wraps a #cir.const_record containing vtable data.

Example:
```
cir.global linkonce_odr @_ZTV1B = #cir.vtable<<
    {#cir.const_array<[#cir.null : !cir.ptr<i8>,
     #cir.global_view<@_ZTI1B> : !cir.ptr<i8>,
     #cir.global_view<@_ZN1BD1Ev> : !cir.ptr<i8>,
     #cir.global_view<@_ZN1BD0Ev> : !cir.ptr<i8>,
     #cir.global_view<@_ZNK1A5quackEv> : !cir.ptr<i8>]>
     : !cir.array<!cir.ptr<i8> x 5>}>>
  : !cir.record<"", !cir.array<!cir.ptr<i8> x 5>>
```

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
| vtable_data | `mlir::ArrayAttr` |  |

### ZeroAttr

_Attribute to represent zero initialization_

Syntax:

```
#cir.zero<
  ::mlir::Type   # type
>
```

The ZeroAttr is used to indicate zero initialization on structs.

#### Parameters:

| Parameter | C++ type | Description |
| :-------: | :-------: | ----------- |
| type | `::mlir::Type` |  |
