---
parent: CIR Dialect
nav_order: 4
---

# Passes

* toc
{:toc}

---

<!-- Autogenerated by mlir-tblgen; don't manually edit -->

### `-cir-call-conv-lowering`

_Handle calling conventions for CIR functions_

This pass lowers CIR function definitions and calls according to the
calling conventions for the target architecture. This pass is necessary
to properly lower CIR functions to LLVM IR.

### `-cir-canonicalize`

_Performs CIR canonicalization_

Perform canonicalizations on CIR and removes some redundant operations.

This pass performs basic cleanup and canonicalization transformations that
hopefully do not affect CIR-to-source fidelity and high-level code analysis
passes too much. Example transformations performed in this pass include
empty scope cleanup, trivial try cleanup, redundant branch cleanup, etc.
Those more "heavyweight" transformations and those transformations that
could significantly affect CIR-to-source fidelity are performed in the
`cir-simplify` pass.

### `-cir-drop-ast`

_Remove clang AST nodes attached to CIR operations_

Some CIR operations have references back to Clang AST, this is
necessary to perform lots of useful checks without having to
duplicate all rich AST information in CIR. As we move down in the
pipeline (e.g. generating LLVM or other MLIR dialects), the need
for such nodes diminish and AST information can be dropped.

Right now this is enabled by default in Clang prior to dialect
codegen from CIR, but not before lifetime check, where AST is
required to be present.

### `-cir-flatten-cfg`

_Produces flatten CFG_

This pass transforms CIR and inline all the nested regions. Thus,
the next post condtions are met after the pass applied:
- there is not any nested region in a function body
- all the blocks in a function belong to the parent region
In other words, this pass removes such CIR operations like IfOp, LoopOp,
ScopeOp and etc. and produces a flat CIR.

### `-cir-goto-solver`

_Replaces goto operations with branches_

This pass transforms CIR and replaces goto-s with branch
operations to the proper blocks.

### `-cir-hoist-allocas`

_Hoist allocas to the entry of the function_

This pass hoist all non-dynamic allocas to the entry of the function.
This is helpful for later code generation.

### `-cir-idiom-recognizer`

_Raise calls to C/C++ libraries to CIR operations_

This pass recognize idiomatic C++ usage and incorporate C++ standard
containers, library functions calls, and types into CIR operation,
attributes and types.

Detections done by this pass can be inspected by users by using
remarks. Currently supported are `all` and `found-calls`.

#### Options

```
-remarks : Diagnostic remarks to enable Supported styles: {all|found-calls}
```

### `-cir-lib-opt`

_Optimize C/C++ library calls_

By using higher level information from `cir-idiom-recognize`, this pass
apply transformations to CIR based on specific C/C++ library semantics.

Transformations done by this pass can be inspected by users by using
remarks. Currently supported are `all` and `transforms`.

#### Options

```
-remarks : Diagnostic remarks to enable Supported styles: {all|transforms}
```

### `-cir-lifetime-check`

_Check lifetime safety and generate diagnostics_

This pass relies on a lifetime analysis pass and uses the diagnostics
mechanism to report to the user. It does not change any code.

A default ctor is specified but is solely in order to make
tablegen happy, since this pass requires the presence of an ASTContext,
one can set that up using `mlir::createLifetimeCheckPass(clang::ASTContext &)`
instead.

#### Options

```
-history       : List of history styles to emit as part of diagnostics. Supported styles: {all|null|invalid}
-remarks       : List of remark styles to enable as part of diagnostics. Supported styles: {all|pset}
-history_limit : Max amount of diagnostics to emit on pointer history
```

### `-cir-lowering-prepare`

_Preparation work before lowering to LLVM dialect_

This pass does preparation work for LLVM lowering. For example, it may
expand the global variable initialziation in a more ABI-friendly form.

### `-cir-mlir-scf-prepare`

_Preparation work before lowering to SCF dialect_

This pass does preparation work for SCF lowering. For example, it may
hoist the loop invariant or canonicalize the loop comparison. Currently,
the pass only be enabled for through MLIR pipeline.

### `-cir-simplify`

_Performs CIR simplification and code optimization_

The pass performs code simplification and optimization on CIR.

Unlike the `cir-canonicalize` pass, this pass contains more aggresive code
transformations that could significantly affect CIR-to-source fidelity.
Example transformations performed in this pass include ternary folding,
code hoisting, etc.
