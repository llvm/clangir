//===- CIRTypes.cpp - MLIR CIR Types --------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines the types in the CIR dialect.
//
//===----------------------------------------------------------------------===//

#include "clang/CIR/Dialect/IR/CIRTypes.h"
#include "clang/CIR/Dialect/IR/CIRDialect.h"

#include "mlir/IR/Attributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/Support/LogicalResult.h"

#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/TypeSwitch.h"
#include "llvm/Support/ErrorHandling.h"

//===----------------------------------------------------------------------===//
// CIR Custom Parser/Printer Signatures
//===----------------------------------------------------------------------===//

static mlir::ParseResult
parseFuncTypeArgs(mlir::AsmParser &p, llvm::SmallVector<mlir::Type> &params,
                  bool &isVarArg);
static void printFuncTypeArgs(mlir::AsmPrinter &p,
                              mlir::ArrayRef<mlir::Type> params, bool isVarArg);

//===----------------------------------------------------------------------===//
// Get autogenerated stuff
//===----------------------------------------------------------------------===//

#define GET_TYPEDEF_CLASSES
#include "clang/CIR/Dialect/IR/CIROpsTypes.cpp.inc"

using namespace mlir;
using namespace mlir::cir;

//===----------------------------------------------------------------------===//
// General CIR parsing / printing
//===----------------------------------------------------------------------===//

Type CIRDialect::parseType(DialectAsmParser &parser) const {
  llvm::SMLoc typeLoc = parser.getCurrentLocation();
  StringRef mnemonic;
  Type genType;
  OptionalParseResult parseResult =
      generatedTypeParser(parser, &mnemonic, genType);
  if (parseResult.has_value())
    return genType;
  parser.emitError(typeLoc, "unknown type in CIR dialect");
  return Type();
}

void CIRDialect::printType(Type type, DialectAsmPrinter &os) const {
  if (failed(generatedTypePrinter(type, os)))
    llvm_unreachable("unexpected CIR type kind");
}

Type PointerType::parse(mlir::AsmParser &parser) {
  if (parser.parseLess())
    return Type();
  Type pointeeType;
  if (parser.parseType(pointeeType))
    return Type();
  if (parser.parseGreater())
    return Type();
  return get(parser.getContext(), pointeeType);
}

void PointerType::print(mlir::AsmPrinter &printer) const {
  printer << "<";
  printer.printType(getPointee());
  printer << '>';
}

Type BoolType::parse(mlir::AsmParser &parser) {
  return get(parser.getContext());
}

void BoolType::print(mlir::AsmPrinter &printer) const {}

Type StructType::parse(mlir::AsmParser &parser) {
  if (parser.parseLess())
    return Type();
  std::string typeName;
  if (parser.parseString(&typeName))
    return Type();

  llvm::SmallVector<Type> members;
  bool parsedBody = false;

  auto parseASTAttribute = [&](Attribute &attr) {
    auto optAttr = parser.parseOptionalAttribute(attr);
    if (optAttr.has_value()) {
      if (failed(*optAttr))
        return false;
      if (attr.isa<ASTFunctionDeclAttr>() || attr.isa<ASTRecordDeclAttr>() ||
          attr.isa<ASTVarDeclAttr>())
        return true;
      parser.emitError(parser.getCurrentLocation(),
                       "Unknown cir.struct attribute");
      return false;
    }
    return false;
  };

  while (mlir::succeeded(parser.parseOptionalComma())) {
    if (mlir::succeeded(parser.parseOptionalKeyword("incomplete")))
      continue;

    parsedBody = true;
    Type nextMember;
    auto optTy = parser.parseOptionalType(nextMember);
    if (optTy.has_value()) {
      if (failed(*optTy))
        return Type();
      members.push_back(nextMember);
      continue;
    }

    // Maybe it's an AST attribute: always last member, break.
    Attribute astAttr;
    if (parseASTAttribute(astAttr))
      break;
  }

  if (parser.parseGreater())
    return Type();
  auto sTy = get(parser.getContext(), members, typeName, parsedBody);
  return sTy;
}

void StructType::print(mlir::AsmPrinter &printer) const {
  printer << '<' << getTypeName();
  if (!getBody()) {
    printer << ", incomplete";
  } else {
    auto members = getMembers();
    if (!members.empty()) {
      printer << ", ";
      llvm::interleaveComma(getMembers(), printer);
    }
  }
  if (getAst()) {
    printer << ", ";
    printer.printAttributeWithoutType(*getAst());
  }
  printer << '>';
}

Type ArrayType::parse(mlir::AsmParser &parser) {
  if (parser.parseLess())
    return Type();
  Type eltType;
  if (parser.parseType(eltType))
    return Type();
  if (parser.parseKeyword("x"))
    return Type();

  uint64_t val = 0;
  if (parser.parseInteger(val).failed())
    return Type();

  if (parser.parseGreater())
    return Type();
  return get(parser.getContext(), eltType, val);
}

void ArrayType::print(mlir::AsmPrinter &printer) const {
  printer << '<';
  printer.printType(getEltType());
  printer << " x " << getSize();
  printer << '>';
}

//===----------------------------------------------------------------------===//
// Data Layout information for types
//===----------------------------------------------------------------------===//

llvm::TypeSize
BoolType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                            ::mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(8);
}

uint64_t
BoolType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                          ::mlir::DataLayoutEntryListRef params) const {
  return 1;
}

uint64_t
BoolType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                ::mlir::DataLayoutEntryListRef params) const {
  return 1;
}

llvm::TypeSize
PointerType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                               ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: improve this in face of address spaces
  return llvm::TypeSize::getFixed(64);
}

uint64_t
PointerType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                             ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: improve this in face of address spaces
  return 8;
}

uint64_t PointerType::getPreferredAlignment(
    const ::mlir::DataLayout &dataLayout,
    ::mlir::DataLayoutEntryListRef params) const {
  // FIXME: improve this in face of address spaces
  return 8;
}

llvm::TypeSize
ArrayType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                             ::mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypeSizeInBits(getEltType());
}

uint64_t
ArrayType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                           ::mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypeABIAlignment(getEltType());
}

uint64_t
ArrayType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                 ::mlir::DataLayoutEntryListRef params) const {
  return dataLayout.getTypePreferredAlignment(getEltType());
}

llvm::TypeSize
StructType::getTypeSizeInBits(const ::mlir::DataLayout &dataLayout,
                              ::mlir::DataLayoutEntryListRef params) const {
  if (!size)
    computeSizeAndAlignment(dataLayout);
  return llvm::TypeSize::getFixed(*size * 8);
}

uint64_t
StructType::getABIAlignment(const ::mlir::DataLayout &dataLayout,
                            ::mlir::DataLayoutEntryListRef params) const {
  if (!align)
    computeSizeAndAlignment(dataLayout);
  return *align;
}

uint64_t
StructType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                                  ::mlir::DataLayoutEntryListRef params) const {
  llvm_unreachable("NYI");
}

bool StructType::isPadded(const ::mlir::DataLayout &dataLayout) const {
  if (!padded)
    computeSizeAndAlignment(dataLayout);
  return *padded;
}

void StructType::computeSizeAndAlignment(
    const ::mlir::DataLayout &dataLayout) const {
  assert(!isOpaque() && "Cannot get layout of opaque structs");
  // Do not recompute.
  if (size || align || padded)
    return;

  // This is a similar algorithm to LLVM's StructLayout.
  unsigned structSize = 0;
  llvm::Align structAlignment{1};
  [[maybe_unused]] bool isPadded = false;
  unsigned numElements = getNumElements();
  auto members = getMembers();

  // Loop over each of the elements, placing them in memory.
  for (unsigned i = 0, e = numElements; i != e; ++i) {
    auto ty = members[i];

    // This matches LLVM since it uses the ABI instead of preferred alignment.
    const llvm::Align tyAlign =
        llvm::Align(getPacked() ? 1 : dataLayout.getTypeABIAlignment(ty));

    // Add padding if necessary to align the data element properly.
    if (!llvm::isAligned(tyAlign, structSize)) {
      isPadded = true;
      structSize = llvm::alignTo(structSize, tyAlign);
    }

    // Keep track of maximum alignment constraint.
    structAlignment = std::max(tyAlign, structAlignment);

    // FIXME: track struct size up to each element.
    // getMemberOffsets()[i] = structSize;

    // Consume space for this data item
    structSize += dataLayout.getTypeSize(ty);
  }

  // Add padding to the end of the struct so that it could be put in an array
  // and all array elements would be aligned correctly.
  if (!llvm::isAligned(structAlignment, structSize)) {
    isPadded = true;
    structSize = llvm::alignTo(structSize, structAlignment);
  }

  size = structSize;
  align = structAlignment.value();
  padded = isPadded;
}

//===----------------------------------------------------------------------===//
// IntType Definitions
//===----------------------------------------------------------------------===//

Type IntType::parse(mlir::AsmParser &parser) {
  auto *context = parser.getBuilder().getContext();
  auto loc = parser.getCurrentLocation();
  bool isSigned;
  unsigned width;

  if (parser.parseLess())
    return {};

  // Fetch integer sign.
  llvm::StringRef sign;
  if (parser.parseKeyword(&sign))
    return {};
  if (sign.equals("s"))
    isSigned = true;
  else if (sign.equals("u"))
    isSigned = false;
  else {
    parser.emitError(loc, "expected 's' or 'u'");
    return {};
  }

  if (parser.parseComma())
    return {};

  // Fetch integer size.
  if (parser.parseInteger(width))
    return {};
  if (width % 8 != 0) {
    parser.emitError(loc, "expected integer width to be a multiple of 8");
    return {};
  }
  if (width < 8 || width > 64) {
    parser.emitError(loc, "expected integer width to be from 8 up to 64");
    return {};
  }

  if (parser.parseGreater())
    return {};

  return IntType::get(context, width, isSigned);
}

void IntType::print(mlir::AsmPrinter &printer) const {
  auto sign = isSigned() ? 's' : 'u';
  printer << '<' << sign << ", " << getWidth() << '>';
}

llvm::TypeSize
IntType::getTypeSizeInBits(const mlir::DataLayout &dataLayout,
                           mlir::DataLayoutEntryListRef params) const {
  return llvm::TypeSize::getFixed(getWidth());
}

uint64_t IntType::getABIAlignment(const mlir::DataLayout &dataLayout,
                                  mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

uint64_t
IntType::getPreferredAlignment(const ::mlir::DataLayout &dataLayout,
                               ::mlir::DataLayoutEntryListRef params) const {
  return (uint64_t)(getWidth() / 8);
}

mlir::LogicalResult
IntType::verify(llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
                unsigned width, bool isSigned) {

  if (width < 8 || width > 64) {
    emitError() << "IntType only supports widths from 8 up to 64";
    return mlir::failure();
  }
  if (width % 8 != 0) {
    emitError() << "IntType width is not a multiple of 8";
    return mlir::failure();
  }

  return mlir::success();
}

//===----------------------------------------------------------------------===//
// FuncType Definitions
//===----------------------------------------------------------------------===//

mlir::LogicalResult
FuncType::verify(llvm::function_ref<mlir::InFlightDiagnostic()> emitError,
                 llvm::ArrayRef<mlir::Type> inputs,
                 llvm::ArrayRef<mlir::Type> results, bool varArg) {
  if (results.size() > 1)
    return emitError() << "functions only supports 0 or 1 results";
  if (varArg && inputs.empty())
    return emitError() << "functions must have at least one non-variadic input";
  return mlir::success();
}

FuncType FuncType::clone(TypeRange inputs, TypeRange results) const {
  return get(getContext(), results, inputs, isVarArg());
}

mlir::ParseResult
parseFuncTypeArgs(mlir::AsmParser &p, llvm::SmallVector<mlir::Type> &params,
                  bool &isVarArg) {
  isVarArg = false;
  // `(` `)`
  if (succeeded(p.parseOptionalRParen()))
    return mlir::success();

  // type (`,` type)* (`,` `...`)?
  mlir::Type type;
  if (p.parseType(type))
    return mlir::failure();
  params.push_back(type);
  while (succeeded(p.parseOptionalComma())) {
    if (succeeded(p.parseOptionalEllipsis())) {
      isVarArg = true;
      return p.parseRParen();
    }
    if (p.parseType(type))
      return mlir::failure();
    params.push_back(type);
  }

  return p.parseRParen();
}

void printFuncTypeArgs(mlir::AsmPrinter &p,
                              mlir::ArrayRef<mlir::Type> params,
                              bool isVarArg) {
  llvm::interleaveComma(params, p,
                        [&p](mlir::Type type) { p.printType(type); });
  if (isVarArg) {
    if (!params.empty())
      p << ", ";
    p << "...";
  }
  p << ')';
}

//===----------------------------------------------------------------------===//
// CIR Dialect
//===----------------------------------------------------------------------===//

void CIRDialect::registerTypes() {
  addTypes<
#define GET_TYPEDEF_LIST
#include "clang/CIR/Dialect/IR/CIROpsTypes.cpp.inc"
      >();
}
