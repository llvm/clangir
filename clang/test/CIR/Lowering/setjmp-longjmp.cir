// RUN: cir-opt %s -cir-to-llvm -o %t.ll
// RUN: FileCheck %s --input-file=%t.ll -check-prefix=MLIR
!s32i = !cir.int<s, 32>
!p32  = !cir.ptr<!s32i>

module {
  // MLIR: module {
  cir.func @test_setjmp(%arg0 : !p32) -> !s32i {

    // MLIR:  llvm.func @test_setjmp([[ARG0:%.*]]: !llvm.ptr) -> i32
    // MLIR-NEXT:    [[RET:%.*]] = llvm.call_intrinsic "llvm.eh.sjlj.setjmp"([[ARG0]]) : (!llvm.ptr) -> i32
    // MLIR-NEXT:    llvm.return [[RET:%.*]] : i32
    // MLIR-NEXT:  }
    %0 = cir.eh.setjmp builtin %arg0 : (!p32) -> !s32i
    cir.return %0 : !s32i
  }
  cir.func @test_setjmp_2(%arg0 : !p32) -> !s32i {

    // MLIR:  llvm.func @test_setjmp_2([[ARG0:%.*]]: !llvm.ptr) -> i32
    // MLIR-NEXT:    [[RET:%.*]] = llvm.call @_setjmp([[ARG0]]) : (!llvm.ptr) -> i32
    // MLIR-NEXT:    llvm.return [[RET:%.*]] : i32
    // MLIR-NEXT:  }
    %0 = cir.eh.setjmp %arg0 : (!p32) -> !s32i
    cir.return %0 : !s32i
  }
  // MLIR: }
}

