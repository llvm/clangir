// RUN: cir-opt %s -cir-to-llvm -reconcile-unrealized-casts -o %t.mlir
// RUN: FileCheck --input-file=%t.mlir %s

!s32i = !cir.int<s, 32>
module {
  cir.func @testFor() {
    %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
    %1 = cir.const(#cir.int<0> : !s32i) : !s32i
    cir.store %1, %0 : !s32i, cir.ptr <!s32i>
    cir.loop for(cond : {
      %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
      %3 = cir.const(#cir.int<10> : !s32i) : !s32i
      %4 = cir.cmp(lt, %2, %3) : !s32i, !s32i
      %5 = cir.cast(int_to_bool, %4 : !s32i), !cir.bool
      cir.yield %5 : !cir.bool
    }, step : {
      %2 = cir.load %0 : cir.ptr <!s32i>, !s32i
      %3 = cir.unary(inc, %2) : !s32i, !s32i
      cir.store %3, %0 : !s32i, cir.ptr <!s32i>
      cir.yield
    }) {
      cir.yield
    }
    cir.return
  }

  // CHECK:  llvm.func @testFor()
  //           [...]
  // CHECK:    llvm.br ^bb[[#COND:]]
  // CHECK:  ^bb[[#COND]]:
  //           [...]
  // CHECK:    llvm.cond_br %{{.+}}, ^bb[[#BODY:]], ^bb[[#EXIT:]]
  // CHECK:  ^bb[[#BODY]]:
  //           [...]
  // CHECK:    llvm.br ^bb[[#STEP:]]
  // CHECK:  ^bb[[#STEP]]:
  //           [...]
  // CHECK:    llvm.br ^bb[[#COND]]
  // CHECK:  ^bb[[#EXIT]]:
  //           [...]
  // CHECK:  }


  // Test while cir.loop operation lowering.
  cir.func @testWhile(%arg0: !s32i) {
    %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
    cir.store %arg0, %0 : !s32i, cir.ptr <!s32i>
    cir.loop while(cond : {
      %1 = cir.load %0 : cir.ptr <!s32i>, !s32i
      %2 = cir.const(#cir.int<10> : !s32i) : !s32i
      %3 = cir.cmp(lt, %1, %2) : !s32i, !s32i
      %4 = cir.cast(int_to_bool, %3 : !s32i), !cir.bool
      cir.yield %4 : !cir.bool
    }, step : {
      cir.yield
    }) {
      %1 = cir.load %0 : cir.ptr <!s32i>, !s32i
      %2 = cir.unary(inc, %1) : !s32i, !s32i
      cir.store %2, %0 : !s32i, cir.ptr <!s32i>
      cir.yield
    }
    cir.return
  }

  // CHECK:  llvm.func @testWhile
  //           [...]
  // CHECK:    llvm.br ^bb[[#COND:]]
  // CHECK:  ^bb[[#COND]]:
  //           [...]
  // CHECK:    llvm.cond_br %{{.+}}, ^bb[[#BODY:]], ^bb[[#EXIT:]]
  // CHECK:  ^bb[[#BODY]]:
  //           [...]
  // CHECK:    llvm.br ^bb[[#COND]]
  // CHECK:  ^bb[[#EXIT]]:
  //           [...]
  // CHECK:  }


  // Test do-while cir.loop operation lowering.
  cir.func @testDoWhile(%arg0: !s32i) {
    %0 = cir.alloca !s32i, cir.ptr <!s32i>, ["i", init] {alignment = 4 : i64}
    cir.store %arg0, %0 : !s32i, cir.ptr <!s32i>
    cir.loop dowhile(cond : {
      %1 = cir.load %0 : cir.ptr <!s32i>, !s32i
      %2 = cir.const(#cir.int<10> : !s32i) : !s32i
      %3 = cir.cmp(lt, %1, %2) : !s32i, !s32i
      %4 = cir.cast(int_to_bool, %3 : !s32i), !cir.bool
      cir.yield %4 : !cir.bool
    }, step : {
      cir.yield
    }) {
      %1 = cir.load %0 : cir.ptr <!s32i>, !s32i
      %2 = cir.unary(inc, %1) : !s32i, !s32i
      cir.store %2, %0 : !s32i, cir.ptr <!s32i>
      cir.yield
    }
    cir.return
  }

  // CHECK:  llvm.func @testDoWhile
  //           [...]
  // CHECK:    llvm.br ^bb[[#BODY:]]
  // CHECK:  ^bb[[#COND:]]:
  //           [...]
  // CHECK:    llvm.cond_br %{{.+}}, ^bb[[#BODY]], ^bb[[#EXIT:]]
  // CHECK:  ^bb[[#BODY]]:
  //           [...]
  // CHECK:    llvm.br ^bb[[#COND]]
  // CHECK:  ^bb[[#EXIT]]:
  //           [...]
  // CHECK:  }

}
