// RUN: cir-opt %s -cir-to-llvm -reconcile-unrealized-casts -o %t.cir
// RUN: FileCheck %s --input-file=%t.cir -check-prefix=MLIR

!s32i = !cir.int<s, 32>
!rec_A = !cir.record<union "A" {!s32i}>
!rec_anon2E0 = !cir.record<union "anon.0" {!rec_A} #cir.record.decl.ast>

module {
cir.func @_Z1xi(%arg0: !s32i) -> !s32i {
    %0 = cir.alloca !s32i, !cir.ptr<!s32i>, ["y", init] {alignment = 4 : i64}
    %1 = cir.alloca !s32i, !cir.ptr<!s32i>, ["__retval"] {alignment = 4 : i64}
    cir.store %arg0, %0 : !s32i, !cir.ptr<!s32i>
    %2 = cir.load %0 : !cir.ptr<!s32i>, !s32i
    %3 = cir.const #cir.int<0> : !s32i
    %4 = cir.cmp(gt, %2, %3) : !s32i, !cir.bool
    %5 = cir.ternary(%4, true {
      %7 = cir.const #cir.int<3> : !s32i
      cir.yield %7 : !s32i
    }, false {
      %7 = cir.const #cir.int<5> : !s32i
      cir.yield %7 : !s32i
    }) : (!cir.bool) -> !s32i
    cir.store %5, %1 : !s32i, !cir.ptr<!s32i>
    %6 = cir.load %1 : !cir.ptr<!s32i>, !s32i
    cir.return %6 : !s32i
  }

//      MLIR:  llvm.func @_Z1xi(%arg0: i32) -> i32
// MLIR-NEXT:    %0 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:    %1 = llvm.alloca %0 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr
// MLIR-NEXT:    %2 = llvm.mlir.constant(1 : index) : i64
// MLIR-NEXT:    %3 = llvm.alloca %2 x i32 {alignment = 4 : i64} : (i64) -> !llvm.ptr
// MLIR-NEXT:    llvm.store %arg0, %1 {{.*}}: i32, !llvm.ptr
// MLIR-NEXT:    %4 = llvm.load %1 {alignment = 4 : i64} : !llvm.ptr -> i32
// MLIR-NEXT:    %5 = llvm.mlir.constant(0 : i32) : i32
// MLIR-NEXT:    %6 = llvm.icmp "sgt" %4, %5 : i32
// MLIR-NEXT:    llvm.cond_br %6, ^bb1, ^bb2
// MLIR-NEXT:  ^bb1:  // pred: ^bb0
// MLIR-NEXT:    %7 = llvm.mlir.constant(3 : i32) : i32
// MLIR-NEXT:    llvm.br ^bb3(%7 : i32)
// MLIR-NEXT:  ^bb2:  // pred: ^bb0
// MLIR-NEXT:    %8 = llvm.mlir.constant(5 : i32) : i32
// MLIR-NEXT:    llvm.br ^bb3(%8 : i32)
// MLIR-NEXT:  ^bb3(%9: i32):  // 2 preds: ^bb1, ^bb2
// MLIR-NEXT:    llvm.store %9, %3 {{.*}}: i32, !llvm.ptr
// MLIR-NEXT:    %10 = llvm.load %3 {alignment = 4 : i64} : !llvm.ptr -> i32
// MLIR-NEXT:    llvm.return %10 : i32
// MLIR-NEXT:  }

cir.global external dso_local @a = #cir.zero : !cir.array<!rec_anon2E0 x 1> {alignment = 4 : i64}
cir.func no_proto dso_local @B() -> !rec_A {
  %0 = cir.alloca !rec_A, !cir.ptr<!rec_A>, ["__retval"] {alignment = 4 : i64}
  %1 = cir.get_global @a : !cir.ptr<!cir.array<!rec_anon2E0 x 1>>
  %2 = cir.cast bitcast %1 : !cir.ptr<!cir.array<!rec_anon2E0 x 1>> -> !cir.ptr<!cir.array<!rec_anon2E0 x 0>>
  %3 = cir.get_global @a : !cir.ptr<!cir.array<!rec_anon2E0 x 1>>
  %4 = cir.cast bitcast %3 : !cir.ptr<!cir.array<!rec_anon2E0 x 1>> -> !cir.ptr<!cir.array<!rec_anon2E0 x 0>>
  %5 = cir.cast array_to_ptrdecay %4 : !cir.ptr<!cir.array<!rec_anon2E0 x 0>> -> !cir.ptr<!rec_anon2E0>
  %6 = cir.const #cir.ptr<null> : !cir.ptr<!rec_anon2E0>
  %7 = cir.cmp(lt, %5, %6) : !cir.ptr<!rec_anon2E0>, !cir.bool
  %8 = cir.cast bool_to_int %7 : !cir.bool -> !s32i
  %9 = cir.ternary(%7, true {
    cir.yield %8 : !s32i
  }, false {
    %14 = cir.get_global @a : !cir.ptr<!cir.array<!rec_anon2E0 x 1>>
    %15 = cir.cast bitcast %14 : !cir.ptr<!cir.array<!rec_anon2E0 x 1>> -> !cir.ptr<!cir.array<!rec_anon2E0 x 0>>
    %16 = cir.const #cir.int<0> : !s32i
    %17 = cir.get_element %15[%16] : (!cir.ptr<!cir.array<!rec_anon2E0 x 0>>, !s32i) -> !cir.ptr<!rec_anon2E0>
    %18 = cir.get_member %17[0] {name = "B"} : !cir.ptr<!rec_anon2E0> -> !cir.ptr<!rec_A>
    %19 = cir.get_member %18[0] {name = "A"} : !cir.ptr<!rec_A> -> !cir.ptr<!s32i>
    %20 = cir.load align(4) %19 : !cir.ptr<!s32i>, !s32i
    cir.yield %20 : !s32i
  }) : (!cir.bool) -> !s32i
  %10 = cir.const #cir.int<0> : !s32i
  %11 = cir.binop(sub, %9, %10) nsw : !s32i
  %12 = cir.get_element %2[%11] : (!cir.ptr<!cir.array<!rec_anon2E0 x 0>>, !s32i) -> !cir.ptr<!rec_anon2E0>
  %13 = cir.load %0 : !cir.ptr<!rec_A>, !rec_A
  cir.return %13 : !rec_A
}
// MLIR-LABEL:   llvm.func @B() -> !llvm.struct<"union.A", (i32)>
// MLIR:           %[[VAL_0:.*]] = llvm.mlir.constant(1 : index) : i64
// MLIR:           %[[VAL_1:.*]] = llvm.alloca %[[VAL_0]] x !llvm.struct<"union.A", (i32)> {alignment = 4 : i64} : (i64) -> !llvm.ptr
// MLIR:           %[[VAL_2:.*]] = llvm.mlir.addressof @a : !llvm.ptr
// MLIR:           %[[VAL_3:.*]] = llvm.bitcast %[[VAL_2]] : !llvm.ptr to !llvm.ptr
// MLIR:           %[[VAL_4:.*]] = llvm.mlir.addressof @a : !llvm.ptr
// MLIR:           %[[VAL_5:.*]] = llvm.bitcast %[[VAL_4]] : !llvm.ptr to !llvm.ptr
// MLIR:           %[[VAL_6:.*]] = llvm.getelementptr %[[VAL_5]][0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"union.anon.0", (struct<"union.A", (i32)>)>
// MLIR:           %[[VAL_7:.*]] = llvm.mlir.zero : !llvm.ptr
// MLIR:           %[[VAL_8:.*]] = llvm.icmp "ult" %[[VAL_6]], %[[VAL_7]] : !llvm.ptr
// MLIR:           %[[VAL_9:.*]] = llvm.zext %[[VAL_8]] : i1 to i32
// MLIR:           llvm.cond_br %[[VAL_8]], ^bb1, ^bb2
// MLIR:         ^bb1:
// MLIR:           llvm.br ^bb3(%[[VAL_9]] : i32)
// MLIR:         ^bb2:
// MLIR:           %[[VAL_10:.*]] = llvm.mlir.addressof @a : !llvm.ptr
// MLIR:           %[[VAL_11:.*]] = llvm.bitcast %[[VAL_10]] : !llvm.ptr to !llvm.ptr
// MLIR:           %[[VAL_12:.*]] = llvm.mlir.constant(0 : i32) : i32
// MLIR:           %[[VAL_13:.*]] = llvm.sext %[[VAL_12]] : i32 to i64
// MLIR:           %[[VAL_14:.*]] = llvm.getelementptr %[[VAL_11]][0, %[[VAL_13]]] : (!llvm.ptr, i64) -> !llvm.ptr, !llvm.array<0 x struct<"union.anon.0", (struct<"union.A", (i32)>)>>
// MLIR:           %[[VAL_15:.*]] = llvm.bitcast %[[VAL_14]] : !llvm.ptr to !llvm.ptr
// MLIR:           %[[VAL_16:.*]] = llvm.bitcast %[[VAL_15]] : !llvm.ptr to !llvm.ptr
// MLIR:           %[[VAL_17:.*]] = llvm.load %[[VAL_16]] {alignment = 4 : i64} : !llvm.ptr -> i32
// MLIR:           llvm.br ^bb3(%[[VAL_17]] : i32)
// MLIR:         ^bb3(%[[VAL_18:.*]]: i32):
// MLIR:           %[[VAL_19:.*]] = llvm.mlir.constant(0 : i32) : i32
// MLIR:           %[[VAL_20:.*]] = llvm.sub %[[VAL_18]], %[[VAL_19]] overflow<nsw> : i32
// MLIR:           %[[VAL_21:.*]] = llvm.sext %[[VAL_20]] : i32 to i64
// MLIR:           %[[VAL_22:.*]] = llvm.getelementptr %[[VAL_3]][0, %[[VAL_21]]] : (!llvm.ptr, i64) -> !llvm.ptr, !llvm.array<0 x struct<"union.anon.0", (struct<"union.A", (i32)>)>>
// MLIR:           %[[VAL_23:.*]] = llvm.load %[[VAL_1]] {alignment = 4 : i64} : !llvm.ptr -> !llvm.struct<"union.A", (i32)>
// MLIR:           llvm.return %[[VAL_23]] : !llvm.struct<"union.A", (i32)>
// MLIR:         }
}
