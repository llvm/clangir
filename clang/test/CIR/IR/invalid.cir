// Test attempts to build bogus CIR
// RUN: cir-tool %s -verify-diagnostics -split-input-file

// expected-error@+2 {{'cir.cst' op nullptr expects pointer type}}
func.func @p0() {
  %1 = cir.cst(#cir.null : !cir.ptr<i32>) : i32
  cir.return
}

// -----

// expected-error@+2 {{'cir.cst' op result type ('i32') must be '!cir.bool' for 'true'}}
func.func @b0() {
  %1 = cir.cst(true) : i32
  cir.return
}

// -----

func.func @if0() {
  %0 = cir.cst(true) : !cir.bool
  // expected-error@+1 {{'cir.if' op  region control flow edge from Region #0 to parent results: source has 1 operands, but target successor needs 0}}
  cir.if %0 {
    %6 = cir.cst(3 : i32) : i32
    cir.yield %6 : i32
  }
  cir.return
}

// -----

func.func @yield0() {
  %0 = cir.cst(true) : !cir.bool
  cir.if %0 { // expected-error {{custom op 'cir.if' expected at least one block with cir.yield or cir.return}}
    cir.br ^a
  ^a:
  }
  cir.return
}

// -----

func.func @yieldfallthrough() {
  %0 = cir.cst(true) : !cir.bool
  cir.if %0 {
    cir.yield fallthrough // expected-error {{'cir.yield' op fallthrough only expected within 'cir.switch'}}
  }
  cir.return
}

// -----

func.func @yieldbreak() {
  %0 = cir.cst(true) : !cir.bool
  cir.if %0 {
    cir.yield break // expected-error {{shall be dominated by 'cir.loop' or 'cir.switch'}}
  }
  cir.return
}

// -----

func.func @yieldcontinue() {
  %0 = cir.cst(true) : !cir.bool
  cir.if %0 {
    cir.yield continue // expected-error {{shall be dominated by 'cir.loop'}}
  }
  cir.return
}

// -----

func.func @s0() {
  %1 = cir.cst(2 : i32) : i32
  cir.switch (%1 : i32) [
    case (equal, 5) {
      %2 = cir.cst(3 : i32) : i32
    }
  ] // expected-error {{blocks are expected to be explicitly terminated}}
  cir.return
}

// -----

func.func @s1() {
  %1 = cir.cst(2 : i32) : i32
  cir.switch (%1 : i32) [
    case (equal, 5) {
    }
  ] // expected-error {{case region shall not be empty}}
  cir.return
}
