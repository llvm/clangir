// RUN: cir-opt %s | FileCheck %s

// Test ClangIR exception handling parsing fix
// This demonstrates the syntax that was failing before the fix:
// 1. #cir.unwind attributes in catch blocks
// 2. cir.resume operations with location information

!void = !cir.void

#loc1 = loc("simple.cpp":10:5)
#loc2 = loc("simple.cpp":15:8)

module {
  // This represents C++ code like:
  //   void function() {
  //     RAII_Object obj;  // needs cleanup on exception
  //   }

  // CHECK-LABEL: @simple_cleanup_example
  cir.func @simple_cleanup_example() -> !void {
    cir.try {
      // Normal execution path
      cir.return
    } catch [#cir.unwind {
      // Cleanup/unwind region - not a real exception handler
      // Before the fix: "undefined symbol alias id 'loc1'"
      // CHECK: cir.resume
      cir.resume loc(#loc1)
    }]
    cir.return
  }

  // This represents C++ code like:
  //   void function() {
  //     try { /* some code */ }
  //     catch (...) { throw; }  // rethrow
  //   }

  // CHECK-LABEL: @rethrow_example
  cir.func @rethrow_example() -> !void {
    cir.try {
      cir.return
    } catch [#cir.unwind {
      // Rethrow - continue unwinding to find real handler
      // CHECK: cir.resume rethrow
      cir.resume rethrow loc(#loc2)
    }]
    cir.return
  }

  // CHECK-LABEL: @test_unwind_catch_parsing
  cir.func @test_unwind_catch_parsing() -> !void {
    cir.try {
      cir.return
    } catch [#cir.unwind {
      // CHECK: cir.resume
      cir.resume
    }]
    // CHECK: cir.return
    cir.return
  }
}
