//===- CIRAttrs.td - CIR dialect types ---------------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file declares the CIR dialect attributes.
//
//===----------------------------------------------------------------------===//

#ifndef CLANG_CIR_DIALECT_IR_CIRATTRS_TD
#define CLANG_CIR_DIALECT_IR_CIRATTRS_TD

include "mlir/IR/BuiltinAttributeInterfaces.td"
include "clang/CIR/Dialect/IR/CIREnumAttr.td"

include "clang/CIR/Dialect/IR/CIRDialect.td"
include "clang/CIR/Dialect/IR/CIRAttrConstraints.td"

include "clang/CIR/Interfaces/ASTAttrInterfaces.td"

//===----------------------------------------------------------------------===//
// CIR Attrs
//===----------------------------------------------------------------------===//

class CIR_Attr<string name, string attrMnemonic, list<Trait> traits = [],
               string baseCppClass = "::mlir::Attribute">
    : AttrDef<CIR_Dialect, name, traits, baseCppClass> {
  let mnemonic = attrMnemonic;
}

class CIR_TypedAttr<string name, string attrMnemonic, list<Trait> traits = []>
    : CIR_Attr<name, attrMnemonic, !listconcat(traits, [TypedAttrInterface])> {

  let parameters = (ins AttributeSelfTypeParameter<"">:$type);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type), [{
      return $_get(type.getContext(), type);
    }]>
  ];

  let assemblyFormat = [{}];
}

class CIR_UnitAttr<string name, string attrMnemonic, list<Trait> traits = []>
    : CIR_Attr<name, attrMnemonic, traits> {
  let returnType = "bool";
  let defaultValue = "false";
  let valueType = NoneType;
  let isOptional = 1;
}

//===----------------------------------------------------------------------===//
// SourceLanguageAttr
//===----------------------------------------------------------------------===//

def CIR_SourceLanguage : CIR_I32EnumAttr<"SourceLanguage", "source language", [
  I32EnumAttrCase<"C", 1, "c">,
  I32EnumAttrCase<"CXX", 2, "cxx">,
  I32EnumAttrCase<"OpenCLC", 3, "opencl_c">
]> {
  // The enum attr class is defined in `CIR_SourceLanguageAttr` below,
  // so that it can define extra class methods.
  let genSpecializedAttr = 0;
}

def CIR_SourceLanguageAttr : CIR_EnumAttr<CIR_SourceLanguage, "lang"> {
  let summary = "Module source language";
  let description = [{
    Represents the source language used to generate the module.

    Example:
    ```
    // Module compiled from C.
    module attributes {cir.lang = cir.lang<c>} {}
    // Module compiled from C++.
    module attributes {cir.lang = cir.lang<cxx>} {}
    ```

    Module source language attribute name is `cir.lang` is defined by
    `getSourceLanguageAttrName` method in CIRDialect class.
  }];

  let extraClassDeclaration = [{
    bool isC() const { return getValue() == SourceLanguage::C; }
    bool isCXX() const { return getValue() == SourceLanguage::CXX; }
    bool isOpenCLC() const { return getValue() == SourceLanguage::OpenCLC; }
  }];
}

//===----------------------------------------------------------------------===//
// OptInfoAttr
//===----------------------------------------------------------------------===//

def CIR_OptInfoAttr : CIR_Attr<"OptInfo", "opt_info"> {
  let summary =
    "A module-level attribute that holds the optimization information";
  let description = [{
    The `#cir.opt_info` attribute holds the optimization related information.
    Currently this attribute is a module-level attribute that gets attached to
    the module operation during CIRGen.

    The `level` parameter gives the optimization level. It must be an integer
    between 0 and 3, inclusive. It corresponds to the `OptimizationLevel` field
    within the `clang::CodeGenOptions` structure.

    The `size` parameter gives the code size optimization level. It must be an
    integer between 0 and 2, inclusive. It corresponds to the `OptimizeSize`
    field within the `clang::CodeGenOptions` structure.

    The `level` and `size` parameters correspond to the optimization level
    command line options passed to clang driver. The table below lists the
    current correspondance relationship:

    | Flag             | `level` | `size` |
    |------------------|---------|--------|
    | `-O0` or nothing | 0       | 0      |
    | `-O1`            | 1       | 0      |
    | `-O2`            | 2       | 0      |
    | `-O3`            | 3       | 0      |
    | `-Os`            | 2       | 1      |
    | `-Oz`            | 2       | 2      |

    Examples:

    ```mlir
    #cir.opt_info<level = 2, size = 0>  // -O2
    ```
  }];

  let parameters = (ins "unsigned":$level, "unsigned":$size);

  let assemblyFormat = [{
    `<` struct(params) `>`
  }];
  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// TypeSizeInfoAttr
//===----------------------------------------------------------------------===//

def CIR_TypeSizeInfoAttr : CIR_Attr<"TypeSizeInfo", "type_size_info"> {
  let summary = "the size of types in bits";
  let description = [{
    The `cir.type_size` attribute is attached to a module, recording lengths
    of various types if their names don't include it.

    It is worth noticing that size_t and pointers are considered to have the
    same length in Clang IR.

    Float and double types are represented by cir::SingleType and cir::
    DoubleType respectively, whose constructos don't need the type size as an
    argument. So their lengths are not stored here.

    Examples:

    ```mlir
    // sizeof(int) == 4, sizeof(size_t) == 8
    module attributes {
      cir.type_size = #cir.type_size<
        char = 8,
        int = 32,
        size_t = 64
      >
    } {}
    ```
  }];

  let parameters = (ins "unsigned":$char_size,
                        "unsigned":$int_size,
                        "unsigned":$size_t_size);

  let assemblyFormat = [{
    `<`
      `char` `=` $char_size `,`
      `int` `=` $int_size `,`
      `size_t` `=` $size_t_size
    `>`
  }];

  let extraClassDeclaration = [{
    unsigned getPointerSize() const;
    mlir::Type getCharType(mlir::MLIRContext *ctx) const;
    mlir::Type getUCharType(mlir::MLIRContext *ctx) const;
    mlir::Type getIntType(mlir::MLIRContext *ctx) const;
    mlir::Type getUIntType(mlir::MLIRContext *ctx) const;
    mlir::Type getSizeType(mlir::MLIRContext *ctx) const;
    mlir::Type getPtrDiffType(mlir::MLIRContext *ctx) const;
  }];

  let extraClassDefinition = [{
    unsigned $cppClass::getPointerSize() const { return getSizeTSize(); }

    mlir::Type $cppClass::getCharType(mlir::MLIRContext *ctx) const {
      return cir::IntType::get(ctx, getCharSize(), /*signed=*/true);
    }

    mlir::Type $cppClass::getUCharType(mlir::MLIRContext *ctx) const {
      return cir::IntType::get(ctx, getCharSize(), /*signed=*/false);
    }

    mlir::Type $cppClass::getIntType(mlir::MLIRContext *ctx) const {
      return cir::IntType::get(ctx, getIntSize(), /*signed=*/true);
    }

    mlir::Type $cppClass::getUIntType(mlir::MLIRContext *ctx) const {
      return cir::IntType::get(ctx, getIntSize(), /*signed=*/false);
    }

    mlir::Type $cppClass::getSizeType(mlir::MLIRContext *ctx) const {
      return cir::IntType::get(ctx, getSizeTSize(), /*signed=*/false);
    }

    mlir::Type $cppClass::getPtrDiffType(mlir::MLIRContext *ctx) const {
      return cir::IntType::get(ctx, getSizeTSize(), /*signed=*/true);
    }
  }];
}


//===----------------------------------------------------------------------===//
// BoolAttr
//===----------------------------------------------------------------------===//

def CIR_BoolAttr : CIR_Attr<"Bool", "bool", [TypedAttrInterface]> {
  let summary = "Represent true/false for !cir.bool types";
  let description = [{
    The BoolAttr represents a 'true' or 'false' value.
  }];

  let parameters = (ins AttributeSelfTypeParameter<
                        "", "cir::BoolType">:$type,
                    "bool":$value);

  let builders = [
    AttrBuilder<(ins "bool":$value), [{
      return $_get($_ctxt, cir::BoolType::get($_ctxt), value);
    }]>,
  ];

  let assemblyFormat = [{
    `<` $value `>`
  }];
}

//===----------------------------------------------------------------------===//
// ZeroAttr
//===----------------------------------------------------------------------===//

def CIR_ZeroAttr : CIR_TypedAttr<"Zero", "zero"> {
  let summary = "Attribute to represent zero initialization";
  let description = [{
    The ZeroAttr is used to indicate zero initialization on structs.
  }];
}

//===----------------------------------------------------------------------===//
// UndefAttr
//===----------------------------------------------------------------------===//

def CIR_UndefAttr : CIR_TypedAttr<"Undef", "undef"> {
  let summary = "Represent an undef constant";
  let description = [{
    The UndefAttr represents an undef constant, corresponding to LLVM's notion
    of undef.
  }];
}

//===----------------------------------------------------------------------===//
// PoisonAttr
//===----------------------------------------------------------------------===//

def CIR_PoisonAttr : CIR_TypedAttr<"Poison", "poison"> {
  let summary = "Represent a typed poison constant";
  let description = [{
    The PoisonAttr represents a typed poison constant, corresponding to LLVM's
    notion of poison.
  }];
}

//===----------------------------------------------------------------------===//
// ConstArrayAttr
//===----------------------------------------------------------------------===//

def CIR_ConstArrayAttr : CIR_Attr<"ConstArray", "const_array", [
  TypedAttrInterface
]> {
  let summary = "A constant array from ArrayAttr or StringRefAttr";
  let description = [{
    An CIR array attribute is an array of literals of the specified attr types.
  }];

  let parameters = (ins AttributeSelfTypeParameter<"">:$type,
                        "mlir::Attribute":$elts,
                        "int":$trailingZerosNum);

  // Define a custom builder for the type; that removes the need to pass
  // in an MLIRContext instance, as it can be infered from the `type`.
  let builders = [
    AttrBuilderWithInferredContext<(ins "cir::ArrayType":$type,
                                        "mlir::Attribute":$elts), [{
      int zeros = 0;
      auto typeSize = mlir::cast<cir::ArrayType>(type).getSize();
      if (auto str = mlir::dyn_cast<mlir::StringAttr>(elts))
        zeros = typeSize - str.size();
      else
        zeros = typeSize - mlir::cast<mlir::ArrayAttr>(elts).size();

      return $_get(type.getContext(), type, elts, zeros);
    }]>,
    AttrBuilderWithInferredContext<(ins "cir::ArrayType":$type,
                                        "mlir::Attribute":$elts,
                                        "int":$trailingZerosNum), [{
      return $_get(type.getContext(), type, elts, trailingZerosNum);
    }]>
  ];

  // Printing and parsing available in CIRDialect.cpp
  let hasCustomAssemblyFormat = 1;

  // Enable verifier.
  let genVerifyDecl = 1;

  let extraClassDeclaration = [{
    bool hasTrailingZeros() const { return getTrailingZerosNum() != 0; };
  }];
}

//===----------------------------------------------------------------------===//
// ConstVectorAttr
//===----------------------------------------------------------------------===//

def CIR_ConstVectorAttr : CIR_Attr<"ConstVector", "const_vector", [
  TypedAttrInterface
]> {
  let summary = "A constant vector from ArrayAttr";
  let description = [{
    A CIR vector attribute is an array of literals of the specified attribute
    types.
  }];

  let parameters = (ins AttributeSelfTypeParameter<"">:$type,
		        "mlir::ArrayAttr":$elts);

  // Define a custom builder for the type; that removes the need to pass in an
  // MLIRContext instance, as it can be inferred from the `type`.
  let builders = [
    AttrBuilderWithInferredContext<(ins "cir::VectorType":$type,
		                        "mlir::ArrayAttr":$elts), [{
      return $_get(type.getContext(), type, elts);
    }]>
  ];

  // Printing and parsing available in CIRDialect.cpp
  let hasCustomAssemblyFormat = 1;

  // Enable verifier.
  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// ConstRecordAttr
//===----------------------------------------------------------------------===//

def CIR_ConstRecordAttr : CIR_Attr<"ConstRecord", "const_record", [
  TypedAttrInterface
]> {
  let summary = "Represents a constant record";
  let description = [{
    Effectively supports "struct-like" constants. It's must be built from
    an `mlir::ArrayAttr `instance where each elements is a typed attribute
    (`mlir::TypedAttribute`).

    Example:
    ```
    cir.global external @rgb2 = #cir.const_record<{0 : i8,
                                                   5 : i64, #cir.null : !cir.ptr<i8>
                                                  }> : !cir.record<"", i8, i64, !cir.ptr<i8>>
    ```
  }];

  let parameters = (ins AttributeSelfTypeParameter<"">:$type,
                        "mlir::ArrayAttr":$members);

  let builders = [
    AttrBuilderWithInferredContext<(ins "cir::RecordType":$type,
                                        "mlir::ArrayAttr":$members), [{
      return $_get(type.getContext(), type, members);
    }]>
  ];

  let assemblyFormat = [{
    `<` custom<RecordMembers>($members) `>`
  }];

  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// IntegerAttr
//===----------------------------------------------------------------------===//

def CIR_IntAttr : CIR_Attr<"Int", "int", [TypedAttrInterface]> {
  let summary = "An Attribute containing a integer value";
  let description = [{
    An integer attribute is a literal attribute that represents an integral
    value of the specified integer type.
  }];

  let parameters = (ins
    AttributeSelfTypeParameter<"", "cir::IntTypeInterface">:$type,
    "llvm::APInt":$value
  );

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type,
                                        "const llvm::APInt &":$value), [{
      return $_get(type.getContext(),
                   mlir::cast<cir::IntTypeInterface>(type), value);
    }]>,
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type, "int64_t":$value), [{
      auto intType = mlir::cast<cir::IntTypeInterface>(type);
      mlir::APInt apValue(intType.getWidth(), value, intType.isSigned());
      return $_get(intType.getContext(), intType, apValue);
    }]>,
  ];

  let extraClassDeclaration = [{
    int64_t getSInt() const;
    uint64_t getUInt() const;
    bool isNullValue() const;
    bool isSigned() const;
    bool isUnsigned() const;
    uint64_t getBitWidth() const;
  }];

  let extraClassDefinition = [{
    int64_t $cppClass::getSInt() const {
      return getValue().getSExtValue();
    }

    uint64_t $cppClass::getUInt() const {
      return getValue().getZExtValue();
    }

    bool $cppClass::isNullValue() const {
      return getValue() == 0;
    }

    bool $cppClass::isSigned() const {
      return mlir::cast<IntTypeInterface>(getType()).isSigned();
    }

    bool $cppClass::isUnsigned() const {
      return mlir::cast<IntTypeInterface>(getType()).isUnsigned();
    }

    uint64_t $cppClass::getBitWidth() const {
      return mlir::cast<IntTypeInterface>(getType()).getWidth();
    }
  }];

  let assemblyFormat = [{
    `<` custom<IntLiteral>($value, ref($type)) `>`
  }];

  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// FPAttr
//===----------------------------------------------------------------------===//

def CIR_FPAttr : CIR_Attr<"FP", "fp", [TypedAttrInterface]> {
  let summary = "An attribute containing a floating-point value";
  let description = [{
    An fp attribute is a literal attribute that represents a floating-point
    value of the specified floating-point type. Supporting only CIR FP types.
  }];

  let parameters = (ins
    AttributeSelfTypeParameter<"", "::cir::FPTypeInterface">:$type,
    APFloatParameter<"">:$value
  );

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type,
                                        "const llvm::APFloat &":$value), [{
      return $_get(type.getContext(), mlir::cast<FPTypeInterface>(type), value);
    }]>
  ];

  let extraClassDeclaration = [{
    static FPAttr getZero(mlir::Type type);
  }];

  let assemblyFormat = [{
    `<` custom<FloatLiteral>($value, ref($type)) `>`
  }];

  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// ComplexAttr
//===----------------------------------------------------------------------===//

def CIR_ComplexAttr : CIR_Attr<"Complex", "complex", [TypedAttrInterface]> {
  let summary = "An attribute that contains a constant complex value";
  let description = [{
    The `#cir.complex` attribute contains a constant value of complex number
    type. The `real` parameter gives the real part of the complex number and the
    `imag` parameter gives the imaginary part of the complex number.

    The `real` and `imag` parameter must be either an IntAttr or an FPAttr that
    contains values of the same CIR type.
  }];

  let parameters = (ins
    AttributeSelfTypeParameter<"", "cir::ComplexType">:$type,
    "mlir::TypedAttr":$real, "mlir::TypedAttr":$imag);

  let builders = [
    AttrBuilderWithInferredContext<(ins "cir::ComplexType":$type,
                                        "mlir::TypedAttr":$real,
                                        "mlir::TypedAttr":$imag), [{
      return $_get(type.getContext(), type, real, imag);
    }]>,
  ];

  let genVerifyDecl = 1;

  let assemblyFormat = [{
    `<` qualified($real) `,` qualified($imag) `>`
  }];
}

//===----------------------------------------------------------------------===//
// ConstPointerAttr
//===----------------------------------------------------------------------===//

def CIR_ConstPtrAttr : CIR_Attr<"ConstPtr", "ptr", [TypedAttrInterface]> {
  let summary = "Holds a constant pointer value";
  let parameters = (ins
    AttributeSelfTypeParameter<"", "::cir::PointerType">:$type,
    "mlir::IntegerAttr":$value);
  let description = [{
    A pointer attribute is a literal attribute that represents an integral
    value of a pointer type.
  }];
  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type, "mlir::IntegerAttr":$value), [{
      return $_get(type.getContext(), mlir::cast<cir::PointerType>(type), value);
    }]>
  ];
  let extraClassDeclaration = [{
    bool isNullValue() const { return getValue().getInt() == 0; }
  }];

  let assemblyFormat = [{
    `<` custom<ConstPtr>($value) `>`
  }];
}

//===----------------------------------------------------------------------===//
// CmpThreeWayInfoAttr
//===----------------------------------------------------------------------===//

def CIR_CmpOrdering : CIR_I32EnumAttr<
  "CmpOrdering", "three-way comparison ordering kind", [
    I32EnumAttrCase<"Strong", 0, "strong">,
    I32EnumAttrCase<"Partial", 1, "partial">
]> {
  let genSpecializedAttr = 0;
}

def CIR_CmpThreeWayInfoAttr : CIR_Attr<"CmpThreeWayInfo", "cmp3way_info"> {
  let summary = "Holds information about a three-way comparison operation";
  let description = [{
    The `#cmp3way_info` attribute contains information about a three-way
    comparison operation `cir.cmp3way`.

    The `ordering` parameter gives the ordering kind of the three-way comparison
    operation. It may be either strong ordering or partial ordering.

    Given the two input operands of the three-way comparison operation `lhs` and
    `rhs`, the `lt`, `eq`, `gt`, and `unordered` parameters gives the result
    value that should be produced by the three-way comparison operation when the
    ordering between `lhs` and `rhs` is `lhs < rhs`, `lhs == rhs`, `lhs > rhs`,
    or neither, respectively.
  }];

  let parameters = (ins
    EnumParameter<CIR_CmpOrdering>:$ordering,
    "int64_t":$lt, "int64_t":$eq, "int64_t":$gt,
    OptionalParameter<"std::optional<int64_t>">:$unordered
  );

  let builders = [
    AttrBuilder<(ins "int64_t":$lt, "int64_t":$eq, "int64_t":$gt), [{
      return $_get($_ctxt, CmpOrdering::Strong, lt, eq, gt, std::nullopt);
    }]>,
    AttrBuilder<(ins "int64_t":$lt, "int64_t":$eq, "int64_t":$gt,
                     "int64_t":$unordered), [{
      return $_get($_ctxt, CmpOrdering::Partial, lt, eq, gt, unordered);
    }]>,
  ];

  let extraClassDeclaration = [{
    /// Get attribute alias name for this attribute.
    std::string getAlias() const;
  }];

  let assemblyFormat = [{
    `<`
      $ordering `,`
      `lt` `=` $lt `,`
      `eq` `=` $eq `,`
      `gt` `=` $gt
      (`,` `unordered` `=` $unordered^)?
    `>`
  }];

  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// DataMemberAttr
//===----------------------------------------------------------------------===//

def CIR_DataMemberAttr : CIR_Attr<"DataMember", "data_member", [
  TypedAttrInterface
]> {
  let summary = "Holds a constant data member pointer value";
  let parameters = (ins AttributeSelfTypeParameter<
                            "", "cir::DataMemberType">:$type,
                        OptionalParameter<
                            "std::optional<unsigned>">:$member_index);
  let description = [{
    A data member attribute is a literal attribute that represents a constant
    pointer-to-data-member value.

    The `member_index` parameter represents the index of the pointed-to member
    within its containing record. It is an optional parameter; lack of this
    parameter indicates a null pointer-to-data-member value.

    Example:
    ```
    #ptr = #cir.data_member<1> : !cir.data_member<!s32i in !rec_22Point22>

    #null = #cir.data_member<null> : !cir.data_member<!s32i in !rec_22Point22>
    ```
  }];

  let builders = [
    AttrBuilderWithInferredContext<(ins "cir::DataMemberType":$type), [{
      return $_get(type.getContext(), type, std::nullopt);
    }]>,
    AttrBuilderWithInferredContext<(ins "cir::DataMemberType":$type,
                                        "unsigned":$member_index), [{
      return $_get(type.getContext(), type, member_index);
    }]>,
  ];

  let genVerifyDecl = 1;

  let assemblyFormat = [{
    `<` ($member_index^):(`null`)? `>`
  }];

  let extraClassDeclaration = [{
    bool isNullPtr() const {
      return !getMemberIndex().has_value();
    }
  }];
}

//===----------------------------------------------------------------------===//
// MethodAttr
//===----------------------------------------------------------------------===//

def CIR_MethodAttr : CIR_Attr<"Method", "method", [TypedAttrInterface]> {
  let summary = "Holds a constant pointer-to-member-function value";
  let description = [{
    A method attribute is a literal attribute that represents a constant
    pointer-to-member-function value.

    If the member function is a non-virtual function, the `symbol` parameter
    gives the global symbol for the non-virtual member function.

    If the member function is a virtual function, the `vtable_offset` parameter
    gives the offset of the vtable entry corresponding to the virtual member
    function.

    `symbol` and `vtable_offset` cannot be present at the same time. If both of
    `symbol` and `vtable_offset` are not present, the attribute represents a
    null pointer constant.
  }];

  let parameters = (ins AttributeSelfTypeParameter<
                            "", "cir::MethodType">:$type,
                        OptionalParameter<
                            "std::optional<mlir::FlatSymbolRefAttr>">:$symbol,
                        OptionalParameter<
                            "std::optional<uint64_t>">:$vtable_offset);

  let builders = [
    AttrBuilderWithInferredContext<(ins "cir::MethodType":$type), [{
      return $_get(type.getContext(), type, std::nullopt, std::nullopt);
    }]>,
    AttrBuilderWithInferredContext<(ins "cir::MethodType":$type,
                                        "mlir::FlatSymbolRefAttr":$symbol), [{
      return $_get(type.getContext(), type, symbol, std::nullopt);
    }]>,
    AttrBuilderWithInferredContext<(ins "cir::MethodType":$type,
                                        "uint64_t":$vtable_offset), [{
      return $_get(type.getContext(), type, std::nullopt, vtable_offset);
    }]>,
  ];

  let hasCustomAssemblyFormat = 1;

  let genVerifyDecl = 1;

  let extraClassDeclaration = [{
    bool isNull() const {
      return !getSymbol().has_value() && !getVtableOffset().has_value();
    }

    bool isVirtual() const {
      return getVtableOffset().has_value();
    }
  }];
}

//===----------------------------------------------------------------------===//
// GlobalViewAttr
//===----------------------------------------------------------------------===//

def CIR_GlobalViewAttr : CIR_Attr<"GlobalView", "global_view", [
  TypedAttrInterface
]> {
  let summary = "Provides constant access to a global address";
  let description = [{
    Get constant address of global `symbol` and optionally apply offsets to
    access existing subelements. It provides a way to access globals from other
    global and always produces a pointer.

    The type of the input symbol can be different from `#cir.global_view`
    output type, since a given view of the global might require a static
    cast for initializing other globals.

    A list of indices can be optionally passed and each element subsequently
    indexes underlying types. For `symbol` types like `!cir.array`
    and `!cir.record`, it leads to the constant address of sub-elements, while
    for `!cir.ptr`, an offset is applied. The first index is relative to the
    original symbol type, not the produced one.

    The result type of this attribute may be an integer type. In such a case,
    the pointer to the referenced global is casted to an integer and this
    attribute represents the casted result.

    Example:

    ```
      cir.global external @s = @".str2": !cir.ptr<i8>
      cir.global external @x = #cir.global_view<@s> : !cir.ptr<i8>
      cir.global external @s_addr = #cir.global_view<@s> : !s64i

      cir.global external @rgb = #cir.const_array<[0 : i8, -23 : i8, 33 : i8] : !cir.array<i8 x 3>>
      cir.global external @elt_ptr = #cir.global_view<@rgb, [1]> : !cir.ptr<i8>
      cir.global external @table_of_ptrs = #cir.const_array<[#cir.global_view<@rgb, [1]> : !cir.ptr<i8>] : !cir.array<!cir.ptr<i8> x 1>>
    ```

    Note, that unlike LLVM IR's gep instruction, CIR doesn't add the leading zero index
    when it's known to be constant zero, e.g. for pointers, i.e. we use indexes exactly
    to access sub elements or for the offset. The leading zero index is added later in
    the lowering.

    Example:
    ```
    struct A {
      int a;
    };

    struct B:  virtual A {
      int b;
    };
    ```
    VTT for B:
    ```
    cir.global linkonce_odr @_ZTT1B = #cir.const_array<[#cir.global_view<@_ZTV1B, [0 : i32, 3 : i32]> : !cir.ptr<!u8i>]> : !cir.array<!cir.ptr<!u8i> x 1>
    ```
    The same for LLVM IR after CIR:
    ```
    @_ZTT1B = linkonce_odr global [1 x ptr] [ptr getelementptr inbounds ({ [3 x ptr] }, ptr @_ZTV1B, i32 0, i32 0, i32 3)], align 8
    ```
  }];

  let parameters = (ins AttributeSelfTypeParameter<"">:$type,
                        "mlir::FlatSymbolRefAttr":$symbol,
                        OptionalParameter<"mlir::ArrayAttr">:$indices);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type,
                                        "mlir::FlatSymbolRefAttr":$symbol,
                                        CArg<"mlir::ArrayAttr", "{}">:$indices), [{
      return $_get(type.getContext(), type, symbol, indices);
    }]>
  ];

  // let genVerifyDecl = 1;
  let assemblyFormat = [{
    `<`
      $symbol
      (`,` $indices^)?
    `>`
  }];
}

//===----------------------------------------------------------------------===//
// TypeInfoAttr
//===----------------------------------------------------------------------===//

def CIR_TypeInfoAttr : CIR_Attr<"TypeInfo", "typeinfo", [TypedAttrInterface]> {
  let summary = "Represents a typeinfo used for RTTI";
  let description = [{
    The typeinfo data for a given class is stored into an ArrayAttr. The
    layout is determined by the C++ ABI used (clang only implements
    itanium on CIRGen).

    The verifier enforces that the output type is always a `!cir.record`,
    and that the ArrayAttr element types match the equivalent member type
    for the resulting record, i.e, a GlobalViewAttr for symbol reference or
    an IntAttr for flags.

    Example:

    ```
    cir.global "private" external @_ZTVN10__cxxabiv120__si_class_type_infoE : !cir.ptr<i32>

    cir.global external @type_info_B = #cir.typeinfo<<
      {#cir.global_view<@_ZTVN10__cxxabiv120__si_class_type_infoE, [2]> : !cir.ptr<i8>}
    >> : !cir.record<"", !cir.ptr<i8>>
    ```
  }];

  let parameters = (ins AttributeSelfTypeParameter<"">:$type,
                        "mlir::ArrayAttr":$data);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type,
                                        "mlir::ArrayAttr":$data), [{
      return $_get(type.getContext(), type, data);
    }]>
  ];

  // Checks record element types should match the array for every equivalent
  // element type.
  let genVerifyDecl = 1;
  let assemblyFormat = [{
    `<` custom<RecordMembers>($data) `>`
  }];
}

//===----------------------------------------------------------------------===//
// VTableAttr
//===----------------------------------------------------------------------===//

def VTableAttr : CIR_Attr<"VTable", "vtable", [TypedAttrInterface]> {
  let summary = "Represents a C++ vtable";
  let description = [{
    Wraps a #cir.const_record containing vtable data.

    Example:
    ```
    cir.global linkonce_odr @_ZTV1B = #cir.vtable<<
        {#cir.const_array<[#cir.null : !cir.ptr<i8>,
         #cir.global_view<@_ZTI1B> : !cir.ptr<i8>,
         #cir.global_view<@_ZN1BD1Ev> : !cir.ptr<i8>,
         #cir.global_view<@_ZN1BD0Ev> : !cir.ptr<i8>,
         #cir.global_view<@_ZNK1A5quackEv> : !cir.ptr<i8>]>
         : !cir.array<!cir.ptr<i8> x 5>}>>
      : !cir.record<"", !cir.array<!cir.ptr<i8> x 5>>
    ```
  }];

  // `vtable_data` is const record with one element, containing an array of
  // vtable information.
  let parameters = (ins AttributeSelfTypeParameter<"">:$type,
                        "mlir::ArrayAttr":$vtable_data);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::Type":$type,
                                        "mlir::ArrayAttr":$vtable_data), [{
      return $_get(type.getContext(), type, vtable_data);
    }]>
  ];

  let genVerifyDecl = 1;
  let assemblyFormat = [{
    `<` custom<RecordMembers>($vtable_data) `>`
  }];
}

//===----------------------------------------------------------------------===//
// DynamicCastInfoAttr
//===----------------------------------------------------------------------===//

def CIR_DynamicCastInfoAttr : CIR_Attr<"DynamicCastInfo", "dyn_cast_info"> {
  let summary = "ABI specific information about a dynamic cast";
  let description = [{
    Provide ABI specific information about a dynamic cast operation.

    The `srcRtti` and the `destRtti` parameters give the RTTI of the source
    record type and the destination record type, respectively.

    The `runtimeFunc` parameter gives the `__dynamic_cast` function which is
    provided by the runtime. The `badCastFunc` parameter gives the
    `__cxa_bad_cast` function which is also provided by the runtime.

    The `offsetHint` parameter gives the hint value that should be passed to the
    `__dynamic_cast` runtime function.
  }];

  let parameters = (ins
    CIR_GlobalViewAttr:$srcRtti,
    CIR_GlobalViewAttr:$destRtti,
    "mlir::FlatSymbolRefAttr":$runtimeFunc,
    "mlir::FlatSymbolRefAttr":$badCastFunc,
    CIR_IntAttr:$offsetHint
  );

  let builders = [
    AttrBuilderWithInferredContext<(ins "GlobalViewAttr":$srcRtti,
                                        "GlobalViewAttr":$destRtti,
                                        "mlir::FlatSymbolRefAttr":$runtimeFunc,
                                        "mlir::FlatSymbolRefAttr":$badCastFunc,
                                        "IntAttr":$offsetHint), [{
      return $_get(srcRtti.getContext(), srcRtti, destRtti, runtimeFunc,
                   badCastFunc, offsetHint);
    }]>,
  ];

  let genVerifyDecl = 1;
  let assemblyFormat = [{
    `<`
      qualified($srcRtti) `,` qualified($destRtti) `,`
      $runtimeFunc `,` $badCastFunc `,` qualified($offsetHint)
    `>`
  }];

  let extraClassDeclaration = [{
    /// Get attribute alias name for this attribute.
    std::string getAlias() const;
  }];
}

//===----------------------------------------------------------------------===//
// AddressSpaceAttr
//===----------------------------------------------------------------------===//

def CIR_AddressSpaceAttr :  CIR_EnumAttr<CIR_AddressSpace, "address_space"> {
  let builders = [
    AttrBuilder<(ins "clang::LangAS":$langAS), [{
      return $_get($_ctxt, cir::toCIRAddressSpace(langAS));
    }]>
  ];

  let assemblyFormat = [{
    `` custom<AddressSpaceValue>($value)
  }];

  let defaultValue = "cir::AddressSpace::Default";

  let extraClassDeclaration = [{
    bool isLang() const;
    bool isTarget() const;
    unsigned getTargetValue() const;
    unsigned getAsUnsignedValue() const;
  }];

  let extraClassDefinition = [{
    unsigned $cppClass::getAsUnsignedValue() const {
      return static_cast<unsigned>(getValue());
    }

    bool $cppClass::isLang() const {
      return cir::isLangAddressSpace(getValue());
    }

    bool $cppClass::isTarget() const {
      return cir::isTargetAddressSpace(getValue());
    }

    unsigned $cppClass::getTargetValue() const {
      return cir::getTargetAddressSpaceValue(getValue());
    }
  }];
}

//===----------------------------------------------------------------------===//
// AST Wrappers
//===----------------------------------------------------------------------===//

class CIR_AST<string name, string prefix, list<Trait> traits = []>
    : CIR_Attr<!strconcat("AST", name), !strconcat(prefix, ".ast"), traits> {
  string clang_name = !strconcat("const clang::", name, " *");

  let summary = !strconcat("Wraps a '", clang_name, "' AST node.");
  let description = [{
    Operations optionally refer to this node, they could be available depending
    on the CIR lowering stage. Whether it's attached to the appropriated
    CIR operation is delegated to the operation verifier.

    This always implies a non-null AST reference (verified).
  }];
  let parameters = (ins clang_name:$ast);

  // Printing and parsing available in CIRDialect.cpp
  let hasCustomAssemblyFormat = 1;

  // Enable verifier.
  let genVerifyDecl = 1;

  let extraClassDefinition = [{
    ::mlir::Attribute $cppClass::parse(::mlir::AsmParser &parser,
                                       ::mlir::Type type) {
      // We cannot really parse anything AST related at this point
      // since we have no serialization/JSON story.
      return $cppClass::get(parser.getContext(), nullptr);
    }

    void $cppClass::print(::mlir::AsmPrinter &printer) const {
      // Nothing to print besides the mnemonics.
    }

    llvm::LogicalResult $cppClass::verify(
        ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError,
        }] # clang_name # [{ decl) {
      return mlir::success();
    }
  }];
}

def CIR_ASTDeclAttr : CIR_AST<"Decl", "decl", [ASTDeclInterface]>;

def CIR_ASTFunctionDeclAttr : CIR_AST<"FunctionDecl", "function.decl",[
  ASTFunctionDeclInterface
]>;

def CIR_ASTCXXMethodDeclAttr : CIR_AST<"CXXMethodDecl", "cxxmethod.decl", [
  ASTCXXMethodDeclInterface
]>;

def CIR_ASTCXXConstructorDeclAttr
  : CIR_AST<"CXXConstructorDecl","cxxconstructor.decl", [
    ASTCXXConstructorDeclInterface
  ]>;

def CIR_ASTCXXConversionDeclAttr
  : CIR_AST<"CXXConversionDecl", "cxxconversion.decl", [
    ASTCXXConversionDeclInterface
  ]>;

def CIR_ASTCXXDestructorDeclAttr
  : CIR_AST<"CXXDestructorDecl", "cxxdestructor.decl", [
    ASTCXXDestructorDeclInterface
  ]>;

def CIR_ASTVarDeclAttr : CIR_AST<"VarDecl", "var.decl", [
  ASTVarDeclInterface
]>;

def CIR_ASTTypeDeclAttr : CIR_AST<"TypeDecl", "type.decl", [
  ASTTypeDeclInterface
]>;

def CIR_ASTTagDeclAttr : CIR_AST<"TagDecl", "tag.decl", [
  ASTTagDeclInterface
]>;

def CIR_ASTRecordDeclAttr : CIR_AST<"RecordDecl", "record.decl", [
  ASTRecordDeclInterface
]>;

def CIR_ASTExprAttr : CIR_AST<"Expr", "expr", [
  ASTExprInterface
]>;

def CIR_ASTCallExprAttr : CIR_AST<"CallExpr", "call.expr", [
  ASTCallExprInterface
]>;


//===----------------------------------------------------------------------===//
// VisibilityAttr
//===----------------------------------------------------------------------===//

def CIR_VisibilityKind : CIR_I32EnumAttr<"VisibilityKind", "C/C++ visibility", [
  I32EnumAttrCase<"Default", 0, "default">,
  I32EnumAttrCase<"Hidden", 1, "hidden">,
  I32EnumAttrCase<"Protected", 2, "protected">
]> {
  let genSpecializedAttr = 0;
}

def CIR_VisibilityAttr : CIR_EnumAttr<CIR_VisibilityKind, "visibility"> {
  let summary = "Visibility attribute";
  let description = [{
    Visibility attributes.
  }];

  let cppClassName = "VisibilityAttr";

  let skipDefaultBuilders = 1;
  let builders = [
    AttrBuilder<(ins CArg<"VisibilityKind",
                          "cir::VisibilityKind::Default">:$value), [{
      return $_get($_ctxt, value);
    }]>
  ];

  let assemblyFormat = [{
    $value
  }];

  let extraClassDeclaration = [{
    bool isDefault() const { return getValue() == VisibilityKind::Default; };
    bool isHidden() const { return getValue() == VisibilityKind::Hidden; };
    bool isProtected() const { return getValue() == VisibilityKind::Protected; };
  }];
}

//===----------------------------------------------------------------------===//
// ExtraFuncAttr
//===----------------------------------------------------------------------===//

def CIR_ExtraFuncAttr : CIR_Attr<"ExtraFuncAttributes", "extra"> {
  let summary = "Represents aggregated attributes for a function";
  let description = [{
    This is a wrapper of attribute dictionary that contains extra attributes of
    a function.
  }];

  let parameters = (ins "mlir::DictionaryAttr":$elements);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::DictionaryAttr":$elements), [{
      return $_get(elements.getContext(), elements);
    }]>
  ];

  let assemblyFormat = [{ `(` $elements `)` }];
}

//===----------------------------------------------------------------------===//
// InlineAttr
//===----------------------------------------------------------------------===//

def CIR_InlineKind : CIR_I32EnumAttr<"InlineKind", "inlineKind", [
  I32EnumAttrCase<"NoInline", 1, "no">,
  I32EnumAttrCase<"AlwaysInline", 2, "always">,
  I32EnumAttrCase<"InlineHint", 3, "hint">
]> {
  let genSpecializedAttr = 0;
}

def CIR_InlineAttr : CIR_EnumAttr<CIR_InlineKind, "inline"> {
  let summary = "Inline attribute";
  let description = [{
    Inline attributes represents user directives.
  }];

  let cppClassName = "InlineAttr";

  let extraClassDeclaration = [{
    bool isNoInline() const { return getValue() == InlineKind::NoInline; };
    bool isAlwaysInline() const { return getValue() == InlineKind::AlwaysInline; };
    bool isInlineHint() const { return getValue() == InlineKind::InlineHint; };
  }];
}

//===----------------------------------------------------------------------===//
// Unit Function Attributes
//===----------------------------------------------------------------------===//

def CIR_OptNoneAttr : CIR_UnitAttr<"OptNone", "optnone"> {
  let storageType = [{ OptNoneAttr }];
}

def CIR_NoThrowAttr : CIR_UnitAttr<"NoThrow", "nothrow"> {
  let storageType = [{ NoThrowAttr }];
}

def CIR_ConvergentAttr : CIR_UnitAttr<"Convergent", "convergent"> {
  let storageType = [{ ConvergentAttr }];
}

//===----------------------------------------------------------------------===//
// UWTableAttr
//===----------------------------------------------------------------------===//

def CIR_UWTableKind : CIR_I32EnumAttr<"UWTableKind", "Unwind table kind", [
  I32EnumAttrCase<"None", 0, "none">,
  I32EnumAttrCase<"Sync", 1, "sync">,
  I32EnumAttrCase<"Async", 2, "async">
]> {
  let genSpecializedAttr = 0;
}

def CIR_UWTableAttr : CIR_EnumAttr<CIR_UWTableKind, "uwtable"> {
  let summary = "Unwind table kind attribute";
  let description = [{
    The kind of unwind tables to generate for a function. `none` means no unwind
    tables are generated; `sync` means synchronous unwind tables (that are only
    valid at call boundaries), and `async` means asynchronous unwind tables
    (that are valid at all instructions). When applied to a module, this
    controls the unwind table generation for any synthesized functions.
  }];

  let cppClassName = "UWTableAttr";
}

class CIR_GlobalCtorDtor<string name, string attrMnemonic>
    : CIR_Attr<"Global" # name, "global_" # attrMnemonic> {
  let parameters = (ins "mlir::StringAttr":$name, "int":$priority);

  let skipDefaultBuilders = 1;
  let builders = [
    AttrBuilder<(ins
        "llvm::StringRef":$name,
        CArg<"int", "cir::DefaultGlobalCtorDtorPriority">:$priority), [{
      return $_get($_ctxt, mlir::StringAttr::get($_ctxt, name), priority);
    }]>,
    AttrBuilderWithInferredContext<(ins
        "mlir::StringAttr":$name,
        CArg<"int", "cir::DefaultGlobalCtorDtorPriority">:$priority), [{
      return $_get(name.getContext(), name, priority);
    }]>
  ];

  let assemblyFormat = [{
    `<` $name `,` $priority `>`
  }];

  let extraClassDeclaration = [{
    bool isDefaultPriority() const {
      return getPriority() == cir::DefaultGlobalCtorDtorPriority;
    };
  }];
}

def CIR_GlobalCtorAttr : CIR_GlobalCtorDtor<"Ctor", "ctor"> {
  let summary = "Marks a function as a global constructor";
  let description = [{
    Marks the function as a global constructor in the module's constructor list.
    It will be executed before main() is called.
  }];
}

def CIR_GlobalDtorAttr : CIR_GlobalCtorDtor<"Dtor", "dtor"> {
  let summary = "Marks a function as a global destructor";
  let description = [{
      Marks a function as a global destructor in the module dtors list.
      The function will be executed before the module unloading.
  }];
}

def CIR_BitfieldInfoAttr : CIR_Attr<"BitfieldInfo", "bitfield_info"> {
  let summary = "Represents a bit field info";
  let description = [{
    Holds the next information about bitfields: name, storage type, a bitfield size
    and position in the storage, if the bitfield is signed or not.
  }];
  let parameters = (ins "mlir::StringAttr":$name,
                        "mlir::Type":$storage_type,
                        "uint64_t":$size,
                        "uint64_t":$offset,
                        "bool":$is_signed);

  let assemblyFormat = "`<` struct($name, $storage_type, $size, $offset, $is_signed) `>`";

  let builders = [
    AttrBuilder<(ins "llvm::StringRef":$name,
                     "mlir::Type":$storage_type,
                     "uint64_t":$size,
                     "uint64_t":$offset,
                     "bool":$is_signed
                     ), [{
      return $_get($_ctxt, mlir::StringAttr::get($_ctxt, name), storage_type, size, offset, is_signed);
    }]>
  ];
}

//===----------------------------------------------------------------------===//
// AnnotationAttr
//===----------------------------------------------------------------------===//

def CIR_AnnotationAttr : CIR_Attr<"Annotation", "annotation"> {
  let summary = "Annotation attribute for global variables and functions";
  let description = [{
    Represent C/C++ attribute of annotate in CIR.
    Example C code:
    ```
     int *a __attribute__((annotate("testptr", "21", 12 )));
    ```
    In this example code, the `AnnotationAttr` has annotation name "testptr",
    and arguments "21" and 12 constitutes an `ArrayAttr` type parameter `args`
    for global variable `a`.
    In CIR, the attribute for above annotation looks like:
    ```
    [#cir.annotation<name = "withargs", args = ["21", 12 : i32]>]
    ```
  }];

  // The parameter args is empty when there is no arg.
  let parameters = (ins "mlir::StringAttr":$name,
                        "mlir::ArrayAttr":$args);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::StringAttr":$name,
                                        CArg<"mlir::ArrayAttr", "{}">:$args), [{
      return $_get(name.getContext(), name, args);
    }]>
  ];

  let assemblyFormat = "`<` struct($name, $args) `>`";

  let extraClassDeclaration = [{
    bool isNoArgs() const { return getArgs().empty(); };
  }];
}

//===----------------------------------------------------------------------===//
// GlobalAnnotationValuesAttr
//===----------------------------------------------------------------------===//

def CIR_GlobalAnnotationValuesAttr : CIR_Attr<"GlobalAnnotationValues",
  "global_annotations"
> {
  let summary = "Array of annotations, each element consists of name of"
                "a global var or func and one of its annotations";
  let description = [{
    This is annotation value array, which holds the annotation
    values for all global variables and functions in a module.
    This array is used to create the initial value of a global annotation
    metadata variable in LLVM IR.
    Example C code:
    ```
    double *a __attribute__((annotate("withargs", "21", 12 )));
    int *b __attribute__((annotate("withargs", "21", 12 )));
    void *c __attribute__((annotate("noargvar")));
    void foo(int i) __attribute__((annotate("noargfunc"))) {}
    ```
    After CIR lowering prepare pass, compiler generates a
    `GlobalAnnotationValuesAttr` like the following:
    ```
    #cir<global_annotations [
      ["a", #cir.annotation<name = "withargs", args = ["21", 12 : i32]>],
      ["b", #cir.annotation<name = "withargs", args = ["21", 12 : i32]>],
      ["c", #cir.annotation<name = "noargvar", args = []>],
      ["foo", #cir.annotation<name = "noargfunc", args = []>]]>
    ```
  }];

  let parameters = (ins "mlir::ArrayAttr":$annotations);

  let builders = [
    AttrBuilderWithInferredContext<(ins "mlir::ArrayAttr":$annotations), [{
      return $_get(annotations.getContext(), annotations);
    }]>
  ];

  let assemblyFormat = [{ $annotations }];

  // Enable verifier.
  let genVerifyDecl = 1;
}

//===----------------------------------------------------------------------===//
// AddressPointAttr
//===----------------------------------------------------------------------===//

def CIR_AddressPointAttr : CIR_Attr<"AddressPoint", "address_point"> {
  let summary = "Address point attribute";

  let description = [{
  Attribute specifying the address point within a C++ virtual table (vtable).

  The `index` (vtable index) parameter identifies which vtable to use within a vtable
  group, while the `offset` (address point index) specifies the offset within
  that vtable where the address begins.

  Example:
  ```mlir
  cir.global linkonce_odr @_ZTV1B = ...
  ...
  %3 = cir.vtable.address_point(@_ZTV1B, address_point = <index = 0, offset = 2>)) : !cir.ptr<!cir.ptr<() -> i32>>
  ```
  }];

  let parameters = (ins "int32_t":$index,
                        "int32_t":$offset);

  let assemblyFormat = [{
    `<` struct($index, $offset) `>`
  }];
}

include "clang/CIR/Dialect/IR/CIRTBAAAttrs.td"

include "clang/CIR/Dialect/IR/CIROpenCLAttrs.td"
include "clang/CIR/Dialect/IR/CIRCUDAAttrs.td"

#endif // CLANG_CIR_DIALECT_IR_CIRATTRS_TD
