//===-- CIROps.td - CIR dialect definition -----------------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
///
/// \file
/// Definition of the CIR dialect
///
//===----------------------------------------------------------------------===//

#ifndef LLVM_CLANG_CIR_DIALECT_IR_CIROPS
#define LLVM_CLANG_CIR_DIALECT_IR_CIROPS

include "clang/CIR/Dialect/IR/CIRDialect.td"
include "clang/CIR/Dialect/IR/CIRTypes.td"
include "clang/CIR/Dialect/IR/CIRTypeConstraints.td"
include "clang/CIR/Dialect/IR/CIRAttrs.td"
include "clang/CIR/Dialect/IR/CIRAttrConstraints.td"


include "clang/CIR/Interfaces/ASTAttrInterfaces.td"
include "clang/CIR/Interfaces/CIROpInterfaces.td"
include "clang/CIR/Interfaces/CIRLoopOpInterface.td"

include "mlir/Interfaces/ControlFlowInterfaces.td"
include "mlir/Interfaces/FunctionInterfaces.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/LoopLikeInterface.td"
include "mlir/Interfaces/MemorySlotInterfaces.td"
include "mlir/Interfaces/SideEffectInterfaces.td"

include "mlir/IR/BuiltinAttributeInterfaces.td"
include "mlir/IR/EnumAttr.td"
include "mlir/IR/SymbolInterfaces.td"
include "mlir/IR/CommonAttrConstraints.td"

//===----------------------------------------------------------------------===//
// CIR Ops
//===----------------------------------------------------------------------===//

// LLVMLoweringInfo is used by cir-tablegen to generate LLVM lowering logic
// automatically for CIR operations. The `llvmOp` field gives the name of the
// LLVM IR dialect operation that the CIR operation will be lowered to. The
// input arguments of the CIR operation will be passed in the same order to the
// lowered LLVM IR operation.
//
// Example:
//
// For the following CIR operation definition:
//
//   def FooOp : CIR_Op<"foo"> {
//     // ...
//     let arguments = (ins CIR_AnyType:$arg1, CIR_AnyType:$arg2);
//     let llvmOp = "BarOp";
//   }
//
// cir-tablegen will generate LLVM lowering code for the FooOp similar to the
// following:
//
//   class CIRFooOpLowering
//       : public mlir::OpConversionPattern<cir::FooOp> {
//   public:
//     using OpConversionPattern<cir::FooOp>::OpConversionPattern;
//
//     mlir::LogicalResult matchAndRewrite(
//         cir::FooOp op,
//         OpAdaptor adaptor,
//         mlir::ConversionPatternRewriter &rewriter) const override {
//       rewriter.replaceOpWithNewOp<mlir::LLVM::BarOp>(
//         op, adaptor.getOperands()[0], adaptor.getOperands()[1]);
//       return mlir::success();
//     }
//   }
//
// If you want fully customized LLVM IR lowering logic, simply exclude the
// `llvmOp` field from your CIR operation definition.
class LLVMLoweringInfo {
  string llvmOp = "";
}

class CIR_Op<string mnemonic, list<Trait> traits = []> :
    Op<CIR_Dialect, mnemonic, traits>, LLVMLoweringInfo;

//===----------------------------------------------------------------------===//
// CIR Operation Traits
//===----------------------------------------------------------------------===//

class HasAtMostOneOfAttrsPred<list<string> names> :
  CPred<!foldl("0", names, acc, name,  acc # " + (" # name # " ? 1 : 0)")
        # " <= 1">;

class HasAtMostOneOfAttrs<list<string> names> : PredOpTrait<
  "has only one of the optional attributes: " # !interleave(names, ", "),
  HasAtMostOneOfAttrsPred<!foreach(name, names, "$" # name)>
>;


//===----------------------------------------------------------------------===//
// CastOp
//===----------------------------------------------------------------------===//

def CIR_CastKind : CIR_I32EnumAttr<"CastKind", "cast kind", [
  I32EnumAttrCase<"bitcast", 1>,
  // CK_LValueBitCast
  // CK_LValueToRValueBitCast
  // CK_LValueToRValue
  // CK_NoOp
  // CK_BaseToDerived
  // CK_DerivedToBase
  // CK_UncheckedDerivedToBase
  // CK_Dynamic
  // CK_ToUnion
  I32EnumAttrCase<"array_to_ptrdecay", 11>,
  // CK_FunctionToPointerDecay
  // CK_NullToPointer
  // CK_NullToMemberPointer
  // CK_BaseToDerivedMemberPointer
  // CK_DerivedToBaseMemberPointer
  I32EnumAttrCase<"member_ptr_to_bool", 17>,
  // CK_ReinterpretMemberPointer
  // CK_UserDefinedConversion
  // CK_ConstructorConversion
  I32EnumAttrCase<"int_to_ptr", 21>,
  I32EnumAttrCase<"ptr_to_int", 22>,
  I32EnumAttrCase<"ptr_to_bool", 23>,
  // CK_ToVoid
  // CK_MatrixCast
  // CK_VectorSplat
  I32EnumAttrCase<"integral", 27>,
  I32EnumAttrCase<"int_to_bool", 28>,
  I32EnumAttrCase<"int_to_float", 29>,
  // CK_FloatingToFixedPoint
  // CK_FixedPointToFloating
  // CK_FixedPointCast
  // CK_FixedPointToIntegral
  // CK_IntegralToFixedPoint
  // CK_FixedPointToBoolean
  I32EnumAttrCase<"float_to_int", 36>,
  I32EnumAttrCase<"float_to_bool", 37>,
  I32EnumAttrCase<"bool_to_int", 38>,
  I32EnumAttrCase<"floating", 39>,
  // CK_CPointerToObjCPointerCast
  // CK_BlockPointerToObjCPointerCast
  // CK_AnyPointerToBlockPointerCast
  // CK_ObjCObjectLValueCast
  I32EnumAttrCase<"float_to_complex", 44>,
  I32EnumAttrCase<"float_complex_to_real", 45>,
  I32EnumAttrCase<"float_complex_to_bool", 46>,
  I32EnumAttrCase<"float_complex", 47>,
  I32EnumAttrCase<"float_complex_to_int_complex", 48>,
  I32EnumAttrCase<"int_to_complex", 49>,
  I32EnumAttrCase<"int_complex_to_real", 50>,
  I32EnumAttrCase<"int_complex_to_bool", 51>,
  I32EnumAttrCase<"int_complex", 52>,
  I32EnumAttrCase<"int_complex_to_float_complex", 53>,
  // CK_ARCProduceObject
  // CK_ARCConsumeObject
  // CK_ARCReclaimReturnedObject
  // CK_ARCExtendBlockObject
  // CK_AtomicToNonAtomic
  // CK_NonAtomicToAtomic
  // CK_CopyAndAutoreleaseBlockObject
  // CK_BuiltinFnToFnPtr
  // CK_ZeroToOCLOpaqueType
  I32EnumAttrCase<"address_space", 63>,
  // CK_IntToOCLSampler
  // CK_HLSLVectorTruncation
  // CK_HLSLArrayRValue
  // CK_HLSLElementwiseCast
  // CK_HLSLAggregateSplatCast

  // Enums below are specific to CIR and don't have a correspondence to classic
  // codegen:
  I32EnumAttrCase<"bool_to_float", 1000>,
]>;

def CIR_CastOp : CIR_Op<"cast",[
  Pure,
  DeclareOpInterfaceMethods<PromotableOpInterface>
]> {
  // FIXME: not all conversions are free of side effects.
  let summary = "Conversion between values of different types";
  let description = [{
    Apply the usual C/C++ conversion rules between values. This operation models
    a subset of conversions as defined in Clang's `OperationKinds.def`
    (`llvm-project/clang/include/clang/AST/OperationKinds.def`).

    Note: not all conversions are implemented using `cir.cast`. For instance,
    lvalue-to-rvalue conversion is modeled as a `cir.load` instead.  Currently
    supported kinds:

    - `bitcast`
    - `array_to_ptrdecay`
    - `member_ptr_to_bool
    - `int_to_ptr`
    - `ptr_to_int`
    - `ptr_to_bool`
    - `integral`
    - `int_to_bool`
    - `int_to_float`
    - `float_to_int`
    - `float_to_bool`
    - `bool_to_int`
    - `floating`
    - `float_to_complex`
    - `float_complex_to_real`
    - `float_complex_to_bool`
    - `float_complex`
    - `float_complex_to_int_complex`
    - `int_to_complex`
    - `int_complex_to_real`
    - `int_complex_to_bool`
    - `int_complex`
    - `int_complex_to_float_complex`
    - `address_space`

    CIR also supports some additional conversions that are not part of the classic
    Clang codegen:

    - `bool_to_float`

    Example:

    ```mlir
    %4 = cir.cast(int_to_bool, %3 : i32), !cir.bool
    ...
    %x = cir.cast(array_to_ptrdecay, %0 : !cir.ptr<!cir.array<i32 x 10>>), !cir.ptr<i32>
    ```
  }];

  let arguments = (ins CIR_CastKind:$kind, CIR_AnyType:$src);
  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
    `(` $kind `,` $src `:` type($src) `)`
    `,` type($result) attr-dict
  }];

  // The input and output types should match the cast kind.
  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// DynamicCastOp
//===----------------------------------------------------------------------===//

def CIR_DynamicCastKind : CIR_I32EnumAttr<
  "DynamicCastKind", "dynamic cast kind", [
    I32EnumAttrCase<"Ptr", 0, "ptr">,
    I32EnumAttrCase<"Ref", 1, "ref">
]>;

def CIR_DynamicCastOp : CIR_Op<"dyn_cast"> {
  let summary = "Perform dynamic cast on record pointers";
  let description = [{
    The `cir.dyn_cast` operation models part of the semantics of the
    `dynamic_cast` operator in C++. It can be used to perform 3 kinds of casts
    on record pointers:

    - Down-cast, which casts a base class pointer to a derived class pointer;
    - Side-cast, which casts a class pointer to a sibling class pointer;
    - Cast-to-complete, which casts a class pointer to a void pointer.

    The input of the operation must be a record pointer. The result of the
    operation is either a record pointer or a void pointer.

    The parameter `kind` specifies the semantics of this operation. If its value
    is `ptr`, then the operation models dynamic casts on pointers. Otherwise, if
    its value is `ref`, the operation models dynamic casts on references.
    Specifically:

    - When the input pointer is a null pointer value:
      - If `kind` is `ref`, the operation will invoke undefined behavior. A
        sanitizer check will be emitted if sanitizer is on.
      - Otherwise, the operation will return a null pointer value as its result.
    - When the runtime type check fails:
      - If `kind` is `ref`, the operation will throw a `bad_cast` exception.
      - Otherwise, the operation will return a null pointer value as its result.

    The `info` argument gives detailed information about the requested dynamic
    cast operation. It is an optional `#cir.dyn_cast_info` attribute that is
    only present when the operation models a down-cast or a side-cast.

    The `relative_layout` argument specifies whether the Itanium C++ ABI vtable
    uses relative layout. It is only meaningful when the operation models a
    cast-to-complete operation.
  }];

  let arguments = (ins
    CIR_DynamicCastKind:$kind,
    CIR_PtrToRecordType:$src,
    OptionalAttr<CIR_DynamicCastInfoAttr>:$info,
    UnitAttr:$relative_layout
  );

  let results = (outs
    CIR_PtrToAnyOf<[CIR_VoidType, CIR_RecordType]>:$result
  );

  let assemblyFormat = [{
    `(`
      $kind `,` $src `:` qualified(type($src))
      (`,` qualified($info)^)?
      (`relative_layout` $relative_layout^)?
    `)`
    `->` qualified(type($result)) attr-dict
  }];

  let extraClassDeclaration = [{
    /// Determine whether this operation models reference casting in C++.
    bool isRefcast() {
      return getKind() == ::cir::DynamicCastKind::Ref;
    }

    /// Determine whether this operation represents a dynamic cast to a void
    /// pointer.
    bool isCastToVoid() {
      return getType().isVoidPtr();
    }
  }];
}

//===----------------------------------------------------------------------===//
// ObjSizeOp
//===----------------------------------------------------------------------===//

def CIR_SizeInfoType : CIR_I32EnumAttr< "SizeInfoType", "size info type", [
  I32EnumAttrCase<"Min", 0, "min">,
  I32EnumAttrCase<"Max", 1, "max">
]>;

def CIR_ObjSizeOp : CIR_Op<"objsize", [Pure]> {
  let summary = "Conversion between values of different types";

  let arguments = (ins
    CIR_PointerType:$ptr,
    CIR_SizeInfoType:$kind,
    UnitAttr:$dynamic
  );

  let results = (outs CIR_AnyFundamentalIntType:$result);

  let assemblyFormat = [{
    `(`
        $ptr `:` type($ptr) `,`
        $kind
        (`,` `dynamic` $dynamic^)?
    `)`
    `->` type($result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// PtrDiffOp
//===----------------------------------------------------------------------===//

def CIR_PtrDiffOp : CIR_Op<"ptr_diff", [Pure, SameTypeOperands]> {

  let summary = "Pointer subtraction arithmetic";
  let description = [{
    `cir.ptr_diff` performs a subtraction between two pointer types with the
    same element type and produces a `cir::IntType` result.

    Note that the result considers the pointer size according to the ABI for
    the pointee sizes, e.g. the subtraction between two `!cir.ptr<!u64i>` might
    yield 1, meaning 8 bytes, whereas for `void` or function type pointees,
    yielding 8 means 8 bytes.

    ```mlir
    %7 = "cir.ptr_diff"(%0, %1) : !cir.ptr<!u64i> -> !u64i
    ```
  }];

  let results = (outs CIR_AnyFundamentalIntType:$result);
  let arguments = (ins CIR_PointerType:$lhs, CIR_PointerType:$rhs);

  let assemblyFormat = [{
    `(` $lhs `,` $rhs  `)` `:` qualified(type($lhs)) `->` qualified(type($result)) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// PtrStrideOp
//===----------------------------------------------------------------------===//

def CIR_PtrStrideOp : CIR_Op<"ptr_stride",[
  Pure, AllTypesMatch<["base", "result"]>
]> {
  let summary = "Pointer access with stride";
  let description = [{
    Given a base pointer as first operand, provides a new pointer after applying
    a stride (second operand).

    ```mlir
    %3 = cir.const 0 : i32
    %4 = cir.ptr_stride(%2 : !cir.ptr<i32>, %3 : i32), !cir.ptr<i32>
    ```
  }];

  let arguments = (ins
    CIR_PointerType:$base,
    CIR_AnyFundamentalIntType:$stride
  );

  let results = (outs CIR_PointerType:$result);

  let assemblyFormat = [{
    `(` $base `:` qualified(type($base)) `,` $stride `:` qualified(type($stride)) `)`
    `,` qualified(type($result)) attr-dict
  }];

  let extraClassDeclaration = [{
    // Get type pointed by the base pointer.
    mlir::Type getElementTy() {
      return getBase().getType().getPointee();
    }
  }];
}

//===----------------------------------------------------------------------===//
// ConstantOp
//===----------------------------------------------------------------------===//

def CIR_ConstantOp : CIR_Op<"const",[
  ConstantLike, Pure, AllTypesMatch<["value", "res"]>
]> {
  // FIXME: Use SameOperandsAndResultType or similar and prevent eye bleeding
  // type repetition in the assembly form.

  let summary = "Defines a CIR constant";
  let description = [{
    The `cir.const` operation turns a literal into an SSA value. The data is
    attached to the operation as an attribute.

    ```mlir
      %0 = cir.const 42 : i32
      %1 = cir.const 4.2 : f32
      %2 = cir.const nullptr : !cir.ptr<i32>
    ```
  }];

  // The constant operation takes an attribute as the only input.
  let arguments = (ins TypedAttrInterface:$value);

  // The constant operation returns a single value of CIR_AnyType.
  let results = (outs CIR_AnyType:$res);

  let assemblyFormat = "attr-dict $value";

  let hasVerifier = 1;

  let extraClassDeclaration = [{
     bool isNullPtr() {
      if (const auto ptrAttr = mlir::dyn_cast<cir::ConstPtrAttr>(getValue()))
       return ptrAttr.isNullValue();
      return false;
     }
  }];

  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// C/C++ memory order definitions
//===----------------------------------------------------------------------===//

def CIR_MemOrder : CIR_I32EnumAttr<
  "MemOrder", "Memory order according to C++11 memory model", [
    I32EnumAttrCase<"Relaxed", 0, "relaxed">,
    I32EnumAttrCase<"Consume", 1, "consume">,
    I32EnumAttrCase<"Acquire", 2, "acquire">,
    I32EnumAttrCase<"Release", 3, "release">,
    I32EnumAttrCase<"AcquireRelease", 4, "acq_rel">,
    I32EnumAttrCase<"SequentiallyConsistent", 5, "seq_cst">
]>;

//===----------------------------------------------------------------------===//
// AllocaOp
//===----------------------------------------------------------------------===//

class CIR_AllocaTypesMatchWith<
  string summary, string lhsArg, string rhsArg, string transform,
  string comparator = "std::equal_to<>()"
> : PredOpTrait<summary, CPred<comparator # "(" #
      !subst("$_self", "$" # lhsArg # ".getType()", transform) #
             ", $" # rhsArg # ")">
> {
  string lhs = lhsArg;
  string rhs = rhsArg;
  string transformer = transform;
}

def CIR_AllocaOp : CIR_Op<"alloca", [
  CIR_AllocaTypesMatchWith<"'allocaType' matches pointee type of 'addr'",
    "addr", "allocaType", "mlir::cast<cir::PointerType>($_self).getPointee()">,
  DeclareOpInterfaceMethods<PromotableAllocationOpInterface>
]> {
  let summary = "Defines a scope-local variable";
  let description = [{
    The `cir.alloca` operation defines a scope-local variable.

    The presence `init` attribute indicates that the local variable represented
    by this alloca was originally initialized in C/C++ source code. In such
    cases, the first use contains the initialization (a cir.store, a cir.call
    to a ctor, etc).

    The presence of the `const` attribute indicates that the local variable is
    declared with C/C++ `const` keyword.

    The `dynAllocSize` specifies the size to dynamically allocate on the stack
    and ignores the allocation size based on the original type. This is useful
    when handling VLAs and is omitted when declaring regular local variables.

    The result type is a pointer to the input's type.

    Example:

    ```mlir
    // int count = 3;
    %0 = cir.alloca i32, !cir.ptr<i32>, ["count", init] {alignment = 4 : i64}

    // int *ptr;
    %1 = cir.alloca !cir.ptr<i32>, !cir.ptr<!cir.ptr<i32>>, ["ptr"] {alignment = 8 : i64}
    ...
    ```
  }];

  let arguments = (ins
    Optional<CIR_AnyFundamentalIntType>:$dynAllocSize,
    TypeAttr:$allocaType,
    StrAttr:$name,
    UnitAttr:$init,
    UnitAttr:$constant,
    ConfinedAttr<OptionalAttr<I64Attr>, [IntMinValue<0>]>:$alignment,
    OptionalAttr<ArrayAttr>:$annotations,
    OptionalAttr<ASTVarDeclInterface>:$ast
  );

  let results = (outs Res<CIR_PointerType, "",
                      [MemAlloc<AutomaticAllocationScopeResource>]>:$addr);

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins "mlir::Type":$addr, "mlir::Type":$allocaType,
                   "llvm::StringRef":$name,
                   "mlir::IntegerAttr":$alignment)>,

    OpBuilder<(ins "mlir::Type":$addr,
                   "mlir::Type":$allocaType,
                   "llvm::StringRef":$name,
                   "mlir::IntegerAttr":$alignment,
                   "mlir::Value":$dynAllocSize),
    [{
      if (dynAllocSize)
        $_state.addOperands(dynAllocSize);
      build($_builder, $_state, addr, allocaType, name, alignment);
    }]>
  ];

  let extraClassDeclaration = [{
    // Whether the alloca input type is a pointer.
    bool isPointerType() { return ::mlir::isa<::cir::PointerType>(getAllocaType()); }

    bool isDynamic() { return (bool)getDynAllocSize(); }
  }];

  let assemblyFormat = [{
    $allocaType `,` qualified(type($addr)) `,`
    ($dynAllocSize^ `:` type($dynAllocSize) `,`)?
    `[` $name
       (`,` `init` $init^)?
       (`,` `const` $constant^)?
    `]`
    ($annotations^)?
    (`ast` $ast^)? attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// LoadOp
//===----------------------------------------------------------------------===//

def CIR_LoadOp : CIR_Op<"load", [
  TypesMatchWith<"type of 'result' matches pointee type of 'addr'",
    "addr", "result", "mlir::cast<cir::PointerType>($_self).getPointee()">,
  DeclareOpInterfaceMethods<PromotableMemOpInterface>
]> {
  let summary = "Load value from memory adddress";
  let description = [{
    `cir.load` reads a value (lvalue to rvalue conversion) given an address
    backed up by a `cir.ptr` type. A unit attribute `deref` can be used to
    mark the resulting value as used by another operation to dereference
    a pointer. A unit attribute `volatile` can be used to indicate a volatile
    loading. Load can be marked atomic by using `atomic(<mem_order>)`.

    `align` can be used to specify an alignment that's different from the
    default, which is computed from `result`'s type ABI data layout.

    Example:

    ```mlir

    // Read from local variable, address in %0.
    %1 = cir.load %0 : !cir.ptr<i32>, i32

    // Load address from memory at address %0. %3 is used by at least one
    // operation that dereferences a pointer.
    %3 = cir.load deref %0 : !cir.ptr<!cir.ptr<i32>>

    // Perform a volatile load from address in %0.
    %4 = cir.load volatile %0 : !cir.ptr<i32>, i32

    // Others
    %x = cir.load align(16) atomic(seq_cst) %0 : !cir.ptr<i32>, i32
    ```
  }];

  let arguments = (ins Arg<CIR_PointerType, "the address to load from",
                           [MemRead]>:$addr, UnitAttr:$isDeref,
                       UnitAttr:$is_volatile,
                       UnitAttr:$is_nontemporal,
                       OptionalAttr<I64Attr>:$alignment,
                       OptionalAttr<CIR_MemOrder>:$mem_order,
                       OptionalAttr<CIR_AnyTBAAAttr>:$tbaa
                       );
  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
    (`deref` $isDeref^)?
    (`volatile` $is_volatile^)?
    (`nontemporal` $is_nontemporal^)?
    (`align` `(` $alignment^ `)`)?
    (`atomic` `(` $mem_order^ `)`)?
    $addr `:` qualified(type($addr)) `,` type($result) attr-dict
    (`tbaa` `(` $tbaa^ `)`)?
  }];

  let extraClassDeclaration = [{
    // TODO(CIR): The final interface here should include an argument for the
    // SyncScope::ID.
    // This should be used over the ODS generated setMemOrder.
    void setAtomic(cir::MemOrder order);
  }];

  // FIXME: add verifier.
}

//===----------------------------------------------------------------------===//
// StoreOp
//===----------------------------------------------------------------------===//

def CIR_StoreOp : CIR_Op<"store", [
  TypesMatchWith<"type of 'value' matches pointee type of 'addr'",
    "addr", "value", "mlir::cast<cir::PointerType>($_self).getPointee()">,
  DeclareOpInterfaceMethods<PromotableMemOpInterface>
]> {
  let summary = "Store value to memory address";
  let description = [{
    `cir.store` stores a value (first operand) to the memory address specified
    in the second operand. A unit attribute `volatile` can be used to indicate
    a volatile store. Store's can be marked atomic by using
    `atomic(<mem_order>)`.

    `align` can be used to specify an alignment that's different from the
    default, which is computed from `result`'s type ABI data layout.

    Example:

    ```mlir
    // Store a function argument to local storage, address in %0.
    cir.store %arg0, %0 : i32, !cir.ptr<i32>

    // Perform a volatile store into memory location at the address in %0.
    cir.store volatile %arg0, %0 : i32, !cir.ptr<i32>

    // Others
    cir.store align(16) atomic(seq_cst) %x, %addr : i32, !cir.ptr<i32>
    ```
  }];

  let builders = [
    OpBuilder<(ins "mlir::Value":$value, "mlir::Value":$addr), [{
      $_state.addOperands({value, addr});
    }]>
  ];

  let arguments = (ins CIR_AnyType:$value,
                       Arg<CIR_PointerType, "the address to store the value",
                           [MemWrite]>:$addr,
                       UnitAttr:$is_volatile,
                       UnitAttr:$is_nontemporal,
                       OptionalAttr<I64Attr>:$alignment,
                       OptionalAttr<CIR_MemOrder>:$mem_order,
                       OptionalAttr<CIR_AnyTBAAAttr>:$tbaa);

  let assemblyFormat = [{
    (`volatile` $is_volatile^)?
    (`nontemporal` $is_nontemporal^)?
    (`align` `(` $alignment^ `)`)?
    (`atomic` `(` $mem_order^ `)`)?
    $value `,` $addr attr-dict `:` type($value) `,` qualified(type($addr))
    (`tbaa` `(` $tbaa^ `)`)?
  }];

  let extraClassDeclaration = [{
    // TODO(CIR): The final interface here should include an argument for the
    // SyncScope::ID.
    // This should be used over the ODS generated setMemOrder.
    void setAtomic(cir::MemOrder order);
  }];

  // FIXME: add verifier.
}

//===----------------------------------------------------------------------===//
// ReturnOp
//===----------------------------------------------------------------------===//

defvar CIR_ReturnableScopes = [
  "FuncOp", "ScopeOp", "IfOp", "SwitchOp", "DoWhileOp", "WhileOp", "ForOp",
  "CaseOp", "TryOp"
];

def CIR_ReturnOp : CIR_Op<"return", [
  ParentOneOf<CIR_ReturnableScopes>, Terminator
]> {
  let summary = "Return from function";
  let description = [{
    The "return" operation represents a return operation within a function.
    The operation takes an optional operand and produces no results.
    The operand type must match the signature of the function that contains
    the operation.

    ```mlir
      func @foo() -> i32 {
        ...
        cir.return %0 : i32
      }
    ```
  }];

  // The return operation takes an optional input operand to return. This
  // value must match the return type of the enclosing function.
  let arguments = (ins Variadic<CIR_AnyType>:$input);

  // The return operation only emits the input in the format if it is present.
  let assemblyFormat = "($input^ `:` type($input))? attr-dict ";

  // Allow building a ReturnOp with no return operand.
  let builders = [
    OpBuilder<(ins), [{ build($_builder, $_state, std::nullopt); }]>
  ];

  // Provide extra utility definitions on the c++ operation class definition.
  let extraClassDeclaration = [{
    bool hasOperand() { return getNumOperands() != 0; }
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// IfOp
//===----------------------------------------------------------------------===//

def CIR_IfOp : CIR_Op<"if",
      [DeclareOpInterfaceMethods<RegionBranchOpInterface>,
       RecursivelySpeculatable, AutomaticAllocationScope, NoRegionArguments]> {
  let summary = "The if-then-else operation";
  let description = [{
    The `cir.if` operation represents an if-then-else construct for
    conditionally executing two regions of code. The operand is a `cir.bool`
    type.

    Examples:

    ```mlir
    cir.if %b  {
      ...
    } else {
      ...
    }

    cir.if %c  {
      ...
    }

    cir.if %c  {
      ...
      cir.br ^a
    ^a:
      cir.yield
    }
    ```

    `cir.if` defines no values and the 'else' can be omitted. The if/else
    regions must be terminated. If the region has only one block, the terminator
    can be left out, and `cir.yield` terminator will be inserted implictly.
    Otherwise, the region must be explicitly terminated.
  }];
  let arguments = (ins CIR_BoolType:$condition);
  let regions = (region AnyRegion:$thenRegion, AnyRegion:$elseRegion);

  let hasCustomAssemblyFormat = 1;
  let hasVerifier = 1;

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins "mlir::Value":$cond, "bool":$withElseRegion,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "buildTerminatedBody">:$thenBuilder,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "nullptr">:$elseBuilder)>
  ];
}

//===----------------------------------------------------------------------===//
// TernaryOp
//===----------------------------------------------------------------------===//

def CIR_TernaryOp : CIR_Op<"ternary", [
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  RecursivelySpeculatable, AutomaticAllocationScope, NoRegionArguments
]> {
  let summary = "The `cond ? a : b` C/C++ ternary operation";
  let description = [{
    The `cir.ternary` operation represents C/C++ ternary, much like a `select`
    operation. First argument is a `cir.bool` condition to evaluate, followed
    by two regions to execute (true or false). This is different from `cir.if`
    since each region is one block sized and the `cir.yield` closing the block
    scope should have one argument.

    Example:

    ```mlir
    // x = cond ? a : b;

    %x = cir.ternary (%cond, true_region {
      ...
      cir.yield %a : i32
    }, false_region {
      ...
      cir.yield %b : i32
    }) -> i32
    ```
  }];
  let arguments = (ins CIR_BoolType:$cond);
  let regions = (region AnyRegion:$trueRegion,
                        AnyRegion:$falseRegion);
  let results = (outs Optional<CIR_AnyType>:$result);

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins "mlir::Value":$cond,
      "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$trueBuilder,
      "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$falseBuilder)
      >
  ];

  let assemblyFormat = [{
    `(` $cond `,`
      `true` $trueRegion `,`
      `false` $falseRegion
    `)` `:` functional-type(operands, results) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// SelectOp
//===----------------------------------------------------------------------===//

def CIR_SelectOp : CIR_Op<"select", [
  Pure,
  AllTypesMatch<["true_value", "false_value", "result"]>
]> {
  let summary = "Yield one of two values based on a boolean value";
  let description = [{
    The `cir.select` operation takes three operands. The first operand
    `condition` is a boolean value of type `!cir.bool`. The second and the third
    operand can be of any CIR types, but their types must be the same. If the
    first operand is `true`, the operation yields its second operand. Otherwise,
    the operation yields its third operand.

    Example:

    ```mlir
    %0 = cir.const #cir.bool<true> : !cir.bool
    %1 = cir.const #cir.int<42> : !s32i
    %2 = cir.const #cir.int<72> : !s32i
    %3 = cir.select if %0 then %1 else %2 : (!cir.bool, !s32i, !s32i) -> !s32i
    ```
  }];

  let arguments = (ins CIR_BoolType:$condition, CIR_AnyType:$true_value,
                       CIR_AnyType:$false_value);
  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
    `if` $condition `then` $true_value `else` $false_value
    `:` `(`
      qualified(type($condition)) `,`
      qualified(type($true_value)) `,`
      qualified(type($false_value))
    `)` `->` qualified(type($result)) attr-dict
  }];

  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// ConditionOp
//===----------------------------------------------------------------------===//

def CIR_ConditionOp : CIR_Op<"condition", [
  Terminator, CIR_ConditionOpInterface,
  DeclareOpInterfaceMethods<RegionBranchTerminatorOpInterface, [
    "getSuccessorRegions"
  ]>
]> {
  let summary = "Loop continuation condition.";
  let description = [{
    The `cir.condition` terminates conditional regions. It takes a single
    `cir.bool` operand and, depending on its value, may branch to different
    regions:

     - When in the `cond` region of a `cir.loop`, it continues the loop
       if true, or exits it if false.
     - When in the `ready` region of a `cir.await`, it branches to the `resume`
       region when true, and to the `suspend` region when false.

    Example:

    ```mlir
    cir.loop for(cond : {
      cir.condition(%arg0) // Branches to `step` region or exits.
    }, step : {
      [...]
    }) {
      [...]
    }

    cir.await(user, ready : {
      cir.condition(%arg0) // Branches to `resume` or `suspend` region.
    }, suspend : {
      [...]
    }, resume : {
      [...]
    },)
    ```
  }];
  let arguments = (ins CIR_BoolType:$condition);
  let assemblyFormat = " `(` $condition `)` attr-dict ";
  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// YieldOp
//===----------------------------------------------------------------------===//

defvar CIR_YieldableScopes = [
  "ArrayCtor", "ArrayDtor", "AwaitOp", "CallOp", "CaseOp", "DoWhileOp", "ForOp",
  "GlobalOp", "IfOp", "ScopeOp", "SwitchOp", "TernaryOp", "TryOp", "WhileOp"
];

def CIR_YieldOp : CIR_Op<"yield", [
  ReturnLike, Terminator, ParentOneOf<CIR_YieldableScopes>
]> {
  let summary = "Represents the default branching behaviour of a region";
  let description = [{
    The `cir.yield` operation terminates regions on different CIR operations,
    and it is used to represent the default branching behaviour of a region.
    Said branching behaviour is determinted by the parent operation. For
    example, a yield in a `switch-case` region implies a fallthrough, while
    a yield in a `cir.if` region implies a branch to the exit block, and so
    on.

    In some cases, it might yield an SSA value and the semantics of how the
    values are yielded is defined by the parent operation. For example, a
    `cir.ternary` operation yields a value from one of its regions.

    As a general rule, `cir.yield` must be explicitly used whenever a region has
    more than one block and no terminator, or within `cir.switch` regions not
    `cir.return` terminated.

    Examples:
    ```mlir
    cir.if %4 {
      ...
      cir.yield
    }

    cir.switch (%5) [
      case (equal, 3) {
        ...
        cir.yield
      }, ...
    ]

    cir.scope {
      ...
      cir.yield
    }

    %x = cir.scope {
      ...
      cir.yield %val
    }

    %y = cir.ternary {
      ...
      cir.yield %val : i32
    } : i32
    ```
  }];

  let arguments = (ins Variadic<CIR_AnyType>:$args);
  let assemblyFormat = "($args^ `:` type($args))? attr-dict";
  let builders = [
    OpBuilder<(ins), [{ /* nothing to do */ }]>,
  ];
}

//===----------------------------------------------------------------------===//
// BreakOp
//===----------------------------------------------------------------------===//

def CIR_BreakOp : CIR_Op<"break", [Terminator]> {
  let summary = "C/C++ `break` statement equivalent";
  let description = [{
    The `cir.break` operation is used to cease the control flow to the parent
    operation, exiting its region's control flow. It is only allowed if it is
    within a breakable operation (loops and `switch`).
  }];
  let assemblyFormat = "attr-dict";
  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// ContinueOp
//===----------------------------------------------------------------------===//

def CIR_ContinueOp : CIR_Op<"continue", [Terminator]> {
  let summary = "C/C++ `continue` statement equivalent";
  let description = [{
    The `cir.continue` operation is used to continue execution to the next
    iteration of a loop. It is only allowed within `cir.loop` regions.
  }];
  let assemblyFormat = "attr-dict";
  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// Resume
//===----------------------------------------------------------------------===//

def CIR_ResumeOp : CIR_Op<"resume", [
  ReturnLike, Terminator, AttrSizedOperandSegments
]> {
  let summary = "Resumes execution after not catching exceptions";
  let description = [{
    The `cir.resume` operation handles an uncaught exception scenario and
    behaves in two different modes:

    - As the terminator of a `CatchUnwind` region of `cir.try`, where it
    does not receive any arguments (implied from the `cir.try` scope), or
    - The terminator of a regular basic block without an enclosing `cir.try`
    operation, where it requires an `exception_ptr` and a `type_id`.

    The `rethrow` attribute is used to denote rethrowing behavior for the
    resume operation (versus default terminaton).
    ```
  }];

  let arguments = (ins Optional<CIR_VoidPtrType>:$exception_ptr,
                       Optional<CIR_UInt32>:$type_id,
                       UnitAttr:$rethrow);
  let assemblyFormat = [{
    ($rethrow^)?
    ($exception_ptr^)?
    (`,` $type_id^)?
    attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// ScopeOp
//===----------------------------------------------------------------------===//

def CIR_ScopeOp : CIR_Op<"scope", [
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  RecursivelySpeculatable, AutomaticAllocationScope, NoRegionArguments
]> {
  let summary = "Represents a C/C++ scope";
  let description = [{
    `cir.scope` contains one region and defines a strict "scope" for all new
    values produced within its blocks.

    The region can contain an arbitrary number of blocks but usually defaults
    to one and can optionally return a value (useful for representing values
    coming out of C++ full-expressions) via `cir.yield`:


    ```mlir
    %rvalue = cir.scope {
      ...
      cir.yield %value
    }
    ```

    The blocks can be terminated by `cir.yield`, `cir.return` or `cir.throw`.
    If `cir.scope` yields no value, the `cir.yield` can be left out, and
    will be inserted implicitly.

    The scope might also have an associated `cleanup` region, providing code
    that run destruction of automatic variables. Note that in order to lower the
    cleanup region while keeping C++ semantics, all immediate control-flow
    breaking operations not under a children scope should jump to this cleanup
    code.
  }];

  let results = (outs Optional<CIR_AnyType>:$results);
  let regions = (region AnyRegion:$scopeRegion, AnyRegion:$cleanupRegion);

  let hasVerifier = 1;
  let skipDefaultBuilders = 1;
  let assemblyFormat = [{
    custom<OmittedTerminatorRegion>($scopeRegion, $cleanupRegion) (`:` type($results)^)? attr-dict
  }];

  let extraClassDeclaration = [{
    /// Determine whether the scope is empty, meaning it contains a single block
    /// terminated by a cir.yield.
    bool isEmpty() {
      auto &entry = getScopeRegion().front();
      return getScopeRegion().hasOneBlock() &&
        llvm::isa<YieldOp>(entry.front());
      }
    }];

  let builders = [
    // Scopes for yielding values.
    OpBuilder<(ins
              "llvm::function_ref<void(mlir::OpBuilder &, mlir::Type &, mlir::Location)>":$scopeBuilder)>,
    // Scopes without yielding values.
    OpBuilder<(ins "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$scopeBuilder)>
  ];
}

//===----------------------------------------------------------------------===//
// UnaryOp
//===----------------------------------------------------------------------===//

def CIR_UnaryOpKind : CIR_I32EnumAttr<"UnaryOpKind", "unary operation kind", [
  I32EnumAttrCase<"Inc",   0, "inc">,
  I32EnumAttrCase<"Dec",   1, "dec">,
  I32EnumAttrCase<"Plus",  2, "plus">,
  I32EnumAttrCase<"Minus", 3, "minus">,
  I32EnumAttrCase<"Not",   4, "not">
]>;

// FIXME: Pure won't work when we add overloading.
def CIR_UnaryOp : CIR_Op<"unary", [Pure, SameOperandsAndResultType]> {
  let summary = "Unary operations";
  let description = [{
    `cir.unary` performs the unary operation according to
    the specified opcode kind: [inc, dec, plus, minus, not].

    It requires one input operand and has one result, both types
    should be the same.

    ```mlir
    %7 = cir.unary(inc, %1) : i32 -> i32
    %8 = cir.unary(dec, %2) : i32 -> i32
    ```
  }];

  let arguments = (ins
    Arg<CIR_UnaryOpKind, "unary op kind">:$kind,
    Arg<CIR_AnyType>:$input,
    UnitAttr:$no_signed_wrap
  );

  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
      `(` $kind `,` $input `)`
      (`nsw` $no_signed_wrap^)?
      `:` type($input) `,` type($result) attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// BinOp
//===----------------------------------------------------------------------===//

// FIXME: represent Commutative, Idempotent traits for appropriate binops
def CIR_BinOpKind : CIR_I32EnumAttr<
  "BinOpKind", "binary operation (arith and logic) kind", [
    I32EnumAttrCase<"Mul", 0, "mul">,
    I32EnumAttrCase<"Div", 1, "div">,
    I32EnumAttrCase<"Rem", 2, "rem">,
    I32EnumAttrCase<"Add", 3, "add">,
    I32EnumAttrCase<"Sub", 4, "sub">,
    I32EnumAttrCase<"And", 5, "and">,
    I32EnumAttrCase<"Xor", 6, "xor">,
    I32EnumAttrCase<"Or", 7, "or">,
    I32EnumAttrCase<"Max", 8, "max">
]>;

// FIXME: Pure won't work when we add overloading.
def CIR_BinOp : CIR_Op<"binop", [
  Pure, SameTypeOperands, SameOperandsAndResultType
]> {
  let summary = "Binary operations (arith and logic)";
  let description = [{
    cir.binop performs the binary operation according to
    the specified opcode kind: [mul, div, rem, add, sub,
    and, xor, or].

    It requires two input operands and has one result, all types
    should be the same.

    ```mlir
    %7 = cir.binop(add, %1, %2) : !s32i
    %7 = cir.binop(mul, %1, %2) : !u8i
    ```
  }];

  let arguments = (ins
    CIR_BinOpKind:$kind,
    CIR_AnyType:$lhs, CIR_AnyType:$rhs,
    UnitAttr:$no_unsigned_wrap,
    UnitAttr:$no_signed_wrap,
    UnitAttr:$saturated
  );

  // TODO: get more accurate than CIR_AnyType
  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
    `(` $kind `,` $lhs `,` $rhs  `)`
    (`nsw` $no_signed_wrap^)?
    (`nuw` $no_unsigned_wrap^)?
    (`sat` $saturated^)?
    `:` type($lhs) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// ShiftOp
//===----------------------------------------------------------------------===//

def CIR_ShiftOp : CIR_Op<"shift", [Pure]> {
  let summary = "Shift";
  let description = [{
    Shift `left` or `right`, according to the first operand. Second operand is
    the shift target and the third the amount. Second and the thrid operand can
    be either integer type or vector of integer type. However, they must be
    either all vector of integer type, or all integer type. If they are vectors,
    each vector element of the shift target is shifted by the corresponding
    shift amount in the shift amount vector.

    ```mlir
    %7 = cir.shift(left, %1 : !u64i, %4 : !s32i) -> !u64i
    %8 = cir.shift(left, %2 : !cir.vector<!s32i x 2>, %3 : !cir.vector<!s32i x 2>) -> !cir.vector<!s32i x 2>
    ```
  }];

  let arguments = (ins
    CIR_AnyIntOrVecOfIntType:$value,
    CIR_AnyIntOrVecOfIntType:$amount,
    UnitAttr:$isShiftleft
  );

  let results = (outs CIR_AnyIntOrVecOfIntType:$result);

  let assemblyFormat = [{
    `(`
      (`left` $isShiftleft^) : (```right`)?
      `,` $value `:` type($value)
      `,` $amount `:` type($amount)
    `)` `->` type($result) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// CmpOp
//===----------------------------------------------------------------------===//

def CIR_CmpOpKind : CIR_I32EnumAttr<"CmpOpKind", "compare operation kind", [
  I32EnumAttrCase<"lt", 0>,
  I32EnumAttrCase<"le", 1>,
  I32EnumAttrCase<"gt", 2>,
  I32EnumAttrCase<"ge", 3>,
  I32EnumAttrCase<"eq", 4>,
  I32EnumAttrCase<"ne", 5>
]>;

// FIXME: Pure might not work when we add overloading.
def CIR_CmpOp : CIR_Op<"cmp", [Pure, SameTypeOperands]> {
  let summary = "Compare values two values and produce a boolean result";
  let description = [{
    `cir.cmp` compares two input operands of the same type and produces a
    `cir.bool` result. The kinds of comparison available are:
    [lt,gt,ge,eq,ne]

    ```mlir
    %7 = cir.cmp(gt, %1, %2) : i32, !cir.bool
    ```
  }];

  let arguments = (ins
    CIR_CmpOpKind:$kind,
    CIR_AnyType:$lhs,
    CIR_AnyType:$rhs
  );

  let results = (outs CIR_BoolType:$result);

  let assemblyFormat = [{
    `(` $kind `,` $lhs `,` $rhs  `)` `:` type($lhs) `,` type($result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// BinOpOverflowOp
//===----------------------------------------------------------------------===//

def CIR_BinOpOverflowKind : CIR_I32EnumAttr<
  "BinOpOverflowKind", "checked binary arithmetic operation kind", [
    I32EnumAttrCase<"Add", 0, "add">,
    I32EnumAttrCase<"Sub", 1, "sub">,
    I32EnumAttrCase<"Mul", 2, "mul">
]>;

def CIR_BinOpOverflowOp : CIR_Op<"binop.overflow", [Pure, SameTypeOperands]> {
  let summary = "Perform binary integral arithmetic with overflow checking";
  let description = [{
    `cir.binop.overflow` performs binary arithmetic operations with overflow
    checking on integral operands.

    The `kind` argument specifies the kind of arithmetic operation to perform.
    It can be either `add`, `sub`, or `mul`. The `lhs` and `rhs` arguments
    specify the input operands of the arithmetic operation. The types of `lhs`
    and `rhs` must be the same.

    `cir.binop.overflow` produces two SSA values. `result` is the result of the
    arithmetic operation truncated to its specified type. `overflow` is a
    boolean value indicating whether overflow happens during the operation.

    The exact semantic of this operation is as follows:

      - `lhs` and `rhs` are promoted to an imaginary integral type that has
        infinite precision.
      - The arithmetic operation is performed on the promoted operands.
      - The infinite-precision result is truncated to the type of `result`. The
        truncated result is assigned to `result`.
      - If the truncated result is equal to the un-truncated result, `overflow`
        is assigned to false. Otherwise, `overflow` is assigned to true.
  }];

  let arguments = (ins
    CIR_BinOpOverflowKind:$kind,
    CIR_IntType:$lhs,
    CIR_IntType:$rhs
  );

  let results = (outs CIR_IntType:$result, CIR_BoolType:$overflow);

  let assemblyFormat = [{
    `(` $kind `,` $lhs `,` $rhs `)` `:` type($lhs) `,`
    `(` type($result) `,` type($overflow) `)`
    attr-dict
  }];

  let builders = [
    OpBuilder<(ins "cir::IntType":$resultTy,
                   "cir::BinOpOverflowKind":$kind,
                   "mlir::Value":$lhs,
                   "mlir::Value":$rhs), [{
      auto overflowTy = cir::BoolType::get($_builder.getContext());
      build($_builder, $_state, resultTy, overflowTy, kind, lhs, rhs);
    }]>
  ];
}

//===----------------------------------------------------------------------===//
// ComplexCreateOp
//===----------------------------------------------------------------------===//

def CIR_ComplexCreateOp : CIR_Op<"complex.create", [Pure, SameTypeOperands]> {
  let summary = "Create a complex value from its real and imaginary parts";
  let description = [{
    `cir.complex.create` operation takes two operands that represent the real
    and imaginary part of a complex number, and yields the complex number.

    Example:

    ```mlir
    %0 = cir.const #cir.fp<1.000000e+00> : !cir.double
    %1 = cir.const #cir.fp<2.000000e+00> : !cir.double
    %2 = cir.complex.create %0, %1 : !cir.complex<!cir.double>
    ```
  }];

  let results = (outs CIR_ComplexType:$result);
  let arguments = (ins
    CIR_AnyIntOrFloatType:$real,
    CIR_AnyIntOrFloatType:$imag
  );

  let assemblyFormat = [{
    $real `,` $imag
    `:` qualified(type($real)) `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// ComplexRealOp and ComplexImagOp
//===----------------------------------------------------------------------===//

def CIR_ComplexRealOp : CIR_Op<"complex.real", [Pure]> {
  let summary = "Extract the real part of a complex value";
  let description = [{
    `cir.complex.real` operation takes an operand of `!cir.complex` type and
    yields the real part of it.

    Example:

    ```mlir
    %1 = cir.complex.real %0 : !cir.complex<!cir.float> -> !cir.float
    ```
  }];

  let results = (outs CIR_AnyIntOrFloatType:$result);
  let arguments = (ins CIR_ComplexType:$operand);

  let assemblyFormat = [{
    $operand `:` qualified(type($operand)) `->` qualified(type($result))
    attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

def CIR_ComplexImagOp : CIR_Op<"complex.imag", [Pure]> {
  let summary = "Extract the imaginary part of a complex value";
  let description = [{
    `cir.complex.imag` operation takes an operand of `!cir.complex` type and
    yields the imaginary part of it.

    Example:

    ```mlir
    %1 = cir.complex.imag %0 : !cir.complex<!cir.float> -> !cir.float
    ```
  }];

  let results = (outs CIR_AnyIntOrFloatType:$result);
  let arguments = (ins CIR_ComplexType:$operand);

  let assemblyFormat = [{
    $operand `:` qualified(type($operand)) `->` qualified(type($result))
    attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// ComplexRealPtrOp and ComplexImagPtrOp
//===----------------------------------------------------------------------===//

def CIR_ComplexRealPtrOp : CIR_Op<"complex.real_ptr", [Pure]> {
  let summary = "Derive a pointer to the real part of a complex value";
  let description = [{
    `cir.complex.real_ptr` operation takes a pointer operand that points to a
    complex value of type `!cir.complex` and yields a pointer to the real part
    of the operand.

    Example:

    ```mlir
    %1 = cir.complex.real_ptr %0 : !cir.ptr<!cir.complex<!cir.double>> -> !cir.ptr<!cir.double>
    ```
  }];

  let results = (outs CIR_PtrToIntOrFloatType:$result);
  let arguments = (ins CIR_PtrToComplexType:$operand);

  let assemblyFormat = [{
    $operand `:`
    qualified(type($operand)) `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
}

def CIR_ComplexImagPtrOp : CIR_Op<"complex.imag_ptr", [Pure]> {
  let summary = "Derive a pointer to the imaginary part of a complex value";
  let description = [{
    `cir.complex.imag_ptr` operation takes a pointer operand that points to a
    complex value of type `!cir.complex` and yields a pointer to the imaginary
    part of the operand.

    Example:

    ```mlir
    %1 = cir.complex.imag_ptr %0 : !cir.ptr<!cir.complex<!cir.double>> -> !cir.ptr<!cir.double>
    ```
  }];

  let results = (outs CIR_PtrToIntOrFloatType:$result);
  let arguments = (ins CIR_PtrToComplexType:$operand);

  let assemblyFormat = [{
    $operand `:`
    qualified(type($operand)) `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// ComplexBinOp
//===----------------------------------------------------------------------===//

def CIR_ComplexBinOpKind : CIR_I32EnumAttr<
  "ComplexBinOpKind", "complex number binary operation kind", [
    I32EnumAttrCase<"Mul", 0, "mul">,
    I32EnumAttrCase<"Div", 1, "div">
]>;

def CIR_ComplexRangeKind : CIR_I32EnumAttr<
  "ComplexRangeKind", "complex multiplication and division implementation", [
    I32EnumAttrCase<"Full", 0, "full">,
    I32EnumAttrCase<"Improved", 1, "improved">,
    I32EnumAttrCase<"Promoted", 2, "promoted">,
    I32EnumAttrCase<"Basic", 3, "basic">,
    I32EnumAttrCase<"None", 4, "none">
]>;

def CIR_ComplexBinOp : CIR_Op<"complex.binop",[
  Pure, SameTypeOperands, SameOperandsAndResultType
]> {
  let summary = "Binary operations on operands of complex type";
  let description = [{
    The `cir.complex.binop` operation represents a binary operation on operands
    of C complex type (e.g. `float _Complex`). The operation can only represent
    binary multiplication or division on complex numbers; other binary
    operations, such as addition and subtraction, are represented by the
    `cir.binop` operation.

    The operation requires two input operands and has one result. The types of
    all the operands and the result should be of the same `!cir.complex` type.

    The operation also takes a `range` attribute that specifies the complex
    range of the binary operation.

    Examples:

    ```mlir
    %2 = cir.complex.binop add %0, %1 : !cir.complex<!cir.float>
    %2 = cir.complex.binop mul %0, %1 : !cir.complex<!cir.float>
    ```
  }];

  let arguments = (ins
    CIR_ComplexBinOpKind:$kind,
    CIR_ComplexType:$lhs,
    CIR_ComplexType:$rhs,
    CIR_ComplexRangeKind:$range,
    UnitAttr:$promoted
  );

  let results = (outs CIR_ComplexType:$result);

  let assemblyFormat = [{
    $kind $lhs `,` $rhs `range` `(` $range `)` (`promoted` $promoted^)?
    `:` qualified(type($lhs)) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// BitsOp
//===----------------------------------------------------------------------===//

class CIR_BitOp<string mnemonic, TypeConstraint inputTy> : CIR_Op<mnemonic, [
  Pure, SameOperandsAndResultType
]> {
  let arguments = (ins inputTy:$input);
  let results = (outs inputTy:$result);

  let assemblyFormat = [{
    $input `:` type($result) attr-dict
  }];
}

class CIR_CountZerosBitOp<string mnemonic, TypeConstraint inputTy>
    : CIR_BitOp<mnemonic, inputTy> {
  let arguments = (ins inputTy:$input, UnitAttr:$is_zero_poison);
  let assemblyFormat = [{
    $input (`zero_poison` $is_zero_poison^)?
    `:` type($result) attr-dict
  }];
}

def CIR_BitClrsbOp : CIR_BitOp<"clrsb", CIR_SIntOfWidths<[32, 64]>> {
  let summary = "Get the number of leading redundant sign bits in the input";
  let description = [{
    Compute the number of leading redundant sign bits in the input integer.

    The input integer must be a signed integer. The most significant bit of the
    input integer is the sign bit. The `cir.clrsb` operation returns the number
    of redundant sign bits in the input, that is, the number of bits following
    the most significant bit that are identical to it.

    The bit width of the input integer must be either 32 or 64.

    Examples:

    ```mlir
    !s32i = !cir.int<s, 32>

    // %0 = 0xDEADBEEF, 0b1101_1110_1010_1101_1011_1110_1110_1111
    %0 = cir.const #cir.int<3735928559> : !s32i
    // %1 will be 1 because there is 1 bit following the most significant bit
    // that is identical to it.
    %1 = cir.clrsb(%0 : !s32i) : !s32i

    // %2 = 1, 0b0000_0000_0000_0000_0000_0000_0000_0001
    %2 = cir.const #cir.int<1> : !s32i
    // %3 will be 30
    %3 = cir.clrsb(%2 : !s32i) : !s32i
    ```
  }];
}

def CIR_BitClzOp : CIR_CountZerosBitOp<"clz", CIR_UIntOfWidths<[16, 32, 64]>> {
  let summary = "Get the number of leading 0-bits in the input";
  let description = [{
    Compute the number of leading 0-bits in the input.

    The input integer must be an unsigned integer. The `cir.clz` operation
    returns the number of consecutive 0-bits at the most significant bit
    position in the input.

    Zero_poison attribute means this operation invokes undefined behavior if the
    input value is 0.

    Example:

    ```mlir
    !u32i = !cir.int<u, 32>

    // %0 = 0b0000_0000_0000_0000_0000_0000_0000_1000
    %0 = cir.const #cir.int<8> : !u32i
    // %1 will be 28
    %1 = cir.clz(%0 : !u32i) zero_poison : !u32i
    ```
  }];
}

def CIR_BitCtzOp : CIR_CountZerosBitOp<"ctz", CIR_UIntOfWidths<[16, 32, 64]>> {
  let summary = "Get the number of trailing 0-bits in the input";
  let description = [{
    Compute the number of trailing 0-bits in the input.

    The input integer must be an unsigned integer. The `cir.ctz` operation
    returns the number of consecutive 0-bits at the least significant bit
    position in the input.

    Zero_poison attribute means this operation invokes undefined behavior if the
    input value is 0.

    Example:

    ```mlir
    !s32i = !cir.int<s, 32>
    !u32i = !cir.int<u, 32>

    // %0 = 0b1000
    %0 = cir.const #cir.int<8> : !u32i
    // %1 will be 3
    %1 = cir.ctz(%0 : !u32i) : !u32i
    ```
  }];
}

def CIR_BitFfsOp : CIR_BitOp<"ffs", CIR_SIntOfWidths<[32, 64]>> {
  let summary = "Get the position of the least significant 1-bit of input";
  let description = [{
    Compute the position of the least significant 1-bit of the input.

    The input integer must be a signed integer. The `cir.ffs` operation returns
    one plus the index of the least significant 1-bit of the input signed
    integer. As a special case, if the input integer is 0, `cir.ffs` returns 0.

    Example:

    ```mlir
    !s32i = !cir.int<s, 32>

    // %0 = 0x0010_1000
    %0 = cir.const #cir.int<40> : !s32i
    // #1 will be 4 since the 4th least significant bit is 1.
    %1 = cir.ffs(%0 : !s32i) : !s32i
    ```
  }];
}

def CIR_BitParityOp : CIR_BitOp<"parity", CIR_UIntOfWidths<[32, 64]>> {
  let summary = "Get the parity of input";
  let description = [{
    Compute the parity of the input. The parity of an integer is the number of
    1-bits in it modulo 2.

    The input must be an unsigned integer.

    Example:

    ```mlir
    !s32i = !cir.int<s, 32>
    !u32i = !cir.int<u, 32>

    // %0 = 0x0110_1000
    %0 = cir.const #cir.int<104> : !u32i
    // %1 will be 1 since there are 3 1-bits in %0
    %1 = cir.parity(%0 : !u32i) : !u32i
    ```
  }];
}

def CIR_BitPopcountOp : CIR_BitOp<"popcount", CIR_UIntOfWidths<[16, 32, 64]>> {
  let summary = "Get the number of 1-bits in input";
  let description = [{
    Compute the number of 1-bits in the input.

    The input must be an unsigned integer.

    Example:

    ```mlir
    !u32i = !cir.int<u, 32>

    // %0 = 0x0110_1000
    %0 = cir.const #cir.int<104> : !u32i
    // %1 will be 3 since there are 3 1-bits in %0
    %1 = cir.popcount(%0 : !u32i) : !u32i
    ```
  }];
}

//===----------------------------------------------------------------------===//
// ByteswapOp
//===----------------------------------------------------------------------===//

def CIR_ByteswapOp : CIR_Op<"byte_swap", [Pure, SameOperandsAndResultType]> {
  let summary = "Reverse the bytes that constitute the operand integer";
  let description = [{
    The `cir.byte_swap` operation takes an integer as operand, and returns it
    with the order of bytes that constitute the operand reversed.

    The operand integer must be an unsigned integer. Its widths must be either
    16, 32, or 64.

    Example:

    ```mlir
    !u32i = !cir.int<u, 32>

    // %0 = 0x12345678
    %0 = cir.const #cir.int<305419896> : !u32i

    // %1 should be 0x78563412
    %1 = cir.byte_swap(%0 : !u32i) : !u32i
    ```
  }];

  let results = (outs CIR_IntType:$result);
  let arguments = (ins CIR_UIntOfWidths<[16, 32, 64]>:$input);

  let assemblyFormat = [{
    $input `:` type($result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// RotateOp
//===----------------------------------------------------------------------===//

def CIR_RotateOp : CIR_Op<"rotate", [Pure, SameOperandsAndResultType]> {
  let summary = "Reverse the bytes that constitute the operand integer";
  let description = [{
    The `cir.rotate` rotates operand in `src` by the given bit amount `amt`.
    Its widths must be either 8, 16, 32, or 64 and both `src`, `amt` and
    `result` be of the same type. The rotate direction is specified by a
    `left`/`right` keyword.

    This operation covers different C/C++
    builtins, some examples: `__builtin_rotateleft8`, `__builtin_rotateleft16`,
    `__builtin_rotateleft32`, `__builtin_rotateleft64`, `_rotl8`, `_rotl16`,
    `_rotl`, `_lrotl`, `_rotl64`, etc and their "right" variants.

    Example:

    ```mlir
    %r = cir.rotate left %0, %1 -> !u32i
    ```
  }];

  let results = (outs CIR_IntType:$result);
  let arguments = (ins CIR_IntType:$src, CIR_IntType:$amt,
                       UnitAttr:$left);

  let assemblyFormat = [{
    (`left` $left^) : (`right`)?
    $src `,` $amt `->` type($result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// BitReverseOp
//===----------------------------------------------------------------------===//

def CIR_BitReverseOp : CIR_Op<"bit_reverse", [
  Pure, SameOperandsAndResultType
]> {
  let summary = "Reverse the bit pattern of the operand integer";
  let description = [{
    The `cir.bit_reverse` operation reverses the bit pattern of the operand
    integer. Its only argument must be of unsigned integer types of width 8, 16,
    32, or 64.

    This operation covers the C/C++ builtin function `__builtin_bitreverse`.

    Example:

    ```mlir
    %1 = cir.bit_reverse %0 : !u32i
    ```
  }];

  let arguments = (ins CIR_UIntOfWidths<[8, 16, 32, 64]>:$src);
  let results = (outs CIR_UIntOfWidths<[8, 16, 32, 64]>:$result);

  let assemblyFormat = [{
    $src `:` type($result) attr-dict
  }];

  let llvmOp = "BitReverseOp";
}

//===----------------------------------------------------------------------===//
// CmpThreeWayOp
//===----------------------------------------------------------------------===//

def CIR_CmpThreeWayOp : CIR_Op<"cmp3way", [Pure, SameTypeOperands]> {
  let summary = "Compare two values with C++ three-way comparison semantics";
  let description = [{
    The `cir.cmp3way` operation models the `<=>` operator in C++20. It takes two
    operands with the same type and produces a result indicating the ordering
    between the two input operands.

    The result of the operation is a signed integer that indicates the ordering
    between the two input operands.

    There are two kinds of ordering: strong ordering and partial ordering.
    Comparing different types of values yields different kinds of orderings.
    The `info` parameter gives the ordering kind and other necessary information
    about the comparison.

    Example:

    ```mlir
    !s32i = !cir.int<s, 32>

    #cmp3way_strong = #cmp3way_info<strong, lt = -1, eq = 0, gt = 1>
    #cmp3way_partial = #cmp3way_info<strong, lt = -1, eq = 0, gt = 1, unordered = 2>

    %0 = cir.const #cir.int<0> : !s32i
    %1 = cir.const #cir.int<1> : !s32i
    %2 = cir.cmp3way(%0 : !s32i, %1, #cmp3way_strong) : !s8i

    %3 = cir.const #cir.fp<0.0> : !cir.float
    %4 = cir.const #cir.fp<1.0> : !cir.float
    %5 = cir.cmp3way(%3 : !cir.float, %4, #cmp3way_partial) : !s8i
    ```
  }];

  let arguments = (ins
    CIR_AnyType:$lhs,
    CIR_AnyType:$rhs,
    CIR_CmpThreeWayInfoAttr:$info
  );

  let results = (outs CIR_AnySIntType:$result);

  let assemblyFormat = [{
    `(` $lhs `:` type($lhs) `,` $rhs `,` qualified($info) `)`
    `:` type($result) attr-dict
  }];

  let extraClassDeclaration = [{
    /// Determine whether this three-way comparison produces a strong ordering.
    bool isStrongOrdering() {
      return getInfo().getOrdering() == cir::CmpOrdering::Strong;
    }

    /// Determine whether this three-way comparison compares integral operands.
    bool isIntegralComparison() {
      return mlir::isa<cir::IntType>(getLhs().getType());
    }
  }];
}

//===----------------------------------------------------------------------===//
// SwitchOp
//===----------------------------------------------------------------------===//

def CIR_CaseOpKind : CIR_I32EnumAttr<"CaseOpKind", "case kind", [
  I32EnumAttrCase<"Default", 0, "default">,
  I32EnumAttrCase<"Equal", 1, "equal">,
  I32EnumAttrCase<"Anyof", 2, "anyof">,
  I32EnumAttrCase<"Range", 3, "range">
]>;

def CIR_CaseOp : CIR_Op<"case", [
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  RecursivelySpeculatable, AutomaticAllocationScope
]> {
  let summary = "Case operation";
  let description = [{
    The `cir.case` operation represents a case within a C/C++ switch.
    The `cir.case` operation must be in a `cir.switch` operation directly or indirectly.

    The `cir.case` have 4 kinds:
    - `equal, <constant>`: equality of the second case operand against the
    condition.
    - `anyof, [constant-list]`: equals to any of the values in a subsequent
    following list.
    - `range, [lower-bound, upper-bound]`: the condition is within the closed interval.
    - `default`: any other value.

    Each case region must be explicitly terminated.
  }];

  let arguments = (ins ArrayAttr:$value, CIR_CaseOpKind:$kind);
  let regions = (region AnyRegion:$caseRegion);

  let assemblyFormat = "`(` $kind `,` $value `)` $caseRegion attr-dict";

  let hasVerifier = 1;

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins "mlir::ArrayAttr":$value,
                   "CaseOpKind":$kind,
                   "mlir::OpBuilder::InsertPoint &":$insertPoint)>
  ];
}

def CIR_SwitchOp : CIR_Op<"switch", [
  SameVariadicOperandSize,
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  RecursivelySpeculatable, AutomaticAllocationScope, NoRegionArguments
]> {
  let summary = "Switch operation";
  let description = [{
    The `cir.switch` operation represents C/C++ switch functionality for
    conditionally executing multiple regions of code. The operand to an switch
    is an integral condition value.

    The set of `cir.case` operations and their enclosing `cir.switch`
    represents the semantics of a C/C++ switch statement. Users can use
    `collectCases(llvm::SmallVector<CaseOp> &cases)` to collect the `cir.case`
    operation in the `cir.switch` operation easily.

    The `cir.case` operations doesn't have to be in the region of `cir.switch`
    directly. However, when all the `cir.case` operations lives in the region
    of `cir.switch` directly and there is no other operations except the ending
    `cir.yield` operation in the region of `cir.switch` directly, we call the
    `cir.switch` operation is in a simple form. Users can use
    `bool isSimpleForm(llvm::SmallVector<CaseOp> &cases)` member function to
    detect if the `cir.switch` operation is in a simple form. The simple form
    makes analysis easier to handle the `cir.switch` operation
    and makes the boundary to give up pretty clear.

    To make the simple form as common as possible, CIR code generation attaches
    operations corresponding to the statements that lives between top level
    cases into the closest `cir.case` operation.

    For example,

    ```
    switch(int cond) {
      case 4:
        a++;

      b++;
      case 5;
        c++;

      ...
    }
    ```

    The statement `b++` is not a sub-statement of the case statement `case 4`.
    But to make the generated `cir.switch` a simple form, we will attach the
    statement `b++` into the closest `cir.case` operation. So that the generated
    code will be like:

    ```
    cir.switch(int cond) {
      cir.case(equal, 4) {
        a++;
        b++;
        cir.yield
      }
      cir.case(equal, 5) {
        c++;
        cir.yield
      }
      ...
    }
    ```

    For the same reason, we will hoist the case statement as the substatement
    of another case statement so that they will be in the same level. For
    example,

    ```
    switch(int cond) {
      case 4:
      default;
      case 5;
        a++;
      ...
    }
    ```

    will be generated as

    ```
    cir.switch(int cond) {
      cir.case(equal, 4) {
        cir.yield
      }
      cir.case(default) {
        cir.yield
      }
      cir.case(equal, 5) {
        a++;
        cir.yield
      }
      ...
    }
    ```

    The cir.switch might not be considered "simple" if any of the following is
    true:
    - There are case statements of the switch statement lives in other scopes
      other than the top level compound statement scope. Note that a case
      statement itself doesn't form a scope.
    - The sub-statement of the switch statement is not a compound statement.
    - There are codes before the first case statement. For example,

    ```
    switch(int cond) {
      l:
        b++;

      case 4:
        a++;
        break;

      case 5:
        goto l;
      ...
    }
    ```

    the generated CIR for this non-simple switch would be:

    ```
    cir.switch(int cond) {
      cir.label "l"
      b++;
      cir.case(4) {
        a++;
        cir.break
      }
      cir.case(5) {
        goto "l"
      }
      cir.yield
    }
    ```
  }];

  let arguments = (ins CIR_IntType:$condition);

  let regions = (region AnyRegion:$body);

  let hasVerifier = 1;

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins "mlir::Value":$condition,
               "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location, mlir::OperationState &)>":$switchBuilder)>
  ];

  let assemblyFormat = [{
    custom<SwitchOp>(
      $body, $condition, type($condition)
    )
    attr-dict
  }];

  let extraClassDeclaration = [{
    // Collect cases in the switch.
    void collectCases(llvm::SmallVector<CaseOp> &cases);

    // Check if the switch is in a simple form. If yes, collect the cases to \param cases.
    // This is an expensive and need to be used with caution.
    bool isSimpleForm(llvm::SmallVector<CaseOp> &cases);
  }];
}

//===----------------------------------------------------------------------===//
// BrOp
//===----------------------------------------------------------------------===//

def CIR_BrOp : CIR_Op<"br",[
  DeclareOpInterfaceMethods<BranchOpInterface, ["getSuccessorForOperands"]>,
  Pure, Terminator
]> {
  let summary = "Unconditional branch";
  let description = [{
    The `cir.br` branches unconditionally to a block. Used to represent C/C++
    goto's and general block branching.

    Note that for source level `goto`'s crossing scope boundaries, those are
    usually represented with the "symbolic" `cir.goto` operation.

    Example:

    ```mlir
      ...
        cir.br ^bb3
      ^bb3:
        cir.return
    ```
  }];

  let builders = [
    OpBuilder<(ins "mlir::Block *":$dest,
              CArg<"mlir::ValueRange", "{}">:$destOperands), [{
      $_state.addSuccessors(dest);
      $_state.addOperands(destOperands);
    }]>
  ];

  let arguments = (ins Variadic<CIR_AnyType>:$destOperands);
  let successors = (successor AnySuccessor:$dest);
  let assemblyFormat = [{
    $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// BrCondOp
//===----------------------------------------------------------------------===//

def CIR_BrCondOp : CIR_Op<"brcond", [
  DeclareOpInterfaceMethods<BranchOpInterface, ["getSuccessorForOperands"]>,
  Pure, Terminator, AttrSizedOperandSegments
]> {
  let summary = "Conditional branch";
  let description = [{
    The `cir.brcond %cond, ^bb0, ^bb1` branches to 'bb0' block in case
    %cond (which must be a !cir.bool type) evaluates to true, otherwise
    it branches to 'bb1'.

    Example:

    ```mlir
      ...
        cir.brcond %a, ^bb3, ^bb4
      ^bb3:
        cir.return
      ^bb4:
        cir.yield
    ```
  }];

  let builders = [
    OpBuilder<(ins "mlir::Value":$cond, "mlir::Block *":$destTrue, "mlir::Block *":$destFalse,
               CArg<"mlir::ValueRange", "{}">:$destOperandsTrue,
               CArg<"mlir::ValueRange", "{}">:$destOperandsFalse), [{
      build($_builder, $_state, cond, destOperandsTrue,
            destOperandsFalse, destTrue, destFalse);
    }]>
  ];

  let arguments = (ins CIR_BoolType:$cond,
                       Variadic<CIR_AnyType>:$destOperandsTrue,
                       Variadic<CIR_AnyType>:$destOperandsFalse);
  let successors = (successor AnySuccessor:$destTrue, AnySuccessor:$destFalse);
  let assemblyFormat = [{
    $cond
    $destTrue (`(` $destOperandsTrue^ `:` type($destOperandsTrue) `)`)?
    `,`
    $destFalse (`(` $destOperandsFalse^ `:` type($destOperandsFalse) `)`)?
    attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// While & DoWhileOp
//===----------------------------------------------------------------------===//

class CIR_WhileOpBase<string mnemonic> : CIR_Op<mnemonic, [
  CIR_LoopOpInterface, NoRegionArguments
]> {
  defvar isWhile = !eq(mnemonic, "while");
  let summary = "C/C++ " # !if(isWhile, "while", "do-while") # " loop";
  let builders = [
    OpBuilder<(ins "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$condBuilder,
                   "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$bodyBuilder), [{
        mlir::OpBuilder::InsertionGuard guard($_builder);
        $_builder.createBlock($_state.addRegion());
      }] # !if(isWhile, [{
        condBuilder($_builder, $_state.location);
        $_builder.createBlock($_state.addRegion());
        bodyBuilder($_builder, $_state.location);
      }], [{
        bodyBuilder($_builder, $_state.location);
        $_builder.createBlock($_state.addRegion());
        condBuilder($_builder, $_state.location);
      }])>
  ];
}

def CIR_WhileOp : CIR_WhileOpBase<"while"> {
  let regions = (region SizedRegion<1>:$cond, MinSizedRegion<1>:$body);
  let assemblyFormat = "$cond `do` $body attr-dict";

  let description = [{
    Represents a C/C++ while loop. It consists of two regions:

     - `cond`: single block region with the loop's condition. Should be
     terminated with a `cir.condition` operation.
     - `body`: contains the loop body and an arbitrary number of blocks.

    Example:

    ```mlir
    cir.while {
      cir.break
    ^bb2:
      cir.yield
    } do {
      cir.condition %cond : cir.bool
    }
    ```
  }];
}

def CIR_DoWhileOp : CIR_WhileOpBase<"do"> {
  let regions = (region MinSizedRegion<1>:$body, SizedRegion<1>:$cond);
  let assemblyFormat = " $body `while` $cond attr-dict";

  let extraClassDeclaration = [{
    mlir::Region &getEntry() { return getBody(); }
  }];

  let description = [{
    Represents a C/C++ do-while loop. Identical to `cir.while` but the
    condition is evaluated after the body.

    Example:

    ```mlir
    cir.do {
      cir.break
    ^bb2:
      cir.yield
    } while {
      cir.condition %cond : cir.bool
    }
    ```
  }];
}

//===----------------------------------------------------------------------===//
// ForOp
//===----------------------------------------------------------------------===//

def CIR_ForOp : CIR_Op<"for", [CIR_LoopOpInterface, NoRegionArguments]> {
  let summary = "C/C++ for loop counterpart";
  let description = [{
    Represents a C/C++ for loop. It consists of three regions:

     - `cond`: single block region with the loop's condition. Should be
     terminated with a `cir.condition` operation.
     - `body`: contains the loop body and an arbitrary number of blocks.
     - `step`: single block region with the loop's step.

    Example:

    ```mlir
    cir.for cond {
      cir.condition(%val)
    } body {
      cir.break
    ^bb2:
      cir.yield
    } step {
      cir.yield
    }
    ```
  }];

  let regions = (region SizedRegion<1>:$cond,
                        MinSizedRegion<1>:$body,
                        SizedRegion<1>:$step);
  let assemblyFormat = [{
    `:` `cond` $cond
    `body` $body
    `step` $step
    attr-dict
  }];

  let builders = [
    OpBuilder<(ins "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$condBuilder,
                   "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$bodyBuilder,
                   "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$stepBuilder), [{
        mlir::OpBuilder::InsertionGuard guard($_builder);

        // Build condition region.
        $_builder.createBlock($_state.addRegion());
        condBuilder($_builder, $_state.location);

        // Build body region.
        $_builder.createBlock($_state.addRegion());
        bodyBuilder($_builder, $_state.location);

        // Build step region.
        $_builder.createBlock($_state.addRegion());
        stepBuilder($_builder, $_state.location);
      }]>
  ];

  let extraClassDeclaration = [{
    mlir::Region *maybeGetStep() { return &getStep(); }
    llvm::SmallVector<mlir::Region *> getRegionsInExecutionOrder() {
      return llvm::SmallVector<mlir::Region *, 3>{&getCond(), &getBody(), &getStep()};
    }
  }];
}

//===----------------------------------------------------------------------===//
// GlobalOp
//===----------------------------------------------------------------------===//

// Linkage types. This is currently a replay of llvm/IR/GlobalValue.h, this is
// currently handy as part of forwarding appropriate linkage types for LLVM
// lowering, specially useful for C++ support.

/// An enumeration for the kinds of linkage for global values.
def CIR_GlobalLinkageKind : CIR_I32EnumAttr<
  "GlobalLinkageKind", "linkage kind", [
    // Externally visible function
    I32EnumAttrCase<"ExternalLinkage", 0, "external">,
    // Available for inspection, not emission.
    I32EnumAttrCase<"AvailableExternallyLinkage", 1, "available_externally">,
    // Keep one copy of function when linking (inline)
    I32EnumAttrCase<"LinkOnceAnyLinkage", 2, "linkonce">,
    // Same, but only replaced by something equivalent.
    I32EnumAttrCase<"LinkOnceODRLinkage", 3, "linkonce_odr">,
    // Keep one copy of named function when linking (weak)
    I32EnumAttrCase<"WeakAnyLinkage", 4, "weak">,
    // Same, but only replaced by something equivalent.
    I32EnumAttrCase<"WeakODRLinkage", 5, "weak_odr">,
    // TODO: should we add something like appending linkage too?
    // Special purpose, only applies to global arrays
    // I32EnumAttrCase<"AppendingLinkage", 6, "appending">,
    // Rename collisions when linking (static functions).
    I32EnumAttrCase<"InternalLinkage", 7, "internal">,
    // Like Internal, but omit from symbol table, prefix it with
    // "cir_" to prevent clash with MLIR's symbol "private".
    I32EnumAttrCase<"PrivateLinkage", 8, "cir_private">,
    // ExternalWeak linkage description.
    I32EnumAttrCase<"ExternalWeakLinkage", 9, "extern_weak">,
    // Tentative definitions.
    I32EnumAttrCase<"CommonLinkage", 10, "common">
]>;

def CIR_SignedOverflowBehavior : CIR_I32EnumAttr<
  "SignedOverflowBehavior", "behavior for signed overflow", [
    I32EnumAttrCase<"Undefined", 0, "undefined">,
    I32EnumAttrCase<"Defined", 1, "defined">,
    I32EnumAttrCase<"Trapping", 2, "trapping">
]> {
  let genSpecializedAttr = 0;
}

def CIR_SignedOverflowBehaviorAttr : CIR_EnumAttr<
    CIR_SignedOverflowBehavior, "signed_overflow_behavior">;

def CIR_TLSModel : CIR_I32EnumAttr<"TLS_Model", "TLS model", [
  I32EnumAttrCase<"GeneralDynamic", 0, "tls_dyn">,
  I32EnumAttrCase<"LocalDynamic", 1, "tls_local_dyn">,
  I32EnumAttrCase<"InitialExec", 2, "tls_init_exec">,
  I32EnumAttrCase<"LocalExec", 3, "tls_local_exec">
]>;

def CIR_GlobalOp : CIR_Op<"global", [
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  DeclareOpInterfaceMethods<CIRGlobalValueInterface>,
  NoRegionArguments
]> {
  let summary = "Declares or defines a global variable";
  let description = [{
    The `cir.global` operation declares or defines a named global variable.

    The backing memory for the variable is allocated statically and is
    described by the type of the variable.

    The operation is a declaration if no `inital_value` is
    specified, else it is a definition.

    The global variable can also be marked constant using the
    `constant` unit attribute. Writing to such constant global variables is
    undefined.

    The `linkage` tracks C/C++ linkage types, currently very similar to LLVM's.
    Symbol visibility in `sym_visibility` is defined in terms of MLIR's visibility
    and verified to be in accordance to `linkage`.

    `visibility_attr` is defined in terms of CIR's visibility.

    Example:

    ```mlir
    // Public and constant variable with initial value.
    cir.global public constant @c : i32 = 4;
    ```
  }];

  // Note that both sym_name and sym_visibility are tied to Symbol trait.
  // TODO: sym_visibility can possibly be represented by implementing the
  // necessary Symbol's interface in terms of linkage instead.
  let arguments = (ins
    SymbolNameAttr:$sym_name,
    DefaultValuedAttr<
      CIR_VisibilityAttr,
      "VisibilityKind::Default"
    >:$global_visibility,
    OptionalAttr<StrAttr>:$sym_visibility,
    TypeAttr:$sym_type,
    CIR_GlobalLinkageKind:$linkage,
    DefaultValuedAttr<
      CIR_AddressSpaceAttr,
      "AddressSpace::Default"
    >:$addr_space,
    OptionalAttr<CIR_TLSModel>:$tls_model,
    // Note this can also be a FlatSymbolRefAttr
    OptionalAttr<AnyAttr>:$initial_value,
    UnitAttr:$comdat,
    UnitAttr:$constant,
    UnitAttr:$dso_local,
    OptionalAttr<I64Attr>:$alignment,
    OptionalAttr<ASTVarDeclInterface>:$ast,
    OptionalAttr<StrAttr>:$section,
    OptionalAttr<ArrayAttr>:$annotations
  );

  let regions = (region AnyRegion:$ctorRegion, AnyRegion:$dtorRegion);

  let assemblyFormat = [{
       ($sym_visibility^)?
       (`` $global_visibility^)?
       (`constant` $constant^)?
       $linkage
       (`comdat` $comdat^)?
       ($tls_model^)?
       (`dso_local` $dso_local^)?
       ( `addrspace` `(` $addr_space^ `)` )?
       $sym_name
       custom<GlobalOpTypeAndInitialValue>($sym_type, $initial_value, $ctorRegion, $dtorRegion)
       ($annotations^)?
       attr-dict
  }];

  let extraClassDeclaration = [{
    bool isDeclaration() {
      return !getInitialValue() && getCtorRegion().empty() && getDtorRegion().empty();
    }
    bool hasInitializer() { return !isDeclaration(); }
  }];

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins
      // MLIR's default visibility is public.
      "llvm::StringRef":$sym_name,
      "mlir::Type":$sym_type,
      CArg<"bool", "false">:$isConstant,
      // CIR defaults to external linkage.
      CArg<"cir::GlobalLinkageKind",
            "cir::GlobalLinkageKind::ExternalLinkage">:$linkage,
      CArg<"cir::AddressSpace", "cir::AddressSpace::Default">:$addrSpace,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "nullptr">:$ctorBuilder,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "nullptr">:$dtorBuilder)
    >
  ];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// GetGlobalOp
//===----------------------------------------------------------------------===//

def CIR_GetGlobalOp : CIR_Op<"get_global", [
  Pure, DeclareOpInterfaceMethods<SymbolUserOpInterface>
]> {
  let summary = "Get the address of a global variable";
  let description = [{
    The `cir.get_global` operation retrieves the address pointing to a
    named global variable. If the global variable is marked constant, writing
    to the resulting address (such as through a `cir.store` operation) is
    undefined. Resulting type must always be a `!cir.ptr<...>` type with the
    same address space as the global variable.

    Addresses of thread local globals can only be retrieved if this operation
    is marked `thread_local`, which indicates the address isn't constant.

    Example:
    ```mlir
    %x = cir.get_global @foo : !cir.ptr<i32>
    ...
    %y = cir.get_global thread_local @batata : !cir.ptr<i32>
    ...
    cir.global external addrspace(offload_global) @gv = #cir.int<0> : !s32i
    %z = cir.get_global @gv : !cir.ptr<!s32i, addrspace(offload_global)>
    ```
  }];

  let arguments = (ins FlatSymbolRefAttr:$name, UnitAttr:$tls);
  let results = (outs Res<CIR_PointerType, "", []>:$addr);

  let assemblyFormat = [{
    (`thread_local` $tls^)?
    $name `:` qualified(type($addr)) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// VTableAddrPointOp
//===----------------------------------------------------------------------===//

def CIR_VTableAddrPointOp : CIR_Op<"vtable.address_point",[
  Pure, DeclareOpInterfaceMethods<SymbolUserOpInterface>
]> {
  let summary = "Get the vtable (global variable) address point";
  let description = [{
    The `vtable.address_point` operation retrieves the "effective" address
    (address point) of a C++ virtual table. An object internal `__vptr`
    gets initializated on top of the value returned by this operation.

    `address_point.index` (vtable index)  provides the appropriate vtable within the vtable group
    (as specified by Itanium ABI), and `address_point.offset` (address point index) the actual address
    point within that vtable.

    The return type is always a `!cir.ptr<!cir.ptr<() -> i32>>`.

    Example:
    ```mlir
    cir.global linkonce_odr @_ZTV1B = ...
    ...
    %3 = cir.vtable.address_point(@_ZTV1B, address_point = <index = 0, offset = 2>) : !cir.ptr<!cir.ptr<() -> i32>>
    ```
  }];

  let arguments = (ins
    OptionalAttr<FlatSymbolRefAttr>:$name,
    Optional<CIR_AnyType>:$sym_addr,
    CIR_AddressPointAttr:$address_point
  );

  let results = (outs Res<CIR_PointerType, "", []>:$addr);

  let assemblyFormat = [{
    `(`
      ($name^)?
      ($sym_addr^ `:` type($sym_addr))?
      `,`
        `address_point` `=` $address_point
    `)`
    `:` qualified(type($addr)) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// VTTAddrPointOp
//===----------------------------------------------------------------------===//

def CIR_VTTAddrPointOp : CIR_Op<"vtt.address_point", [
  Pure, DeclareOpInterfaceMethods<SymbolUserOpInterface>
]> {
  let summary = "Get the VTT address point";
  let description = [{
    The `vtt.address_point` operation retrieves an element from the VTT,
    which is the address point of a C++ vtable. In virtual inheritance,
    A set of internal `__vptr` for an object are initialized by this operation,
    which assigns an element from the VTT. The initialization order is as follows:

    The complete object constructors and destructors find the VTT,
    via the mangled name of VTT global variable. They pass the address of
    the subobject's sub-VTT entry in the VTT as a second parameter
    when calling the base object constructors and destructors.
    The base object constructors and destructors use the addresses passed to
    initialize the primary virtual pointer and virtual pointers that point to
    the classes which either have virtual bases or override virtual functions
    with a virtual step.

    The first parameter is either the mangled name of VTT global variable
    or the address of the subobject's sub-VTT entry in the VTT.
    The second parameter `offset` provides a virtual step to adjust to
    the actual address point of the vtable.

    The return type is always a `!cir.ptr<!cir.ptr<void>>`.

    Example:
    ```mlir
    cir.global linkonce_odr @_ZTV1B = ...
    ...
    %3 = cir.base_class_addr(%1 : !cir.ptr<!rec_D> nonnull) [0] -> !cir.ptr<!rec_B>
    %4 = cir.vtt.address_point @_ZTT1D, offset = 1 -> !cir.ptr<!cir.ptr<!void>>
    cir.call @_ZN1BC2Ev(%3, %4)
    ```
    Or:
    ```mlir
    %7 = cir.vtt.address_point %3 : !cir.ptr<!cir.ptr<!void>>, offset = 1 -> !cir.ptr<!cir.ptr<!void>>
    ```
  }];

  let arguments = (ins OptionalAttr<FlatSymbolRefAttr>:$name,
                       Optional<CIR_AnyType>:$sym_addr,
                       I32Attr:$offset);
  let results = (outs CIR_PointerType:$addr);

  let assemblyFormat = [{
      ($name^)?
      ($sym_addr^ `:` type($sym_addr))?
      `,`
      `offset` `=` $offset
    `->` qualified(type($addr)) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// SetBitfieldOp
//===----------------------------------------------------------------------===//

def CIR_SetBitfieldOp : CIR_Op<"set_bitfield"> {
  let summary = "Set a bitfield";
  let description = [{
    The `cir.set_bitfield` operation provides a store-like access to
    a bit field of a record.

    It expects an address of a storage where to store, a type of the storage,
    a value being stored, a name of a bit field, a pointer to the storage in the
    base record, a size of the storage, a size the bit field, an offset
    of the bit field and a sign. Returns a value being stored.

    A unit attribute `volatile` can be used to indicate a volatile load of the
    bitfield.

    Example.
    Suppose we have a struct with multiple bitfields stored in
    different storages. The `cir.set_bitfield` operation sets the value
    of the bitfield.
    ```C++
    typedef struct {
      int a : 4;
      int b : 27;
      int c : 17;
      int d : 2;
      int e : 15;
    } S;

    void store_bitfield(S& s) {
      s.d = 3;
    }
    ```

    ```mlir
    // 'd' is in the storage with the index 1
    !record_type = !cir.record<struct "S" {!cir.int<u, 32>, !cir.int<u, 32>, !cir.int<u, 16>} #cir.record.decl.ast>
    #bfi_d = #cir.bitfield_info<name = "d", storage_type = !u32i, size = 2, offset = 17, is_signed = true>

    %1 = cir.const #cir.int<3> : !s32i
    %2 = cir.load %0 : !cir.ptr<!cir.ptr<!record_type>>, !cir.ptr<!record_type>
    %3 = cir.get_member %2[1] {name = "d"} : !cir.ptr<!record_type> -> !cir.ptr<!u32i>
    %4 = cir.set_bitfield(#bfi_d, %3 : !cir.ptr<!u32i>, %1 : !s32i) -> !s32i
    ```
   }];

  let arguments = (ins
    Arg<CIR_PointerType, "the address to store the value", [MemWrite]>:$addr,
    CIR_AnyType:$src,
    CIR_BitfieldInfoAttr:$bitfield_info,
    UnitAttr:$is_volatile
  );

  let results = (outs CIR_IntType:$result);

  let assemblyFormat = [{ `(`$bitfield_info`,` $addr`:`qualified(type($addr))`,`
    $src`:`type($src) `)`  attr-dict `->` type($result) }];

  let builders = [
    OpBuilder<(ins "mlir::Type":$type,
                   "mlir::Value":$addr,
                   "mlir::Type":$storage_type,
                   "mlir::Value":$src,
                   "llvm::StringRef":$name,
                   "unsigned":$size,
                   "unsigned":$offset,
                   "bool":$is_signed,
                   "bool":$is_volatile
                   ),
   [{
      BitfieldInfoAttr info =
        BitfieldInfoAttr::get($_builder.getContext(),
                              name, storage_type,
                              size, offset, is_signed);
      build($_builder, $_state, type, addr, src, info, is_volatile);
    }]>
  ];
}

//===----------------------------------------------------------------------===//
// GetBitfieldOp
//===----------------------------------------------------------------------===//

def CIR_GetBitfieldOp : CIR_Op<"get_bitfield"> {
  let summary = "Get a bitfield";
  let description = [{
    The `cir.get_bitfield` operation provides a load-like access to
    a bit field of a record.

    It expects a name if a bit field, a pointer to a storage in the
    base record, a type of the storage, a name of the bitfield,
    a size the bit field, an offset of the bit field and a sign.

    A unit attribute `volatile` can be used to indicate a volatile load of the
    bitfield.

    Example:
    Suppose we have a struct with multiple bitfields stored in
    different storages. The `cir.get_bitfield` operation gets the value
    of the bitfield
    ```C++
    typedef struct {
      int a : 4;
      int b : 27;
      int c : 17;
      int d : 2;
      int e : 15;
    } S;

    int load_bitfield(S& s) {
      return s.d;
    }
    ```

    ```mlir
    // 'd' is in the storage with the index 1
    !record_type = !cir.record<struct "S" {!cir.int<u, 32>, !cir.int<u, 32>, !cir.int<u, 16>} #cir.record.decl.ast>
    #bfi_d = #cir.bitfield_info<name = "d", storage_type = !u32i, size = 2, offset = 17, is_signed = true>

    %2 = cir.load %0 : !cir.ptr<!cir.ptr<!record_type>>, !cir.ptr<!record_type>
    %3 = cir.get_member %2[1] {name = "d"} : !cir.ptr<!record_type> -> !cir.ptr<!u32i>
    %4 = cir.get_bitfield(#bfi_d, %3 : !cir.ptr<!u32i>) -> !s32i
    ```
    }];

  let arguments = (ins
    Arg<CIR_PointerType, "the address to load from", [MemRead]>:$addr,
    CIR_BitfieldInfoAttr:$bitfield_info,
    UnitAttr:$is_volatile
  );

  let results = (outs CIR_IntType:$result);

  let assemblyFormat = [{ `(`$bitfield_info `,` $addr attr-dict `:`
   qualified(type($addr)) `)` `->` type($result) }];

  let builders = [
    OpBuilder<(ins "mlir::Type":$type,
                   "mlir::Value":$addr,
                   "mlir::Type":$storage_type,
                   "llvm::StringRef":$name,
                   "unsigned":$size,
                   "unsigned":$offset,
                   "bool":$is_signed,
                   "bool":$is_volatile
                   ),
   [{
      BitfieldInfoAttr info =
        BitfieldInfoAttr::get($_builder.getContext(),
                              name, storage_type,
                              size, offset, is_signed);
      build($_builder, $_state, type, addr, info, is_volatile);
    }]>
  ];
}

//===----------------------------------------------------------------------===//
// GetMemberOp
//===----------------------------------------------------------------------===//

def CIR_GetMemberOp : CIR_Op<"get_member"> {
  let summary = "Get the address of a member of a record";
  let description = [{
    The `cir.get_member` operation gets the address of a particular named
    member from the input record.

    It expects a pointer to the base record as well as the name of the member
    and its field index.

    Example:
    ```mlir
    // Suppose we have a record with multiple members.
    !s32i = !cir.int<s, 32>
    !s8i = !cir.int<s, 32>
    !record_ty = !cir.record<"struct.Bar" {!s32i, !s8i}>

    // Get the address of the member at index 1.
    %1 = cir.get_member %0[1] {name = "i"} : (!cir.ptr<!record_ty>) -> !cir.ptr<!s8i>
    ```
  }];

  let arguments = (ins
    Arg<CIR_PointerType, "the address to load from", [MemRead]>:$addr,
    StrAttr:$name,
    IndexAttr:$index_attr);

  let results = (outs Res<CIR_PointerType, "">:$result);

  let assemblyFormat = [{
    $addr `[` $index_attr `]` attr-dict
    `:` qualified(type($addr)) `->` qualified(type($result))
  }];

  let builders = [
    OpBuilder<(ins "mlir::Type":$type,
                   "mlir::Value":$value,
                   "llvm::StringRef":$name,
                   "unsigned":$index),
    [{
      mlir::APInt fieldIdx(64, index);
      build($_builder, $_state, type, value, name, fieldIdx);
    }]>
  ];

  let extraClassDeclaration = [{
    /// Return the index of the record member being accessed.
    uint64_t getIndex() { return getIndexAttr().getZExtValue(); }

    /// Return the record type pointed by the base pointer.
    cir::PointerType getAddrTy() { return getAddr().getType(); }
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// ExtractMemberOp
//===----------------------------------------------------------------------===//

def CIR_ExtractMemberOp : CIR_Op<"extract_member", [Pure]> {
  let summary = "Extract the value of a member of a record value";
  let description = [{
    The `cir.extract_member` operation extracts the value of a particular member
    from the input record. Unlike `cir.get_member` which derives pointers, this
    operation operates on values. It takes a value of record type, and extract
    the value of the specified record member from the input record value.

    Currently `cir.extract_member` does not work on unions.

    Example:

    ```mlir
    // Suppose we have a record with multiple members.
    !s32i = !cir.int<s, 32>
    !s8i = !cir.int<s, 32>
    !record_ty = !cir.record<"struct.Bar" {!s32i, !s8i}>

    // And suppose we have a value of the record type.
    %0 = cir.const #cir.const_record<{#cir.int<1> : !s32i, #cir.int<2> : !s8i}> : !record_ty

    // Extract the value of the second member of the record.
    %1 = cir.extract_member %0[1] : !record_ty -> !s8i
    ```
  }];

  let arguments = (ins CIRRecordType:$record, IndexAttr:$index_attr);
  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
    $record `[` $index_attr `]` attr-dict
    `:` qualified(type($record)) `->` qualified(type($result))
  }];

  let builders = [
    OpBuilder<(ins "mlir::Type":$type, "mlir::Value":$record, "uint64_t":$index), [{
      mlir::APInt fieldIdx(64, index);
      build($_builder, $_state, type, record, fieldIdx);
    }]>,
    OpBuilder<(ins "mlir::Value":$record, "uint64_t":$index), [{
      auto recordTy = mlir::cast<cir::RecordType>(record.getType());
      mlir::Type memberTy = recordTy.getMembers()[index];
      build($_builder, $_state, memberTy, record, index);
    }]>
  ];

  let extraClassDeclaration = [{
    /// Get the index of the record member being accessed.
    uint64_t getIndex() { return getIndexAttr().getZExtValue(); }
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// InsertMemberOp
//===----------------------------------------------------------------------===//

def CIR_InsertMemberOp : CIR_Op<"insert_member", [
  Pure, AllTypesMatch<["record", "result"]>
]> {
  let summary = "Overwrite the value of a member of a record value";
  let description = [{
    The `cir.insert_member` operation overwrites the value of a particular
    member in the input record value, and returns the modified record value. The
    result of this operation is equal to the input record value, except for the
    member specified by `index_attr` whose value is equal to the given value.

    This operation is named after the LLVM instruction `insertvalue`.

    Currently `cir.insert_member` does not work on unions.

    Example:

    ```mlir
    // Suppose we have a record with multiple members.
    !s32i = !cir.int<s, 32>
    !s8i = !cir.int<s, 32>
    !record_ty = !cir.record<"struct.Bar" {!s32i, !s8i}>

    // And suppose we have a value of the record type.
    %0 = cir.const #cir.const_record<{#cir.int<1> : !s32i, #cir.int<2> : !s8i}> : !record_ty
    // %0 is {1, 2}

    // Overwrite the second member of the record value.
    %1 = cir.const #cir.int<3> : !s8i
    %2 = cir.insert_member %0[1], %1 : !record_ty, !s8i
    // %2 is {1, 3}
    ```
  }];

  let arguments = (ins CIRRecordType:$record, IndexAttr:$index_attr,
                       CIR_AnyType:$value);
  let results = (outs CIRRecordType:$result);

  let builders = [
    OpBuilder<(ins "mlir::Value":$record, "uint64_t":$index,
                   "mlir::Value":$value), [{
      mlir::APInt fieldIdx(64, index);
      build($_builder, $_state, record, fieldIdx, value);
    }]>
  ];

  let extraClassDeclaration = [{
    /// Get the index of the record member being accessed.
    uint64_t getIndex() { return getIndexAttr().getZExtValue(); }
  }];

  let assemblyFormat = [{
    $record `[` $index_attr `]` `,` $value attr-dict
    `:` qualified(type($record)) `,` qualified(type($value))
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// GetRuntimeMemberOp
//===----------------------------------------------------------------------===//

def CIR_GetRuntimeMemberOp : CIR_Op<"get_runtime_member"> {
  let summary = "Get the address of a member of a record";
  let description = [{
    The `cir.get_runtime_member` operation gets the address of a member from
    the input record. The target member is given by a value of type
    `!cir.data_member` (i.e. a pointer-to-data-member value).

    This operation differs from `cir.get_member` in when the target member can
    be determined. For the `cir.get_member` operation, the target member is
    specified as a constant index so the member it returns access to is known
    when the operation is constructed. For the `cir.get_runtime_member`
    operation, the target member is given through a pointer-to-data-member
    value which is unknown until the program being compiled is executed. In
    other words, `cir.get_member` represents a normal member access through the
    `.` operator in C/C++:

    ```cpp
    struct Foo { int x; };
    Foo f;
    (void)f.x;  // cir.get_member
    ```

    And `cir.get_runtime_member` represents a member access through the `.*` or
    the `->*` operator in C++:

    ```cpp
    struct Foo { int x; }
    Foo f;
    Foo *p;
    int Foo::*member;

    (void)f.*member;   // cir.get_runtime_member
    (void)f->*member;  // cir.get_runtime_member
    ```

    This operation expects a pointer to the base record as well as the pointer
    to the target member.
  }];

  let arguments = (ins
    Arg<CIR_PtrToRecordType, "address of the record object", [MemRead]>:$addr,
    Arg<CIR_DataMemberType, "pointer to the target member">:$member);

  let results = (outs Res<CIR_PointerType, "">:$result);

  let assemblyFormat = [{
    $addr `[` $member `:` qualified(type($member)) `]` attr-dict
    `:` qualified(type($addr)) `->` qualified(type($result))
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// GetMethodOp
//===----------------------------------------------------------------------===//

def CIR_GetMethodOp : CIR_Op<"get_method"> {
  let summary = "Resolve a method to a function pointer as callee";
  let description = [{
    The `cir.get_method` operation takes a method and an object as input, and
    yields a function pointer that points to the actual function corresponding
    to the input method. The operation also applies any necessary adjustments to
    the input object pointer for calling the method and yields the adjusted
    pointer.

    This operation is generated when calling a method through a pointer-to-
    member-function in C++:

    ```cpp
    // Foo *object;
    // int arg;
    // void (Foo::*method)(int);

    (object->*method)(arg);
    ```

    The code above will generate CIR similar as:

    ```mlir
    // %object = ...
    // %arg = ...
    // %method = ...
    %callee, %this = cir.get_method %method, %object
    cir.call %callee(%this, %arg)
    ```

    The method type must match the callee type. That is:
    - The return type of the method must match the return type of the callee.
    - The first parameter of the callee must have type `!cir.ptr<!cir.void>`.
    - Types of other parameters of the callee must match the parameters of the
      method.
  }];

  let arguments = (ins CIR_MethodType:$method, CIR_PtrToRecordType:$object);
  let results = (outs CIR_PtrToFunc:$callee, CIR_VoidPtrType:$adjusted_this);

  let assemblyFormat = [{
    $method `,` $object
    `:` `(` qualified(type($method)) `,` qualified(type($object)) `)`
    `->` `(` qualified(type($callee)) `,` qualified(type($adjusted_this)) `)`
    attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// GetElementOp
//===----------------------------------------------------------------------===//

def CIR_GetElementOp : CIR_Op<"get_element"> {
  let summary = "Get the address of an array element";
  let description = [{
    The `cir.get_element` operation gets the address of a particular element
    from the `base` array.

    It expects a pointer to the `base` array and the `index` of the element.

    Example:
    ```mlir
    // Suppose we have a array.
    !s32i = !cir.int<s, 32>
    !arr_ty = !cir.array<!s32i x 4>

    // Get the address of the element at index 1.
    %elem_1 = cir.get_element %0[1] : (!cir.ptr<!array_ty>, !s32i) -> !cir.ptr<!s32i>

    // Get the address of the element at index %i.
    %i = ...
    %elem_i = cir.get_element %0[%i] : (!cir.ptr<!array_ty>, !s32i) -> !cir.ptr<!s32i>
    ```
  }];

  let arguments = (ins
    Arg<CIR_PtrToArray, "the base address of the array ">:$base,
    Arg<CIR_AnyFundamentalIntType, "the index of the element">:$index
  );

  let results = (outs CIR_PointerType:$result);

  let assemblyFormat = [{
    $base `[` $index `]` `:` `(` qualified(type($base)) `,` qualified(type($index)) `)`
    `->` qualified(type($result)) attr-dict
  }];

  let extraClassDeclaration = [{
    // Get the type of the element.
    mlir::Type getElementType() {
      return getType().getPointee();
    }
    cir::PointerType getBaseType() {
      return mlir::cast<cir::PointerType>(getBase().getType());
    }
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// VecInsertOp
//===----------------------------------------------------------------------===//

def CIR_VecInsertOp : CIR_Op<"vec.insert", [
  Pure,
  TypesMatchWith<"argument type matches vector element type",
    "vec", "value", "mlir::cast<cir::VectorType>($_self).getElementType()">,
  AllTypesMatch<["result", "vec"]>
]> {
  let summary = "Insert one element into a vector object";
  let description = [{
    The `cir.vec.insert` operation replaces the element of the given vector at
    the given index with the given value.  The new vector with the inserted
    element is returned.
  }];

  let arguments = (ins
    CIR_VectorType:$vec,
    CIR_VectorElementType:$value,
    CIR_AnyFundamentalIntType:$index
  );

  let results = (outs CIR_VectorType:$result);

  let assemblyFormat = [{
    $value `,` $vec `[` $index `:` type($index) `]` attr-dict `:`
    qualified(type($vec))
  }];

  let llvmOp = "InsertElementOp";
}

//===----------------------------------------------------------------------===//
// VecExtractOp
//===----------------------------------------------------------------------===//

def CIR_VecExtractOp : CIR_Op<"vec.extract", [
  Pure,
  TypesMatchWith<"type of 'result' matches element type of 'vec'",
    "vec",  "result", "mlir::cast<cir::VectorType>($_self).getElementType()">
]> {
  let summary = "Extract one element from a vector object";
  let description = [{
    The `cir.vec.extract` operation extracts the element at the given index
    from a vector object.
  }];

  let arguments = (ins
    CIR_VectorType:$vec,
    CIR_AnyFundamentalIntType:$index
  );

  let results = (outs CIR_VectorElementType:$result);

  let assemblyFormat = [{
    $vec `[` $index `:` type($index) `]` attr-dict `:` qualified(type($vec))
  }];

  let llvmOp = "ExtractElementOp";
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// VecCreate
//===----------------------------------------------------------------------===//

def CIR_VecCreateOp : CIR_Op<"vec.create", [Pure]> {
  let summary = "Create a vector value";
  let description = [{
    The `cir.vec.create` operation creates a vector value with the given element
    values. The number of element arguments must match the number of elements
    in the vector type.
  }];

  let arguments = (ins Variadic<CIR_VectorElementType>:$elements);
  let results = (outs CIR_VectorType:$result);

  let assemblyFormat = [{
    `(` ($elements^ `:` type($elements))? `)` `:` qualified(type($result))
    attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// VecSplat
//===----------------------------------------------------------------------===//

// cir.vec.splat is a separate operation from cir.vec.create because more
// efficient LLVM IR can be generated for it, and because some optimization and
// analysis passes can benefit from knowing that all elements of the vector
// have the same value.

def CIR_VecSplatOp : CIR_Op<"vec.splat", [
  Pure,
  TypesMatchWith<"type of 'value' matches element type of 'result'",
    "result", "value", "mlir::cast<cir::VectorType>($_self).getElementType()">
]> {
  let summary = "Convert a scalar into a vector";
  let description = [{
    The `cir.vec.splat` operation creates a vector value from a scalar value.
    All elements of the vector have the same value, that of the given scalar.
  }];

  let arguments = (ins CIR_VectorElementType:$value);
  let results = (outs CIR_VectorType:$result);

  let assemblyFormat = [{
    $value `:` type($value) `,` qualified(type($result)) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// VecCmp
//===----------------------------------------------------------------------===//

def CIR_VecCmpOp : CIR_Op<"vec.cmp", [Pure, SameTypeOperands]> {
  let summary = "Compare two vectors";
  let description = [{
    The `cir.vec.cmp` operation does an element-wise comparison of two vectors
    of the same type. The result is a vector of the same size as the operands
    whose element type is the signed integral type that is the same size as the
    element type of the operands.  The values in the result are 0 or -1.
  }];

  let arguments = (ins
    CIR_CmpOpKind:$kind,
    CIR_VectorType:$lhs,
    CIR_VectorType:$rhs
  );

  let results = (outs CIR_VectorType:$result);

  let assemblyFormat = [{
    `(` $kind `,` $lhs `,` $rhs `)` `:` qualified(type($lhs)) `,`
    qualified(type($result)) attr-dict
  }];

  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// VecTernary
//===----------------------------------------------------------------------===//

def CIR_VecTernaryOp : CIR_Op<"vec.ternary", [
  Pure, AllTypesMatch<["result", "lhs", "rhs"]>
]> {
  let summary = "The `cond ? a : b` ternary operator for vector types";
  let description = [{
    The `cir.vec.ternary` operation represents the C/C++ ternary operator,
    `?:`, for vector types, which does a `select` on individual elements of the
    vectors. Unlike a regular `?:` operator, there is no short circuiting. All
    three arguments are always evaluated.  Because there is no short
    circuiting, there are no regions in this operation, unlike cir.ternary.

    The first argument is a vector of integral type. The second and third
    arguments are vectors of the same type and have the same number of elements
    as the first argument.

    The result is a vector of the same type as the second and third arguments.
    Each element of the result is `(bool)a[n] ? b[n] : c[n]`.
  }];

  let arguments = (ins
    CIR_VectorOfIntType:$cond,
    CIR_VectorType:$lhs,
    CIR_VectorType:$rhs
  );

  let results = (outs CIR_VectorType:$result);
  let assemblyFormat = [{
    `(` $cond `,` $lhs `,` $rhs `)` `:` qualified(type($cond)) `,`
    qualified(type($lhs)) attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// VecShuffle
//===----------------------------------------------------------------------===//

// TODO: Create an interface that both VecShuffleOp and VecShuffleDynamicOp
// implement.  This could be useful for passes that don't care how the vector
// shuffle was specified.

def CIR_VecShuffleOp : CIR_Op<"vec.shuffle", [
  Pure, AllTypesMatch<["vec1", "vec2"]>
]> {
  let summary = "Combine two vectors using indices passed as constant integers";
  let description = [{
    The `cir.vec.shuffle` operation implements the documented form of Clang's
    __builtin_shufflevector, where the indices of the shuffled result are
    integer constants.

    The two input vectors, which must have the same type, are concatenated.
    Each of the integer constant arguments is interpreted as an index into that
    concatenated vector, with a value of -1 meaning that the result value
    doesn't matter. The result vector, which must have the same element type as
    the input vectors and the same number of elements as the list of integer
    constant indices, is constructed by taking the elements at the given
    indices from the concatenated vector.  The size of the result vector does
    not have to match the size of the individual input vectors or of the
    concatenated vector.
  }];
  let arguments = (ins CIR_VectorType:$vec1, CIR_VectorType:$vec2,
		       ArrayAttr:$indices);
  let results = (outs CIR_VectorType:$result);
  let assemblyFormat = [{
    `(` $vec1 `,` $vec2 `:` qualified(type($vec1)) `)` $indices `:`
     qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// VecShuffleDynamic
//===----------------------------------------------------------------------===//

def CIR_VecShuffleDynamicOp : CIR_Op<"vec.shuffle.dynamic", [
  Pure, AllTypesMatch<["vec", "result"]>
]> {
  let summary = "Shuffle a vector using indices in another vector";
  let description = [{
    The `cir.vec.shuffle.dynamic` operation implements the undocumented form of
    Clang's __builtin_shufflevector, where the indices of the shuffled result
    can be runtime values.

    There are two input vectors, which must have the same number of elements.
    The second input vector must have an integral element type. The elements of
    the second vector are interpreted as indices into the first vector. The
    result vector is constructed by taking the elements from the first input
    vector from the indices indicated by the elements of the second vector.
  }];
  let arguments = (ins CIR_VectorType:$vec, CIR_VectorOfIntType:$indices);
  let results = (outs CIR_VectorType:$result);
  let assemblyFormat = [{
    $vec `:` qualified(type($vec)) `,` $indices `:` qualified(type($indices))
    attr-dict
  }];

  let hasVerifier = 1;
  let hasFolder = 1;
}

//===----------------------------------------------------------------------===//
// BaseClassAddr & DerivedClassAddrOp
//===----------------------------------------------------------------------===//

def CIR_BaseClassAddrOp : CIR_Op<"base_class_addr"> {
  let summary = "Get the base class address for a class/struct";
  let description = [{
    The `cir.base_class_addr` operaration gets the address of a particular
    non-virtual base class given a derived class pointer. The offset in bytes
    of the base class must be passed in, since it is easier for the front end
    to calculate that than the MLIR passes. The operation contains a flag for
    whether or not the operand may be nullptr. That depends on the context and
    cannot be known by the operation, and that information affects how the
    operation is lowered.

    Example:
    ```c++
    struct Base { };
    struct Derived : Base { };
    Derived d;
    Base& b = d;
    ```
    will generate
    ```mlir
    %3 = cir.base_class_addr %1 : !cir.ptr<!rec_Derived> nonnull [0] -> !cir.ptr<!rec_Base>
    ```
  }];

  // The validity of the relationship of derived and base cannot yet be
  // verified, currently not worth adding a verifier.
  let arguments = (ins
    Arg<CIR_PointerType, "derived class pointer", [MemRead]>:$derived_addr,
    IndexAttr:$offset, UnitAttr:$assume_not_null);

  let results = (outs Res<CIR_PointerType, "">:$base_addr);

  let assemblyFormat = [{
      $derived_addr `:` qualified(type($derived_addr))
      (`nonnull` $assume_not_null^)?
      ` ` `[` $offset `]` `->` qualified(type($base_addr)) attr-dict
  }];
}

def CIR_DerivedClassAddrOp : CIR_Op<"derived_class_addr"> {
  let summary = "Get the derived class address for a class/struct";
  let description = [{
    The `cir.derived_class_addr` operaration gets the address of a particular
    derived class given a non-virtual base class pointer. The offset in bytes
    of the base class must be passed in, similar to `cir.base_class_addr`, but
    going into the other direction (In the itanium ABI this means lowering to
    a negative offset).

    The operation contains a flag for whether or not the operand may be nullptr.
    That depends on the context and cannot be known by the operation, and that
    information affects how the operation is lowered.

    Example:
    ```c++
    class A { int a; };
    class B { int b;
    public:
        A *getAsA();
    };
    class X : public A, public B { int x; };

    A *B::getAsA() {
      return static_cast<X*>(this);
    ```

    leads to
    ```mlir
      %2 = cir.load %0 : !cir.ptr<!cir.ptr<!rec_B>>, !cir.ptr<!rec_B>
      %3 = cir.derived_class_addr %2 : !cir.ptr<!rec_B> nonnull [4] -> !cir.ptr<!rec_X>
      %4 = cir.base_class_addr %3 : !cir.ptr<!rec_X> [0] -> !cir.ptr<!rec_A>
      cir.return %4
    ```
  }];

  // The validity of the relationship of derived and base cannot yet be
  // verified, currently not worth adding a verifier.
  let arguments = (ins
    Arg<CIR_PointerType, "derived class pointer", [MemRead]>:$base_addr,
    IndexAttr:$offset, UnitAttr:$assume_not_null);

  let results = (outs Res<CIR_PointerType, "">:$derived_addr);

  let assemblyFormat = [{
      $base_addr `:` qualified(type($base_addr))
      (`nonnull` $assume_not_null^)?
      ` ` `[` $offset `]` `->` qualified(type($derived_addr)) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// BaseDataMemberOp & DerivedDataMemberOp
//===----------------------------------------------------------------------===//

def CIR_BaseDataMemberOp : CIR_Op<"base_data_member", [Pure]> {
  let summary =
    "Cast a derived class data member pointer to a base class data member "
    "pointer";
  let description = [{
    The `cir.base_data_member` operation casts a data member pointer of type
    `T Derived::*` to a data member pointer of type `T Base::*`, where `Base`
    is an accessible non-ambiguous non-virtual base class of `Derived`.

    The `offset` parameter gives the offset in bytes of the `Base` base class
    subobject within a `Derived` object.
  }];

  let arguments = (ins CIR_DataMemberType:$src, IndexAttr:$offset);
  let results = (outs CIR_DataMemberType:$result);

  let assemblyFormat = [{
    $src `:` qualified(type($src))
    ` ` `[` $offset `]` `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
}

def CIR_DerivedDataMemberOp : CIR_Op<"derived_data_member", [Pure]> {
  let summary =
    "Cast a base class data member pointer to a derived class data member "
    "pointer";
  let description = [{
    The `cir.derived_data_member` operation casts a data member pointer of type
    `T Base::*` to a data member pointer of type `T Derived::*`, where `Base`
    is an accessible non-ambiguous non-virtual base class of `Derived`.

    The `offset` parameter gives the offset in bytes of the `Base` base class
    subobject within a `Derived` object.
  }];

  let arguments = (ins CIR_DataMemberType:$src, IndexAttr:$offset);
  let results = (outs CIR_DataMemberType:$result);

  let assemblyFormat = [{
    $src `:` qualified(type($src))
    ` ` `[` $offset `]` `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// BaseMethodOp & DerivedMethodOp
//===----------------------------------------------------------------------===//

def CIR_BaseMethodOp : CIR_Op<"base_method", [Pure]> {
  let summary = [{
    Cast a derived class pointer-to-member-function to a base class
    pointer-to-member-function
  }];
  let description = [{
    The `cir.base_method` operation casts a pointer-to-member-function of type
    `Ret (Derived::*)(Args)` to a pointer-to-member-function of type
    `Ret (Base::*)(Args)`, where `Base` is a non-virtual base class of
    `Derived`.

    The `offset` parameter gives the offset in bytes of the `Base` base class
    subobject within a `Derived` object.

    Example:

    ```mlir
    %1 = cir.base_method %0 : !cir.method<!cir.func<(!s32i)> in !rec_Derived> [16] -> !cir.method<!cir.func<(!s32i)> in !rec_Base>
    ```
  }];

  let arguments = (ins CIR_MethodType:$src, IndexAttr:$offset);
  let results = (outs CIR_MethodType:$result);

  let assemblyFormat = [{
    $src `:` qualified(type($src))
    ` ` `[` $offset `]` `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
}

def CIR_DerivedMethodOp : CIR_Op<"derived_method", [Pure]> {
  let summary = [{
    Cast a base class pointer-to-member-function to a derived class
    pointer-to-member-function
  }];
  let description = [{
    The `cir.derived_method` operation casts a pointer-to-member-function of
    type `Ret (Base::*)(Args)` to a pointer-to-member-function of type
    `Ret (Derived::*)(Args)`, where `Base` is a non-virtual base class of
    `Derived`.

    The `offset` parameter gives the offset in bytes of the `Base` base class
    subobject within a `Derived` object.

    Example:

    ```mlir
    %1 = cir.derived_method %0 : !cir.method<!cir.func<(!s32i)> in !rec_Base> [16] -> !cir.method<!cir.func<(!s32i)> in !rec_Derived>
    ```
  }];

  let arguments = (ins CIR_MethodType:$src, IndexAttr:$offset);
  let results = (outs CIR_MethodType:$result);

  let assemblyFormat = [{
    $src `:` qualified(type($src))
    ` ` `[` $offset `]` `->` qualified(type($result)) attr-dict
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// FuncOp
//===----------------------------------------------------------------------===//

// The enumeration values are not necessarily in sync with `clang::CallingConv`
// or `llvm::CallingConv`.
def CIR_CallingConv : CIR_I32EnumAttr<"CallingConv", "calling convention", [
  I32EnumAttrCase<"C", 1, "c">,
  I32EnumAttrCase<"SpirKernel", 2, "spir_kernel">,
  I32EnumAttrCase<"SpirFunction", 3, "spir_function">,
  I32EnumAttrCase<"OpenCLKernel", 4, "opencl_kernel">,
  I32EnumAttrCase<"PTXKernel", 5, "ptx_kernel">
]>;

def CIR_OptionalPriorityAttr : OptionalAttr<
  DefaultValuedAttr<
    ConfinedAttr<I32Attr, [IntMinValue<101>, IntMaxValue<65535>]>,
    "cir::DefaultGlobalCtorDtorPriority"
  >
>;

def FuncOp : CIR_Op<"func", [
  AutomaticAllocationScope, CallableOpInterface, FunctionOpInterface,
  DeclareOpInterfaceMethods<CIRGlobalValueInterface>,
  HasAtMostOneOfAttrs<["global_ctor_priority", "global_dtor_priority"]>,
  IsolatedFromAbove
]> {
  let summary = "Declare or define a function";
  let description = [{

    Similar to `mlir::FuncOp` built-in:
    > Operations within the function cannot implicitly capture values defined
    > outside of the function, i.e. Functions are `IsolatedFromAbove`. All
    > external references must use function arguments or attributes that establish
    > a symbolic connection (e.g. symbols referenced by name via a string
    > attribute like SymbolRefAttr). An external function declaration (used when
    > referring to a function declared in some other module) has no body. While
    > the MLIR textual form provides a nice inline syntax for function arguments,
    > they are internally represented as “block arguments” to the first block in
    > the region.
    >
    > Only dialect attribute names may be specified in the attribute dictionaries
    > for function arguments, results, or the function itself.

    The function linkage information is specified by `linkage`, as defined by
    `GlobalLinkageKind` attribute.

    The `calling_conv` attribute specifies the calling convention of the function.
    The default calling convention is `CallingConv::C`.

    A compiler builtin function must be marked as `builtin` for further
    processing when lowering from CIR.

    The `coroutine` keyword is used to mark coroutine function, which requires
    at least one `cir.await` instruction to be used in its body.

    The `lambda` translates to a C++ `operator()` that implements a lambda, this
    allow callsites to make certain assumptions about the real function nature
    when writing analysis. The verifier should, but do act on this keyword yet.

    The `no_proto` keyword is used to identify functions that were declared
    without a prototype and, consequently, may contain calls with invalid
    arguments and undefined behavior.

    The `extra_attrs`, which is an aggregate of function-specific attributes is
    required and mandatory to describle additional attributes that are not listed
    above. Though mandatory, the prining of the attribute can be omitted if it is
    empty.

    The `global_ctor` indicates whether a function should execute before `main()`
    function, as specified by `__attribute__((constructor))`. A execution priority
    can also be specified `global_ctor(<prio>)`. Similarly, for global destructors
    both `global_dtor` and `global_dtor(<prio>)` are available.

    Example:

    ```mlir
    // External function definitions.
    cir.func @abort()

    // A function with internal linkage.
    cir.func internal @count(%x: i64) -> (i64)
      return %x : i64
    }

    // Linkage information
    cir.func linkonce_odr @some_method(...)

    // Calling convention information
    cir.func @another_func(...) cc(spir_kernel) extra(#fn_attr)

    // Builtin function
    cir.func builtin @__builtin_coro_end(!cir.ptr<i8>, !cir.bool) -> !cir.bool

    // Coroutine
    cir.func coroutine @_Z10silly_taskv() -> !CoroTask {
      ...
      cir.await(...)
      ...
    }
    ```
  }];

  let arguments = (ins
    SymbolNameAttr:$sym_name,
    CIR_VisibilityAttr:$global_visibility,
    TypeAttrOf<CIR_FuncType>:$function_type,
    UnitAttr:$builtin,
    UnitAttr:$coroutine,
    UnitAttr:$lambda,
    UnitAttr:$no_proto,
    UnitAttr:$dso_local,
    DefaultValuedAttr<
      CIR_GlobalLinkageKind, "GlobalLinkageKind::ExternalLinkage"
    >:$linkage,
    DefaultValuedAttr<
      CIR_CallingConv, "CallingConv::C"
    >:$calling_conv,
    CIR_ExtraFuncAttr:$extra_attrs,
    OptionalAttr<StrAttr>:$sym_visibility,
    UnitAttr:$comdat,
    OptionalAttr<DictArrayAttr>:$arg_attrs,
    OptionalAttr<DictArrayAttr>:$res_attrs,
    OptionalAttr<FlatSymbolRefAttr>:$aliasee,
    CIR_OptionalPriorityAttr:$global_ctor_priority,
    CIR_OptionalPriorityAttr:$global_dtor_priority,
    OptionalAttr<ArrayAttr>:$annotations,
    OptionalAttr<AnyASTFunctionDeclAttr>:$ast
  );

  let regions = (region AnyRegion:$body);
  let skipDefaultBuilders = 1;

  let builders = [OpBuilder<(ins
    "llvm::StringRef":$name, "FuncType":$type,
    CArg<"GlobalLinkageKind", "GlobalLinkageKind::ExternalLinkage">:$linkage,
    CArg<"CallingConv", "CallingConv::C">:$callingConv,
    CArg<"llvm::ArrayRef<mlir::NamedAttribute>", "{}">:$attrs,
    CArg<"llvm::ArrayRef<mlir::DictionaryAttr>", "{}">:$argAttrs)
  >];

  let extraClassDeclaration = [{
    /// Returns the region on the current operation that is callable. This may
    /// return null in the case of an external callable object, e.g. an external
    /// function.
    ::mlir::Region *getCallableRegion();

    /// Returns the results types that the callable region produces when
    /// executed.
    llvm::ArrayRef<mlir::Type> getCallableResults() {
      return getFunctionType().getReturnTypes();
    }

    /// Returns the argument attributes for all callable region arguments or
    /// null if there are none.
    ::mlir::ArrayAttr getCallableArgAttrs() {
      return getArgAttrs().value_or(nullptr);
    }

    /// Returns the result attributes for all callable region results or null if
    /// there are none.
    ::mlir::ArrayAttr getCallableResAttrs() {
      return getResAttrs().value_or(nullptr);
    }

    /// Returns the argument types of this function.
    llvm::ArrayRef<mlir::Type> getArgumentTypes() {
       return getFunctionType().getInputs();
    }

    /// Returns 0 or 1 result type of this function (0 in the case of a function
    /// returing void)
    llvm::ArrayRef<mlir::Type> getResultTypes() {
       return getFunctionType().getReturnTypes();
    }

    //===------------------------------------------------------------------===//
    // SymbolOpInterface Methods
    //===------------------------------------------------------------------===//

    bool isDeclaration();
  }];

  let hasCustomAssemblyFormat = 1;
  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// LLVMIntrinsicCallOp
//===----------------------------------------------------------------------===//

def CIR_LLVMIntrinsicCallOp : CIR_Op<"llvm.intrinsic"> {
  let summary = "Call to llvm intrinsic functions that is not defined in CIR";
  let description = [{
    `cir.llvm.intrinsic` operation represents a call-like expression which has
    return type and arguments that maps directly to a llvm intrinsic.
    It only records intrinsic `intrinsic_name`.
  }];

  let results = (outs Optional<CIR_AnyType>:$result);
  let arguments = (ins
                   StrAttr:$intrinsic_name, Variadic<CIR_AnyType>:$arg_ops);

  let skipDefaultBuilders = 1;

  let assemblyFormat = [{
    $intrinsic_name $arg_ops `:` functional-type($arg_ops, $result) attr-dict
  }];

  let builders = [
    OpBuilder<(ins "mlir::StringAttr":$intrinsic_name, "mlir::Type":$resType,
              CArg<"mlir::ValueRange", "{}">:$operands), [{
      $_state.addAttribute("intrinsic_name", intrinsic_name);
      $_state.addOperands(operands);
      if (resType)
        $_state.addTypes(resType);
    }]>,
  ];

}

//===----------------------------------------------------------------------===//
// InvariantGroupOp
//===----------------------------------------------------------------------===//

def CIR_InvariantGroupOp : CIR_Op<"invariant_group", [
  Pure, SameOperandsAndResultType
]> {
  let summary = "Start an invariant group";
  let description = [{
    The `cir.invariant_group` operation takes a single pointer value as argument
    and returns the same pointer value with fresh [invariant group] information.
    All loads and stores that access the returned pointer value are presumed by
    the optimizer to load or store the same value.

    [invariant group]: https://llvm.org/docs/LangRef.html#invariant-group-metadata

    This operation is not emitted during CIRGen. Instead, it is created when
    hoisting constant alloca operations to the entry block of a function. This
    operation effectively marks the syntactic scope of the constant local
    variable represented by the hosited alloca operation, and it allows for
    better LLVMIR generation with potentially more optimizations.

    For example, if we have the following CIR before alloca hoisting:

    ```mlir
    cir.func @foo() {
      cir.scope {
        %0 = cir.alloca !s32i : !cir.ptr<!s32i>
        use(%0)
      }
    }
    ```

    After alloca hoisting:

    ```mlir
    cir.func @foo() {
      %0 = cir.alloca !s32i : !cir.ptr<!s32i>
      cir.scope {
        %1 = cir.invariant_group %0 : !cir.ptr<!s32i>
        use(%1)
      }
    }
    ```

    During LLVMIR lowering, load and store operations whose pointer operand
    comes from `cir.invariant_group` are lowered to corresponding LLVM
    instructions with invariant group metadata attached.
  }];

  let arguments = (ins CIR_PointerType:$ptr);
  let results = (outs CIR_PointerType:$result);

  let assemblyFormat = [{
    $ptr `:` type($result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// DeleteArrayOp
//===----------------------------------------------------------------------===//

def CIR_DeleteArrayOp : CIR_Op<"delete.array"> {
  let summary = "Delete address representing an array";
  let description = [{
    `cir.delete.array` operation deletes an array. For example, `delete[] ptr;`
    will be translated to `cir.delete.array %ptr`.
  }];

  let arguments = (ins CIR_PointerType:$address);

  let assemblyFormat = [{
    $address `:` type($address) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// CallOp and TryCallOp
//===----------------------------------------------------------------------===//

def CIR_SideEffect : CIR_I32EnumAttr<
    "SideEffect", "allowed side effects of a function", [
      I32EnumAttrCase<"All", 0, "all">,
      I32EnumAttrCase<"Pure", 1, "pure">,
      I32EnumAttrCase<"Const", 2, "const">
]> {
  let description = [{
    The side effect attribute specifies the possible side effects of the callee
    of a call operation. This is an enumeration attribute and all possible
    enumerators are:

    - all: The callee can have any side effects. This is the default if no side
      effects are explicitly listed.
    - pure: The callee may read data from memory, but it cannot write data to
      memory. This has the same effect as the GNU C/C++ attribute
      `__attribute__((pure))`.
    - const: The callee may not read or write data from memory. This has the
      same effect as the GNU C/C++ attribute `__attribute__((const))`.

    Examples:

    ```mlir
    %0 = cir.const #cir.int<0> : !s32i
    %1 = cir.const #cir.int<1> : !s32i
    %2 = cir.call @add(%0, %1) : (!s32i, !s32i) -> !s32i side_effect(all)
    %2 = cir.call @add(%0, %1) : (!s32i, !s32i) -> !s32i side_effect(pure)
    %2 = cir.call @add(%0, %1) : (!s32i, !s32i) -> !s32i side_effect(const)
    ```
  }];
}

class CIR_CallOp<string mnemonic, list<Trait> extra_traits = []>
    : CIR_Op<mnemonic, !listconcat(extra_traits, [
        DeclareOpInterfaceMethods<CIRCallOpInterface>,
        DeclareOpInterfaceMethods<SymbolUserOpInterface>
      ])>
{
  let extraClassDeclaration = [{
    /// Get the argument operands to the called function.
    mlir::OperandRange getArgOperands() {
      return {arg_operand_begin(), arg_operand_end()};
    }

    mlir::MutableOperandRange getArgOperandsMutable() {
      llvm_unreachable("NYI");
    }

    /// Return the callee of this operation
    mlir::CallInterfaceCallable getCallableForCallee() {
      return (*this)->getAttrOfType<mlir::SymbolRefAttr>("callee");
    }

    /// Set the callee for this operation.
    void setCalleeFromCallable(::mlir::CallInterfaceCallable callee) {
      if (auto calling =
              (*this)->getAttrOfType<mlir::SymbolRefAttr>(getCalleeAttrName()))
        (*this)->setAttr(getCalleeAttrName(), mlir::cast<mlir::SymbolRefAttr>(callee));
      setOperand(0, mlir::cast<mlir::Value>(callee));
    }

    ::mlir::ArrayAttr getArgAttrsAttr();
    ::mlir::ArrayAttr getResAttrsAttr();

    void setResAttrsAttr(::mlir::ArrayAttr attrs);
    void setArgAttrsAttr(::mlir::ArrayAttr attrs);

    ::mlir::Attribute removeArgAttrsAttr();
    ::mlir::Attribute removeResAttrsAttr();

    bool isIndirect() { return !getCallee(); }
    mlir::Value getIndirectCall();

    void setArg(unsigned index, mlir::Value value) {
      if (!isIndirect()) {
        setOperand(index, value);
        return;
      }

      // For indirect call, the operand list is shifted by one.
      setOperand(index + 1, value);
    }
  }];

  let hasCustomAssemblyFormat = 1;
  let skipDefaultBuilders = 1;

  dag commonArgs = (ins
    OptionalAttr<FlatSymbolRefAttr>:$callee,
    Variadic<CIR_AnyType>:$arg_ops,
    DefaultValuedAttr<CIR_CallingConv, "CallingConv::C">:$calling_conv,
    DefaultValuedAttr<CIR_SideEffect, "SideEffect::All">:$side_effect,
    CIR_ExtraFuncAttr:$extra_attrs,
    OptionalAttr<ASTCallExprInterface>:$ast
  );
}

def CIR_CallOp : CIR_CallOp<"call", [NoRegionArguments]> {
  let summary = "call operation";
  let description = [{
    Direct and indirect calls.

    For direct calls, the `call` operation represents a direct call to a
    function that is within the same symbol scope as the call. The operands
    and result types of the call must match the specified function type.
    The callee is encoded as a aymbol reference attribute named "callee".

    For indirect calls, the first `mlir::Operation` operand is the call target.

    Given the way indirect calls are encoded, avoid using `mlir::Operation`
    methods to walk the operands for this operation, instead use the methods
    provided by `CIRCallOpInterface`.

    If the `cir.call` has the `exception` keyword, the call can throw. In this
    case, cleanups can be added in the `cleanup` region.

    Example:

    ```mlir
    // Direct call
    %2 = cir.call @my_add(%0, %1) : (f32, f32) -> f32
     ...
    // Indirect call
    %20 = cir.call %18(%17)
     ...
    // Call that might throw
    cir.call exception @my_div() -> () cleanup {
      // call dtor...
    }
    ```
  }];

  let results = (outs Optional<CIR_AnyType>:$result);
  let arguments = !con((ins
    UnitAttr:$exception
  ), commonArgs);
  let regions = (region AnyRegion:$cleanup);

  let skipDefaultBuilders = 1;

  let builders = [
    OpBuilder<(ins "mlir::SymbolRefAttr":$callee, "mlir::Type":$resType,
              CArg<"mlir::ValueRange", "{}">:$operands,
              CArg<"CallingConv", "CallingConv::C">:$callingConv,
              CArg<"SideEffect", "SideEffect::All">:$sideEffect,
              CArg<"mlir::UnitAttr", "{}">:$exception), [{
      $_state.addOperands(operands);
      if (callee)
        $_state.addAttribute("callee", callee);
      $_state.addAttribute("calling_conv",
        CallingConvAttr::get($_builder.getContext(), callingConv));
      $_state.addAttribute("side_effect",
        SideEffectAttr::get($_builder.getContext(), sideEffect));
      if (exception)
        $_state.addAttribute("exception", exception);
      if (resType && !isa<VoidType>(resType))
        $_state.addTypes(resType);
      // Create region placeholder for potential cleanups.
      $_state.addRegion();
    }]>,
    OpBuilder<(ins "mlir::Value":$ind_target,
               "FuncType":$fn_type,
               CArg<"mlir::ValueRange", "{}">:$operands,
               CArg<"CallingConv", "CallingConv::C">:$callingConv,
               CArg<"SideEffect", "SideEffect::All">:$sideEffect,
               CArg<"mlir::UnitAttr", "{}">:$exception), [{
      $_state.addOperands(ValueRange{ind_target});
      $_state.addOperands(operands);
      if (!fn_type.hasVoidReturn())
        $_state.addTypes(fn_type.getReturnType());
      $_state.addAttribute("calling_conv",
        CallingConvAttr::get($_builder.getContext(), callingConv));
      $_state.addAttribute("side_effect",
        SideEffectAttr::get($_builder.getContext(), sideEffect));
      if (exception)
        $_state.addAttribute("exception", exception);
      // Create region placeholder for potential cleanups.
      $_state.addRegion();
    }]>
  ];
}

def CIR_TryCallOp : CIR_CallOp<"try_call",[
  DeclareOpInterfaceMethods<BranchOpInterface>,
  Terminator, AttrSizedOperandSegments
]> {
  let summary = "try_call operation";
  let description = [{
    Mostly similar to cir.call but requires two destination
    branches, one for handling exceptions in case its thrown and
    the other one to follow on regular control-flow.

    Example:

    ```mlir
    // Direct call
    %2 = cir.try_call @my_add(%0, %1) ^continue, ^landing_pad : (f32, f32) -> f32
    ```
  }];

  let arguments = !con((ins
    Variadic<CIR_AnyType>:$contOperands,
    Variadic<CIR_AnyType>:$landingPadOperands
  ), commonArgs);

  let results = (outs Optional<CIR_AnyType>:$result);
  let successors = (successor AnySuccessor:$cont,
                              AnySuccessor:$landing_pad);

  let skipDefaultBuilders = 1;

  let builders = [
    OpBuilder<(ins "mlir::SymbolRefAttr":$callee, "mlir::Type":$resType,
               "mlir::Block *":$cont, "mlir::Block *":$landing_pad,
               CArg<"mlir::ValueRange", "{}">:$operands,
               CArg<"mlir::ValueRange", "{}">:$contOperands,
               CArg<"mlir::ValueRange", "{}">:$landingPadOperands,
               CArg<"CallingConv", "CallingConv::C">:$callingConv,
               CArg<"SideEffect", "SideEffect::All">:$sideEffect), [{
      $_state.addOperands(operands);
      if (callee)
        $_state.addAttribute("callee", callee);
      if (resType && !isa<VoidType>(resType))
        $_state.addTypes(resType);

      $_state.addAttribute("calling_conv",
        CallingConvAttr::get($_builder.getContext(), callingConv));
      $_state.addAttribute("side_effect",
        SideEffectAttr::get($_builder.getContext(), sideEffect));

      // Handle branches
      $_state.addOperands(contOperands);
      $_state.addOperands(landingPadOperands);
      // The TryCall ODS layout is: cont, landing_pad, operands.
      llvm::copy(::llvm::ArrayRef<int32_t>({
        static_cast<int32_t>(contOperands.size()),
        static_cast<int32_t>(landingPadOperands.size()),
        static_cast<int32_t>(operands.size())
        }),
        odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
      $_state.addSuccessors(cont);
      $_state.addSuccessors(landing_pad);
    }]>,
    OpBuilder<(ins "mlir::Value":$ind_target,
               "FuncType":$fn_type,
               "mlir::Block *":$cont, "mlir::Block *":$landing_pad,
               CArg<"mlir::ValueRange", "{}">:$operands,
               CArg<"mlir::ValueRange", "{}">:$contOperands,
               CArg<"mlir::ValueRange", "{}">:$landingPadOperands,
               CArg<"CallingConv", "CallingConv::C">:$callingConv,
               CArg<"SideEffect", "SideEffect::All">:$sideEffect), [{
      ::llvm::SmallVector<mlir::Value, 4> finalCallOperands({ind_target});
      finalCallOperands.append(operands.begin(), operands.end());
      $_state.addOperands(finalCallOperands);

      if (!fn_type.hasVoidReturn())
        $_state.addTypes(fn_type.getReturnType());

      $_state.addAttribute("calling_conv",
        CallingConvAttr::get($_builder.getContext(), callingConv));
      $_state.addAttribute("side_effect",
        SideEffectAttr::get($_builder.getContext(), sideEffect));

      // Handle branches
      $_state.addOperands(contOperands);
      $_state.addOperands(landingPadOperands);
      // The TryCall ODS layout is: cont, landing_pad, operands.
      llvm::copy(::llvm::ArrayRef<int32_t>({
        static_cast<int32_t>(contOperands.size()),
        static_cast<int32_t>(landingPadOperands.size()),
        static_cast<int32_t>(finalCallOperands.size())
        }),
        odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
      $_state.addSuccessors(cont);
      $_state.addSuccessors(landing_pad);
    }]>
  ];
}

//===----------------------------------------------------------------------===//
// AwaitOp
//===----------------------------------------------------------------------===//

def CIR_AwaitKind : CIR_I32EnumAttr<"AwaitKind", "await kind", [
  I32EnumAttrCase<"Init", 0, "init">,
  I32EnumAttrCase<"User", 1, "user">,
  I32EnumAttrCase<"Yield", 2, "yield">,
  I32EnumAttrCase<"Final", 3, "final">
]>;

def CIR_AwaitOp : CIR_Op<"await",[
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  RecursivelySpeculatable, NoRegionArguments
]> {
  let summary = "Wraps C++ co_await implicit logic";
  let description = [{
    The under the hood effect of using C++ `co_await expr` roughly
    translates to:

    ```c++
    // co_await expr;

    auto &&x = CommonExpr();
    if (!x.await_ready()) {
       ...
       x.await_suspend(...);
       ...
    }
    x.await_resume();
    ```

    `cir.await` represents this logic by using 3 regions:
      - ready: covers veto power from x.await_ready()
      - suspend: wraps actual x.await_suspend() logic
      - resume: handles x.await_resume()

    Breaking this up in regions allow individual scrutiny of conditions
    which might lead to folding some of them out. Lowerings coming out
    of CIR, e.g. LLVM, should use the `suspend` region to track more
    lower level codegen (e.g. intrinsic emission for coro.save/coro.suspend).

    There are also 4 flavors of `cir.await` available:
    - `init`: compiler generated initial suspend via implicit `co_await`.
    - `user`: also known as normal, representing user written co_await's.
    - `yield`: user written `co_yield` expressions.
    - `final`: compiler generated final suspend via implicit `co_await`.

    From the C++ snippet we get:

    ```mlir
      cir.scope {
        ... // auto &&x = CommonExpr();
        cir.await(user, ready : {
          ... // x.await_ready()
        }, suspend : {
          ... // x.await_suspend()
        }, resume : {
          ... // x.await_resume()
        })
      }
    ```

    Note that resulution of the common expression is assumed to happen
    as part of the enclosing await scope.
  }];

  let arguments = (ins CIR_AwaitKind:$kind);
  let regions = (region SizedRegion<1>:$ready,
                        SizedRegion<1>:$suspend,
                        SizedRegion<1>:$resume);
  let assemblyFormat = [{
    `(` $kind `,`
    `ready` `:` $ready `,`
    `suspend` `:` $suspend `,`
    `resume` `:` $resume `,`
    `)`
    attr-dict
  }];

  let skipDefaultBuilders = 1;
  let builders = [
    OpBuilder<(ins
      "cir::AwaitKind":$kind,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "nullptr">:$readyBuilder,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "nullptr">:$suspendBuilder,
      CArg<"llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>",
           "nullptr">:$resumeBuilder
      )>
  ];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// TryOp
//===----------------------------------------------------------------------===//

// Represents the unwind region where unwind continues or
// the program std::terminate's.
def CIR_CatchUnwind : CIR_UnitAttr<"CatchUnwind", "unwind"> {
  let storageType = [{ CatchUnwind }];
}

// Represents the catch_all region.
def CIR_CatchAll : CIR_UnitAttr<"CatchAll", "all"> {
  let storageType = [{ CatchAllAttr }];
}

def CIR_TryOp : CIR_Op<"try",[
  DeclareOpInterfaceMethods<RegionBranchOpInterface>,
  RecursivelySpeculatable, AutomaticAllocationScope, NoRegionArguments
]> {
  let summary = "C++ try block";
  let description = [{
    ```mlir

    Holds the lexical scope of `try {}`. Note that resources used on catch
    clauses are usually allocated in the same parent as `cir.try`.

    `synthetic`: use `cir.try` to represent try/catches not originally
    present in the source code (e.g. `g = new Class` under `-fexceptions`).

    `cleanup`: signal to targets (LLVM for now) that this try/catch, needs
    to specially tag their landing pads as needing "cleanup".

    Example: TBD
    ```
  }];

  let arguments = (ins UnitAttr:$synthetic, UnitAttr:$cleanup,
                       OptionalAttr<ArrayAttr>:$catch_types);
  let regions = (region AnyRegion:$try_region,
                        VariadicRegion<AnyRegion>:$catch_regions);

  let assemblyFormat = [{
    (`synthetic` $synthetic^)?
    (`cleanup` $cleanup^)?
    $try_region
    custom<CatchRegions>($catch_regions, $catch_types)
    attr-dict
  }];

  let extraClassDeclaration = [{
  private:
    mlir::Region *getCatchLastRegion();
  public:
    mlir::Block *getCatchAllEntryBlock();
    mlir::Block *getCatchUnwindEntryBlock();
    bool isCatchAllOnly();
  }];

  // Everything already covered elsewhere.
  let builders = [
    OpBuilder<(ins
              "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$tryBuilder,
              "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location, mlir::OperationState &)>"
              :$catchBuilder)>,
  ];
}

//===----------------------------------------------------------------------===//
// CatchParamOp
//===----------------------------------------------------------------------===//

def CIR_CatchParamKind  : CIR_I32EnumAttr<
  "CatchParamKind", "Designate limits for begin/end of catch param handling", [
    I32EnumAttrCase<"Begin", 0, "begin">,
    I32EnumAttrCase<"End",  1, "end">
]>;

def CIR_CatchParamOp : CIR_Op<"catch_param"> {
  let summary = "Represents catch clause formal parameter";
  let description = [{
    The `cir.catch_param` can operate in two modes: within catch regions of
    `cir.try` or anywhere else with the `begin` or `end` markers. The `begin`
    version requires an exception pointer of `cir.ptr<!void>`.

    Example:
    ```mlir
    // TBD
    ```
  }];

  let arguments = (ins
    Optional<CIR_VoidPtrType>:$exception_ptr,
    OptionalAttr<CIR_CatchParamKind>:$kind
  );

  let results = (outs Optional<CIR_AnyType>:$param);
  let assemblyFormat = [{
    ($kind^)?
    ($exception_ptr^)?
    (`->` qualified(type($param))^)?
    attr-dict
  }];

  let extraClassDeclaration = [{
    bool isBegin() { return getKind() == cir::CatchParamKind::Begin; }
    bool isEnd() { return getKind() == cir::CatchParamKind::End; }
  }];

  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// Exception related: EhInflightOp, EhTypeIdOp
//===----------------------------------------------------------------------===//

def CIR_EhInflightOp : CIR_Op<"eh.inflight_exception"> {
  let summary = "Materialize the catch clause formal parameter";
  let description = [{
    `cir.eh.inflight_exception` returns two values:
      - `exception_ptr`: The exception pointer for the inflight exception
      - `type_id`: pointer to the exception object
    This operation is expected to be the first one basic blocks on the
    exception path out of `cir.try_call` operations.

    The `cleanup` attribute indicates that clean up code might run before the
    values produced by this operation are used to gather exception information.
    This helps CIR to pass down more accurate information for LLVM lowering
    to landingpads.
  }];

  let arguments = (ins UnitAttr:$cleanup,
                       OptionalAttr<FlatSymbolRefArrayAttr>:$sym_type_list);
  let results = (outs CIR_VoidPtrType:$exception_ptr, CIR_UInt32:$type_id);
  let assemblyFormat = [{
    (`cleanup` $cleanup^)?
    ($sym_type_list^)?
    attr-dict
  }];
}

def CIR_EhTypeIdOp : CIR_Op<"eh.typeid",
  [Pure, DeclareOpInterfaceMethods<SymbolUserOpInterface>]> {
  let summary = "Compute exception type id from it's global type symbol";
  let description = [{
    Returns the exception type id for a given global symbol representing
    a type.
  }];

  let arguments = (ins FlatSymbolRefAttr:$type_sym);
  let results = (outs CIR_UInt32:$type_id);
  let assemblyFormat = [{
    $type_sym attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// CopyOp
//===----------------------------------------------------------------------===//

def CIR_CopyOp : CIR_Op<"copy",[
  SameTypeOperands,
  DeclareOpInterfaceMethods<PromotableMemOpInterface>
]> {
  let arguments = (ins Arg<CIR_PointerType, "", [MemWrite]>:$dst,
                       Arg<CIR_PointerType, "", [MemRead]>:$src,
                       UnitAttr:$is_volatile,
                       OptionalAttr<CIR_TBAAAttr>:$tbaa);
  let summary = "Copies contents from a CIR pointer to another";
  let description = [{
    Given two CIR pointers, `src` and `dst`, `cir.copy` will copy the memory
    pointed by `src` to the memory pointed by `dst`.

    The amount of bytes copied is inferred from the pointee type. Naturally,
    the pointee type of both `src` and `dst` must match and must implement
    the `DataLayoutTypeInterface`.

    Examples:

    ```mlir
      // Copying contents from one record to another:
      cir.copy %0 to %1 : !cir.ptr<!record_ty>
    ```
  }];

  let assemblyFormat = [{$src `to` $dst (`volatile` $is_volatile^)?
                        attr-dict `:` qualified(type($dst))
                        (`tbaa` `(` $tbaa^ `)`)?
  }];
  let hasVerifier = 1;

  let extraClassDeclaration = [{
    /// Returns the pointer type being copied.
    cir::PointerType getType() { return getSrc().getType(); }

    /// Returns the number of bytes to be copied.
    unsigned getLength() {
      return mlir::DataLayout::closest(*this).getTypeSize(getType().getPointee());
    }
  }];
}

//===----------------------------------------------------------------------===//
// MemCpyOp && MemMoveOp
//===----------------------------------------------------------------------===//

class CIR_MemOp<string mnemonic> : CIR_Op<mnemonic, [
  AllTypesMatch<["dst", "src"]>
]> {
  dag commonArgs = (ins
    Arg<CIR_VoidPtrType, "", [MemWrite]>:$dst,
    Arg<CIR_VoidPtrType, "", [MemRead]>:$src
  );
}

def CIR_MemCpyOp : CIR_MemOp<"libc.memcpy"> {
  let summary = "Equivalent to libc's `memcpy`";
  let description = [{
    Given two CIR pointers, `src` and `dst`, `cir.libc.memcpy` will copy `len`
    bytes from the memory pointed by `src` to the memory pointed by `dst`.

    While `cir.copy` is meant to be used for implicit copies in the code where
    the length of the copy is known, `cir.memcpy` copies only from and to void
    pointers, requiring the copy length to be passed as an argument.

    Examples:

    ```mlir
      // Copying 2 bytes from one array to a record:
      %2 = cir.const #cir.int<2> : !u32i
      cir.libc.memcpy %2 bytes from %arr to %record : !cir.ptr<!arr> -> !cir.ptr<!record>
    ```
  }];

  let arguments = !con(commonArgs, (ins CIR_AnyFundamentalUIntType:$len));

  let assemblyFormat = [{
    $len `bytes` `from` $src `to` $dst attr-dict
    `:` type($len) `` `,` qualified(type($src)) `->` qualified(type($dst))
  }];

  let extraClassDeclaration = [{
    /// Returns the byte length type.
    cir::IntType getLenTy() { return getLen().getType(); }
  }];
}

def CIR_MemMoveOp : CIR_MemOp<"libc.memmove"> {
  let summary = "Equivalent to libc's `memmove`";
  let description = [{
    Given two CIR pointers, `src` and `dst`, `cir.libc.memmove` will copy `len`
    bytes from the memory pointed by `src` to the memory pointed by `dst`.

    similiar to `cir.libc.memcpy` but accounts for overlapping memory.

    Examples:

    ```mlir
      // Copying 2 bytes from one array to a record:
      %2 = cir.const #cir.int<2> : !u32i
      cir.libc.memmove %2 bytes from %arr to %record : !cir.ptr<!void>, !u64i
    ```
  }];

  let arguments = !con(commonArgs, (ins CIR_AnyFundamentalUIntType:$len));

  let assemblyFormat = [{
    $len `bytes` `from` $src `to` $dst attr-dict
    `:` qualified(type($dst)) `,` type($len)
  }];

  let extraClassDeclaration = [{
    /// Returns the byte length type.
    cir::IntType getLenTy() { return getLen().getType(); }
  }];
}

//===----------------------------------------------------------------------===//
// MemCpyInlineOp
//===----------------------------------------------------------------------===//

def CIR_MemCpyInlineOp : CIR_MemOp<"memcpy_inline"> {
  let summary = "Memory copy with constant length without calling"
                "any external function";
  let description = [{
    Given two CIR pointers, `src` and `dst`, `memcpy_inline` will copy `len`
    bytes from the memory pointed by `src` to the memory pointed by `dst`.

    Unlike `cir.libc.memcpy`,  this Op guarantees that no external functions
    are called, and length of copied bytes is a constant.

    Examples:

    ```mlir
      // Copying 2 bytes from one array to a record:
      cir.memcpy_inline 2 bytes from %arr to %record : !cir.ptr<!arr> -> !cir.ptr<!record>
    ```
  }];

  let arguments = !con(commonArgs, (ins I64Attr:$len));

  let assemblyFormat = [{
    $len `bytes` `from` $src `to` $dst attr-dict
    `:` qualified(type($src)) `->` qualified(type($dst))
  }];
}

//===----------------------------------------------------------------------===//
// MemSetOp
//===----------------------------------------------------------------------===//

def CIR_MemSetOp : CIR_Op<"libc.memset"> {
  let summary = "Equivalent to libc's `memset`";
  let description = [{
    Given the CIR pointer, `dst`, `cir.libc.memset` will set the first `len`
    bytes of the memory pointed by `dst` to the specified `val`.

    Examples:

    ```mlir
      // Set 2 bytes from a record to 0:
      %2 = cir.const #cir.int<2> : !u32i
      %3 = cir.const #cir.int<0> : !u32i
      %zero = cir.cast(integral, %3 : !s32i), !u8i
      cir.libc.memset %2 bytes from %record set to %zero : !cir.ptr<!void>, !s32i, !u64i
    ```
  }];

  let arguments = (ins
    Arg<CIR_VoidPtrType, "", [MemWrite]>:$dst,
    CIR_SInt32:$val,
    CIR_AnyFundamentalUIntType:$len
  );

  let assemblyFormat = [{
    $len `bytes` `from` $dst `set` `to` $val attr-dict
    `:` qualified(type($dst)) `,` type($val) `,` type($len)
  }];
}

//===----------------------------------------------------------------------===//
// MemSetInlineOp
//===----------------------------------------------------------------------===//

def CIR_MemSetInlineOp : CIR_Op<"memset_inline"> {
  let summary = "Fill a block of memory with constant length without calling"
                "any external function";
  let description = [{
    Given the CIR pointer, `dst`, `cir.memset_inline` will set the first `len`
    bytes of the memory pointed by `dst` to the specified `val`.

    The `len` argument must be a constant integer argument specifying the number
    of bytes to fill.

    Examples:

    ```mlir
      // Set 2 bytes from a record to 0
      cir.memset_inline 2 bytes from %record set to %zero : !cir.ptr<!void>, !s32i
    ```
  }];

  let arguments = (ins
    Arg<CIR_VoidPtrType, "", [MemWrite]>:$dst,
    CIR_SInt32:$val,
    I64Attr:$len
  );

  let assemblyFormat = [{
    $len `bytes` `from` $dst `set` `to` $val attr-dict
    `:` qualified(type($dst)) `,` type($val)
  }];
}

//===----------------------------------------------------------------------===//
// MemChrOp
//===----------------------------------------------------------------------===//

def CIR_MemChrOp : CIR_Op<"libc.memchr"> {
  let summary = "libc's `memchr`";
  let description = [{
    Search for `pattern` in data range from `src` to `src` + `len`.
    provides a bound to the search in `src`. `result` is a pointer to found
    `pattern` or a null pointer.

    Examples:

    ```mlir
    %p = cir.libc.memchr(%src, %pattern, %len) -> !cir.ptr<!void>
    ```
  }];

  // TODO: instead of using UInt64 for len, we could make it constrained on
  // size_t (64 or 32) and have a builder that does the right job.
  let arguments = (ins
    Arg<CIR_VoidPtrType, "", [MemRead]>:$src,
    CIR_SInt32:$pattern,
    CIR_UInt64:$len
  );

  let results = (outs CIR_VoidPtrType:$result);

  let assemblyFormat = [{
    `(`
      $src `,` $pattern `,` $len `)` attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// ReturnAddrOp and FrameAddrOp
//===----------------------------------------------------------------------===//

class CIR_FuncAddrBuiltinOp<string mnemonic> : CIR_Op<mnemonic, []> {
  let arguments = (ins CIR_UInt32:$level);
  let results = (outs CIR_VoidPtrType:$result);
  let assemblyFormat = [{
    `(` $level `)` attr-dict
  }];
}

def CIR_ReturnAddrOp : CIR_FuncAddrBuiltinOp<"return_address"> {
  let summary =
      "The return address of the current function, or of one of its callers";

  let description = [{
    Represents call to builtin function ` __builtin_return_address` in CIR.
    This builtin function returns the return address of the current function,
    or of one of its callers.
    The `level` argument is number of frames to scan up the call stack.
    For instance, value of 0 yields the return address of the current function,
    value of 1 yields the return address of the caller of the current function,
    and so forth.

    Examples:

    ```mlir
    %p = return_address(%level) -> !cir.ptr<!void>
    ```
  }];
}

def CIR_FrameAddrOp : CIR_FuncAddrBuiltinOp<"frame_address"> {
  let summary =
      "The frame address of the current function, or of one of its callers";

  let description = [{
    Represents call to builtin function ` __builtin_frame_address` in CIR.
    This builtin function returns the frame address of the current function,
    or of one of its callers. The frame is the area on the stack that holds
    local variables and saved registers. The frame address is normally the
    address of the first word pushed on to the stack by the function.
    However, the exact definition depends upon the processor and the calling
    convention. If the processor has a dedicated frame pointer register, and
    the function has a frame, then __builtin_frame_address returns the value of
    the frame pointer register.

    The `level` argument is number of frames to scan up the call stack.
    For instance, value of 0 yields the frame address of the current function,
    value of 1 yields the frame address of the caller of the current function,
    and so forth.

    Examples:

    ```mlir
    %p = frame_address(%level) -> !cir.ptr<!void>
    ```
  }];
}

//===----------------------------------------------------------------------===//
// Floating Point Ops
//===----------------------------------------------------------------------===//

class CIR_UnaryFPToIntBuiltinOp<string mnemonic, string llvmOpName>
    : CIR_Op<mnemonic, [Pure]>
{
  let arguments = (ins CIR_AnyFloatType:$src);
  let results = (outs CIR_IntType:$result);

  let summary = [{
    Builtin function that takes a floating-point value as input and produces an
    integral value as output.
  }];

  let assemblyFormat = [{
    $src `:` type($src) `->` type($result) attr-dict
  }];

  let llvmOp = llvmOpName;
}

def CIR_LroundOp : CIR_UnaryFPToIntBuiltinOp<"lround", "LroundOp">;
def CIR_LLroundOp : CIR_UnaryFPToIntBuiltinOp<"llround", "LlroundOp">;
def CIR_LrintOp : CIR_UnaryFPToIntBuiltinOp<"lrint", "LrintOp">;
def CIR_LLrintOp : CIR_UnaryFPToIntBuiltinOp<"llrint", "LlrintOp">;

class CIR_UnaryFPToFPBuiltinOp<string mnemonic, string llvmOpName>
    : CIR_Op<mnemonic, [Pure, SameOperandsAndResultType]>
{
  let arguments = (ins CIR_AnyFloatOrVecOfFloatType:$src);
  let results = (outs CIR_AnyFloatOrVecOfFloatType:$result);
  let summary = "libc builtin equivalent ignoring "
                "floating point exceptions and errno";
  let assemblyFormat = "$src `:` type($src) attr-dict";

  let llvmOp = llvmOpName;
}

def CIR_ACosOp : CIR_UnaryFPToFPBuiltinOp<"acos", "ACosOp">;
def CIR_ASinOp : CIR_UnaryFPToFPBuiltinOp<"asin", "ASinOp">;
def CIR_ATanOp : CIR_UnaryFPToFPBuiltinOp<"atan", "ATanOp">;
def CIR_CeilOp : CIR_UnaryFPToFPBuiltinOp<"ceil", "FCeilOp">;
def CIR_CosOp : CIR_UnaryFPToFPBuiltinOp<"cos", "CosOp">;
def CIR_ExpOp : CIR_UnaryFPToFPBuiltinOp<"exp", "ExpOp">;
def CIR_Exp2Op : CIR_UnaryFPToFPBuiltinOp<"exp2", "Exp2Op">;
def CIR_FloorOp : CIR_UnaryFPToFPBuiltinOp<"floor", "FFloorOp">;
def CIR_FAbsOp : CIR_UnaryFPToFPBuiltinOp<"fabs", "FAbsOp">;
def CIR_LogOp : CIR_UnaryFPToFPBuiltinOp<"log", "LogOp">;
def CIR_Log10Op : CIR_UnaryFPToFPBuiltinOp<"log10", "Log10Op">;
def CIR_Log2Op : CIR_UnaryFPToFPBuiltinOp<"log2", "Log2Op">;
def CIR_NearbyintOp : CIR_UnaryFPToFPBuiltinOp<"nearbyint", "NearbyintOp">;
def CIR_RintOp : CIR_UnaryFPToFPBuiltinOp<"rint", "RintOp">;
def CIR_RoundOp : CIR_UnaryFPToFPBuiltinOp<"round", "RoundOp">;
def CIR_RoundEvenOp : CIR_UnaryFPToFPBuiltinOp<"roundeven", "RoundEvenOp">;
def CIR_SinOp : CIR_UnaryFPToFPBuiltinOp<"sin", "SinOp">;
def CIR_SqrtOp : CIR_UnaryFPToFPBuiltinOp<"sqrt", "SqrtOp">;
def CIR_TanOp : CIR_UnaryFPToFPBuiltinOp<"tan", "TanOp">;
def CIR_TruncOp : CIR_UnaryFPToFPBuiltinOp<"trunc", "FTruncOp">;

def CIR_AbsOp : CIR_Op<"abs", [Pure, SameOperandsAndResultType]> {
  let summary = [{
    libc builtin equivalent abs, labs, llabs

    The `poison` argument indicate whether the result value
    is a poison value if the first argument is statically or
    dynamically an INT_MIN value.

    Example:

    ```mlir
      %0 = cir.const #cir.int<-42> : s32i
      %1 = cir.abs %0 poison : s32i
      %2 = cir.abs %3 : !cir.vector<!s32i x 4>
    ```
  }];

  let arguments = (ins
    CIR_AnySIntOrVecOfSIntType:$src,
    UnitAttr:$poison
  );

  let results = (outs CIR_AnySIntOrVecOfSIntType:$result);

  let assemblyFormat = "$src ( `poison` $poison^ )? `:` type($src) attr-dict";
}

class CIR_BinaryFPToFPBuiltinOp<string mnemonic, string llvmOpName>
    : CIR_Op<mnemonic, [Pure, SameOperandsAndResultType]> {
  let summary = [{
    libc builtin equivalent ignoring floating-point exceptions and errno.
  }];

  let arguments = (ins
    CIR_AnyFloatOrVecOfFloatType:$lhs,
    CIR_AnyFloatOrVecOfFloatType:$rhs
  );

  let results = (outs  CIR_AnyFloatOrVecOfFloatType:$result);

  let assemblyFormat = [{
    $lhs `,` $rhs `:` qualified(type($lhs)) attr-dict
  }];

  let llvmOp = llvmOpName;
}

def CIR_CopysignOp : CIR_BinaryFPToFPBuiltinOp<"copysign", "CopySignOp">;
def CIR_FMaxNumOp : CIR_BinaryFPToFPBuiltinOp<"fmaxnum", "MaxNumOp">;
def CIR_FMinNumOp : CIR_BinaryFPToFPBuiltinOp<"fminnum", "MinNumOp">;
def CIR_FMaximumOp : CIR_BinaryFPToFPBuiltinOp<"fmaximum", "MaximumOp">;
def CIR_FMinimumOp : CIR_BinaryFPToFPBuiltinOp<"fminimum", "MinimumOp">;
def CIR_FModOp : CIR_BinaryFPToFPBuiltinOp<"fmod", "FRemOp">;
def CIR_PowOp : CIR_BinaryFPToFPBuiltinOp<"pow", "PowOp">;
def CIR_ATan2Op : CIR_BinaryFPToFPBuiltinOp<"atan2", "ATan2Op">;

def CIR_IsFPClassOp : CIR_Op<"is_fp_class"> {
  let summary = "Corresponding to the `__builtin_fpclassify` builtin function in clang";

  let description = [{
    The `cir.is_fp_class` operation takes a floating-point value as its first
    argument and a bitfield of flags as its second argument. The operation
    returns a boolean value indicating whether the floating-point value
    satisfies the given flags.

    The flags must be a compile time constant and the values are:

    | Bit # | floating-point class |
    | -------- | ------- |
    | 0 | Signaling NaN      |
    | 1 | Quiet NaN          |
    | 2 | Negative infinity  |
    | 3 | Negative normal    |
    | 4 | Negative subnormal |
    | 5 | Negative zero      |
    | 6 | Positive zero      |
    | 7 | Positive subnormal |
    | 8 | Positive normal    |
    | 9 | Positive infinity  |
  }];

  let arguments = (ins CIR_AnyFloatType:$src,
                       I32Attr:$flags);
  let results = (outs CIR_BoolType:$result);
  let assemblyFormat = [{
    $src `,` $flags `:` functional-type($src, $result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// Assume Operations
//===----------------------------------------------------------------------===//

def CIR_AssumeOp : CIR_Op<"assume"> {
  let summary = "Tell the optimizer that a boolean value is true";
  let description = [{
    The `cir.assume` operation takes a single boolean prediate as its only
    argument and does not have any results. The operation tells the optimizer
    that the predicate's value is true.

    This operation corresponds to the `__assume` and the `__builtin_assume`
    builtin function.
  }];

  let arguments = (ins CIR_BoolType:$predicate);

  let assemblyFormat = [{
    $predicate `:` type($predicate) attr-dict
  }];
}

def CIR_AssumeAlignedOp
    : CIR_Op<"assume.aligned", [Pure, AllTypesMatch<["pointer", "result"]>]> {
  let summary = "Tell the optimizer that a pointer is aligned";
  let description = [{
    The `cir.assume.aligned` operation takes two or three arguments.

    When the 3rd argument `offset` is absent, this operation tells the optimizer
    that the pointer given by the `pointer` argument is aligned to the alignment
    given by the `align` argument.

    When the `offset` argument is given, it represents an offset from the
    alignment. This operation then tells the optimizer that the pointer given by
    the `pointer` argument is always misaligned by the alignment given by the
    `align` argument by `offset` bytes, a.k.a. the pointer yielded by
    `(char *)pointer - offset` is aligned to the specified alignment.

    The `align` argument is a constant integer represented as an integer
    attribute instead of an SSA value. It must be a positive integer.

    The result of this operation has the same value as the `pointer` argument,
    but the optimizer has additional knowledge about its alignment.

    This operation corresponds to the `__builtin_assume_aligned` builtin
    function.
  }];

  let arguments = (ins CIR_PointerType:$pointer,
                       I64Attr:$alignment,
                       Optional<CIR_IntType>:$offset);
  let results = (outs CIR_PointerType:$result);

  let assemblyFormat = [{
    $pointer `:` qualified(type($pointer))
    `[` `alignment` $alignment (`,` `offset` $offset^ `:` type($offset))? `]`
    attr-dict
  }];
}

def CIR_AssumeSepStorageOp : CIR_Op<"assume.separate_storage", [
  SameTypeOperands
]> {
  let summary =
      "Tell the optimizer that two pointers point to different allocations";
  let description = [{
    The `cir.assume.separate_storage` operation takes two pointers as arguments,
    and the operation tells the optimizer that these two pointers point to
    different allocations.

    This operation corresponds to the `__builtin_assume_separate_storage`
    builtin function.
  }];

  let arguments = (ins CIR_VoidPtrType:$ptr1, CIR_VoidPtrType:$ptr2);

  let assemblyFormat = [{
    $ptr1 `,` $ptr2 `:` qualified(type($ptr1)) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// PtrMask Operations
//===----------------------------------------------------------------------===//

def CIR_PtrMaskOp : CIR_Op<"ptr_mask", [AllTypesMatch<["ptr", "result"]>]> {
  let summary = "Masks out bits of the pointer according to a mask";
  let description = [{
    The `cir.ptr_mask` operation takes a pointer and an interger `mask` as its
    argument and return the masked pointer type according to the `mask`.
  }];

  let arguments = (ins CIR_PointerType:$ptr,
                       CIR_IntType:$mask);
  let results = (outs CIR_PointerType:$result);

  let assemblyFormat = [{
    `(` $ptr `,` $mask `:` type($mask) `)` `:` qualified(type($result)) attr-dict
  }];

  let llvmOp = "PtrMaskOp";
}

//===----------------------------------------------------------------------===//
// Branch Probability Operations
//===----------------------------------------------------------------------===//

def CIR_ExpectOp : CIR_Op<"expect",[
  Pure, AllTypesMatch<["result", "val", "expected"]>
]> {
  let summary =
    "Compute whether expression is likely to evaluate to a specified value";
  let description = [{
    Provides __builtin_expect functionality in Clang IR.

    If $prob is not specified, then behaviour is same as __builtin_expect.
    If specified, then behaviour is same as __builtin_expect_with_probability,
    where probability = $prob.
  }];

  let arguments = (ins
    CIR_AnyFundamentalIntType:$val,
    CIR_AnyFundamentalIntType:$expected,
    OptionalAttr<F64Attr>:$prob
  );

  let results = (outs CIR_AnyFundamentalIntType:$result);

  let assemblyFormat = [{
    `(` $val`,` $expected (`,` $prob^)? `)` `:` type($val) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// Variadic Operations
//===----------------------------------------------------------------------===//

def CIR_VAStartOp : CIR_Op<"va.start"> {
  let summary = "Starts a variable argument list";

  let arguments = (ins CIR_PointerType:$arg_list);

  let assemblyFormat = [{
    $arg_list attr-dict `:` type(operands)
  }];
}

def CIR_VAEndOp : CIR_Op<"va.end"> {
  let summary = "Ends a variable argument list";

  let arguments = (ins CIR_PointerType:$arg_list);

  let assemblyFormat = [{
    $arg_list attr-dict `:` type(operands)
  }];
}

def CIR_VACopyOp : CIR_Op<"va.copy"> {
  let summary = "Copies a variable argument list";

  let arguments = (ins
    CIR_PointerType:$dst_list,
    CIR_PointerType:$src_list
  );

  let assemblyFormat = [{
    $src_list `to` $dst_list attr-dict `:` type(operands)
  }];
}

def CIR_VAArgOp : CIR_Op<"va.arg"> {
  let summary = "Fetches next variadic element as a given type";

  let arguments = (ins CIR_PointerType:$arg_list);
  let results = (outs CIR_AnyType:$result);

  let assemblyFormat = [{
    $arg_list attr-dict `:` functional-type(operands, $result)
  }];
}

//===----------------------------------------------------------------------===//
// AllocExceptionOp & FreeExceptionOp
//===----------------------------------------------------------------------===//

def CIR_AllocExceptionOp : CIR_Op<"alloc.exception"> {
  let summary = "Allocates an exception according to Itanium ABI";
  let description = [{
    Implements a slightly higher level __cxa_allocate_exception:

    `void *__cxa_allocate_exception(size_t thrown_size);`

    If operation fails, program terminates, not throw.

    Example:

    ```mlir
    // if (b == 0) {
    //   ...
    //   throw "...";
    cir.if %10 {
        %11 = cir.alloc_exception 8 -> !cir.ptr<!void>
        ... // store exception content into %11
        cir.throw %11 : !cir.ptr<!cir.ptr<!u8i>>, ...
    ```
  }];

  let arguments = (ins I64Attr:$size);
  let results = (outs Res<CIR_PointerType, "",
                      [MemAlloc<DefaultResource>]>:$addr);

  let assemblyFormat = [{
    $size `->` qualified(type($addr)) attr-dict
  }];
}

def CIR_FreeExceptionOp : CIR_Op<"free.exception"> {
  let summary = "Frees an exception according to Itanium ABI";
  let description = [{
    Implements a slightly higher level version of:
    `void __cxa_free_exception(void *thrown_exception);`

    Example:

    ```mlir
    %0 = cir.alloc.exception 16 -> !cir.ptr<!some_record>
    %1 = cir.get_global @d2 : !cir.ptr<!some_record>
    cir.try synthetic cleanup {
      cir.call exception @_ZN7test2_DC1ERKS_(%0, %1) : (!cir.ptr<!some_record>, !cir.ptr<!some_record>) -> () cleanup {
        %2 = cir.cast(bitcast, %0 : !cir.ptr<!some_record>), !cir.ptr<!void>
        cir.free.exception %2
        cir.yield
      }
      ...
    }
    ```
  }];

  let arguments = (ins CIR_VoidPtrType:$ptr);

  let assemblyFormat = [{
    $ptr attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// ThrowOp
//===----------------------------------------------------------------------===//

def CIR_ThrowOp : CIR_Op<"throw"> {
  let summary = "(Re)Throws an exception";
  let description = [{
    Very similar to __cxa_throw:

    ```
    void __cxa_throw(void *thrown_exception, std::type_info *tinfo,
                     void (*dest) (void *));
    ```

    The absense of arguments for `cir.throw` means it rethrows.

    For the no-rethrow version, it must have at least two operands, the RTTI
    information, a pointer to the exception object (likely allocated via
    `cir.cxa.allocate_exception`) and finally an optional dtor, which might
    run as part of this operation.

    ```mlir
      // if (b == 0)
      //   throw "Division by zero condition!";
      cir.if %10 {
        %11 = cir.alloc_exception 8 -> !cir.ptr<!void>
        ...
        cir.store %13, %11 : // Store string addr for "Division by zero condition!"
        cir.throw %11 : !cir.ptr<!cir.ptr<!u8i>>, @"typeinfo for char const*"
    ```
  }];

  let arguments = (ins Optional<CIR_PointerType>:$exception_ptr,
                       OptionalAttr<FlatSymbolRefAttr>:$type_info,
                       OptionalAttr<FlatSymbolRefAttr>:$dtor);

  let assemblyFormat = [{
    ($exception_ptr^ `:` type($exception_ptr))?
    (`,` $type_info^)?
    (`,` $dtor^)?
    attr-dict
  }];

  let extraClassDeclaration = [{
    bool rethrows() { return getNumOperands() == 0; }
  }];

  let hasVerifier = 1;
}

def CIR_StackSaveOp : CIR_Op<"stack_save"> {
  let summary = "remembers the current state of the function stack";
  let description = [{
    Remembers the current state of the function stack. Returns a pointer
    that later can be passed into cir.stack_restore.
    Useful for implementing language features like variable length arrays.

    ```mlir
    %0 = cir.stack_save : <!u8i>
    ```

  }];

  let results = (outs CIR_PointerType:$result);
  let assemblyFormat = "attr-dict `:` qualified(type($result))";
}

def CIR_StackRestoreOp : CIR_Op<"stack_restore"> {
  let summary = "restores the state of the function stack";
  let description = [{
    Restore the state of the function stack to the state it was
    in when the corresponding cir.stack_save executed.
    Useful for implementing language features like variable length arrays.

    ```mlir
    %0 = cir.alloca !cir.ptr<!u8i>, !cir.ptr<!cir.ptr<!u8i>>, ["saved_stack"] {alignment = 8 : i64}
    %1 = cir.stack_save : <!u8i>
    cir.store %1, %0 : !cir.ptr<!u8i>, !cir.ptr<!cir.ptr<!u8i>>
    %2 = cir.load %0 : !cir.ptr<!cir.ptr<!u8i>>, !cir.ptr<!u8i>
    cir.stack_restore %2 : !cir.ptr<!u8i>
    ```
    }];

  let arguments = (ins CIR_PointerType:$ptr);
  let assemblyFormat = "$ptr attr-dict `:` qualified(type($ptr))";

  let llvmOp = "StackRestoreOp";
}

def CIR_AsmFlavor : CIR_I32EnumAttr<"AsmFlavor", "ATT or Intel", [
  I32EnumAttrCase<"x86_att", 0>,
  I32EnumAttrCase<"x86_intel", 1>
]>;

def CIR_InlineAsmOp : CIR_Op<"asm", [RecursiveMemoryEffects]> {
  let description = [{
    The `cir.asm` operation represents C/C++ asm inline.

    CIR constraints strings follow barelly the same rules that are established
    for the C level assembler constraints with several differences caused by
    clang::AsmStmt processing.

    Thus, numbers that appears in the constraint string may also refer to:
    - the output variable index referenced by the input operands.
    - the index of early-clobber operand

    Operand attributes is a storage, where each element corresponds to the operand with
    the same index. The first index relates to the operation result (if any).
    Note, the operands themselves are stored as VariadicOfVariadic in the next order:
    output, input and then in/out operands.

    Note, when several output operands are present, the result type may be represented as
    an anon record type.

    Example:
    ```C++
    __asm__("foo" : : : );
    __asm__("bar $42 %[val]" : [val] "=r" (x), "+&r"(x));
    __asm__("baz $42 %[val]" : [val] "=r" (x), "+&r"(x) : "[val]"(y));
    ```

    ```mlir
    !rec_22anon2E022 = !cir.record<struct "anon.0" {!cir.int<s, 32>, !cir.int<s, 32>}>
    !rec_22anon2E122 = !cir.record<struct "anon.1" {!cir.int<s, 32>, !cir.int<s, 32>}>
    ...
    %0 = cir.alloca !s32i, !cir.ptr<!s32i>, ["x", init]
    %1 = cir.alloca !s32i, !cir.ptr<!s32i>, ["y", init]
    ...
    %2 = cir.load %0 : !cir.ptr<!s32i>, !s32i
    %3 = cir.load %1 : !cir.ptr<!s32i>, !s32i

    cir.asm(x86_att,
      out = [],
      in = [],
      in_out = [],
      {"foo" "~{dirflag},~{fpsr},~{flags}"}) side_effects

    cir.asm(x86_att,
      out = [],
      in = [],
      in_out = [%2 : !s32i],
      {"bar $$42 $0" "=r,=&r,1,~{dirflag},~{fpsr},~{flags}"}) -> !rec_22anon2E022

    cir.asm(x86_att,
      out = [],
      in = [%3 : !s32i],
      in_out = [%2 : !s32i],
      {"baz $$42 $0" "=r,=&r,0,1,~{dirflag},~{fpsr},~{flags}"}) -> !rec_22anon2E122
    ```
  }];

  let results = (outs Optional<CIR_AnyType>:$res);

  let arguments = (
    ins VariadicOfVariadic<AnyType, "operands_segments">:$asm_operands,
        StrAttr:$asm_string,
        StrAttr:$constraints,
        UnitAttr:$side_effects,
        CIR_AsmFlavor:$asm_flavor,
        ArrayAttr:$operand_attrs,
        DenseI32ArrayAttr:$operands_segments
        );

  let builders = [OpBuilder<(ins
    "llvm::ArrayRef<mlir::ValueRange>":$asm_operands,
    "llvm::StringRef":$asm_string,
    "llvm::StringRef":$constraints,
    "bool":$side_effects,
    "AsmFlavor":$asm_flavor,
    "llvm::ArrayRef<mlir::Attribute>":$operand_attrs
  )>
  ];

  let hasCustomAssemblyFormat = 1;
}

//===----------------------------------------------------------------------===//
// UnreachableOp
//===----------------------------------------------------------------------===//

def CIR_UnreachableOp : CIR_Op<"unreachable", [Terminator]> {
  let summary = "invoke immediate undefined behavior";
  let description = [{
    If the program control flow reaches a `cir.unreachable` operation, the
    program exhibits undefined behavior immediately. This operation is useful
    in cases where the unreachability of a program point needs to be explicitly
    marked.
  }];

  let assemblyFormat = "attr-dict";
}

//===----------------------------------------------------------------------===//
// TrapOp
//===----------------------------------------------------------------------===//

def CIR_TrapOp : CIR_Op<"trap", [Terminator]> {
  let summary = "Exit the program abnormally";
  let description = [{
    The cir.trap operation causes the program to exit abnormally. The
    implementations may implement this operation with different mechanisms. For
    example, an implementation may implement this operation by calling abort,
    while another implementation may implement this operation by executing an
    illegal instruction.
  }];

  let assemblyFormat = "attr-dict";
}

//===----------------------------------------------------------------------===//
// PrefetchOp
//===----------------------------------------------------------------------===//

def CIR_PrefetchOp : CIR_Op<"prefetch"> {
  let summary = "prefetch operation";
  let description = [{
    The `cir.prefetch` op prefetches data from the memmory address.

    ```mlir
    cir.prefetch(%0 : !cir.ptr<!void>) locality(1) write
    ```

    This opcode has the three attributes:
    1. The $locality is a temporal locality specifier
    ranging from (0) - no locality, to (3) - extremely local keep in cache.
    2. The $isWrite is the specifier determining if the prefetch is prepaired
    for a 'read' or 'write'.
    If $isWrite doesn't specified it means that prefetch is prepared for 'read'.
  }];

  let arguments = (ins
    CIR_VoidPtrType:$addr,
    ConfinedAttr<I32Attr, [IntMinValue<0>, IntMaxValue<3>]>:$locality,
    UnitAttr:$isWrite
  );

  let assemblyFormat = [{
    `(` $addr `:` qualified(type($addr)) `)`
        `locality``(` $locality `)`
        (`write` $isWrite^) : (`read`)?
        attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// ClearCacheOp
//===----------------------------------------------------------------------===//

def CIR_ClearCacheOp : CIR_Op<"clear_cache", [
  AllTypesMatch<["begin", "end"]>
]> {
  let summary = "clear cache operation";
  let description = [{
    CIR representation for `__builtin___clear_cache`.
  }];

  let arguments = (ins CIR_VoidPtrType:$begin, CIR_VoidPtrType:$end);
  let assemblyFormat = [{
    $begin `:` qualified(type($begin)) `,`
    $end `,`
    attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// ArrayCtor & ArrayDtor
//===----------------------------------------------------------------------===//

class CIR_ArrayInitDestroy<string mnemonic> : CIR_Op<mnemonic> {
  let arguments = (ins
    Arg<CIR_PtrToArray, "array address", [MemWrite, MemRead]>:$addr
  );

  let regions = (region SizedRegion<1>:$body);
  let assemblyFormat = [{
    `(` $addr `:` qualified(type($addr)) `)` $body attr-dict
  }];

  let builders = [
    OpBuilder<(ins "mlir::Value":$addr,
      "llvm::function_ref<void(mlir::OpBuilder &, mlir::Location)>":$regionBuilder), [{
        assert(regionBuilder && "builder callback expected");
        mlir::OpBuilder::InsertionGuard guard($_builder);
        mlir::Region *r = $_state.addRegion();
        $_state.addOperands(ValueRange{addr});
        $_builder.createBlock(r);
        regionBuilder($_builder, $_state.location);
    }]>
  ];
}

def CIR_ArrayCtor : CIR_ArrayInitDestroy<"array.ctor"> {
  let summary = "Initialize array elements with C++ constructors";
  let description = [{
    Initialize each array element using the same C++ constructor. This
    operation has one region, with one single block. The block has an
    incoming argument for the current array index to initialize.
  }];
}

def CIR_ArrayDtor : CIR_ArrayInitDestroy<"array.dtor"> {
  let summary = "Destroy array elements with C++ dtors";
  let description = [{
    Destroy each array element using the same C++ destructor. This
    operation has one region, with one single block. The block has an
    incoming argument for the current array index to initialize.
  }];
}

//===----------------------------------------------------------------------===//
// IsConstantOp
//===----------------------------------------------------------------------===//

def CIR_IsConstantOp : CIR_Op<"is_constant", [Pure]> {
  let description = [{
    Returns `true` if the argument is known to be a compile-time constant
    otherwise returns 'false'.
  }];
  let arguments = (ins CIR_AnyType:$val);
  let results = (outs CIR_BoolType:$result);

  let assemblyFormat = [{
    `(` $val `:` type($val) `)` `:` type($result) attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// SwitchFlatOp
//===----------------------------------------------------------------------===//

def CIR_SwitchFlatOp : CIR_Op<"switch.flat", [
  AttrSizedOperandSegments, Terminator
]> {
  let summary = "A flattened version of cir.switch";
  let description = [{
    The `cir.switch.flat` operation is a region-less and simplified version of the `cir.switch`.
    It's representation is closer to LLVM IR dialect than the C/C++ language feature.
  }];

  let arguments = (ins
    CIR_IntType:$condition,
    Variadic<AnyType>:$defaultOperands,
    VariadicOfVariadic<AnyType, "case_operand_segments">:$caseOperands,
    ArrayAttr:$case_values,
    DenseI32ArrayAttr:$case_operand_segments
  );

  let successors = (successor
    AnySuccessor:$defaultDestination,
    VariadicSuccessor<AnySuccessor>:$caseDestinations
  );

  let assemblyFormat = [{
    $condition `:` type($condition) `,`
    $defaultDestination (`(` $defaultOperands^ `:` type($defaultOperands) `)`)?
    custom<SwitchFlatOpCases>(ref(type($condition)), $case_values, $caseDestinations,
                                   $caseOperands, type($caseOperands))
    attr-dict
  }];

  let builders = [
    OpBuilder<(ins "mlir::Value":$condition,
      "mlir::Block *":$defaultDestination,
      "mlir::ValueRange":$defaultOperands,
      CArg<"llvm::ArrayRef<llvm::APInt>", "{}">:$caseValues,
      CArg<"mlir::BlockRange", "{}">:$caseDestinations,
      CArg<"llvm::ArrayRef<mlir::ValueRange>", "{}">:$caseOperands)>
  ];
}

//===----------------------------------------------------------------------===//
// GotoOp
//===----------------------------------------------------------------------===//

def CIR_GotoOp : CIR_Op<"goto", [Terminator]> {
  let description = [{

  Transfers control to the specified `label`. This requires a corresponding
  `cir.label` to exist and is used by to represent source level `goto`s
  that jump across region boundaries. Alternatively, `cir.br` is used to
  construct goto's that don't violate such boundaries.

  `cir.goto` is completely symbolic (i.e. it "jumps" on a label that isn't
  yet materialized) and should be taken into account by passes and analysis
  when deciding if it's safe to make some assumptions about a given region
  or basic block.

  Example:
  ```C++
    int test(int x) {
      if (x)
        goto label;
      {
        x = 10;
    label:
        return x;
      }
    }
  ```

  ```mlir
    cir.scope {  // REGION #1
      %2 = cir.load %0 : !cir.ptr<!s32i>, !s32i
      %3 = cir.cast(int_to_bool, %2 : !s32i), !cir.bool
      cir.if %3 {
        cir.goto "label"
      }
      }
      cir.scope {  // REGION #2
        %2 = cir.const #cir.int<10> : !s32i
        cir.store %2, %0 : !s32i, !cir.ptr<!s32i>
        cir.br ^bb1
      ^bb1:  // pred: ^bb0
        cir.label "label"
        %3 = cir.load %0 : !cir.ptr<!s32i>, !s32i
        cir.store %3, %1 : !s32i, !cir.ptr<!s32i>
        %4 = cir.load %1 : !cir.ptr<!s32i>, !s32i
        cir.return %4 : !s32i
      }
      cir.unreachable
  ```
  }];
  let arguments = (ins StrAttr:$label);
  let assemblyFormat = [{ $label attr-dict }];
}

//===----------------------------------------------------------------------===//
// LabelOp
//===----------------------------------------------------------------------===//

// The LabelOp has AlwaysSpeculatable trait in order to not to be swept by canonicalizer
def CIR_LabelOp : CIR_Op<"label", [AlwaysSpeculatable]> {
  let description = [{
    An identifier which may be referred by cir.goto operation
  }];
  let arguments = (ins StrAttr:$label);
  let assemblyFormat = [{ $label attr-dict }];
  let hasVerifier = 1;
}

//===----------------------------------------------------------------------===//
// Atomic operations
//===----------------------------------------------------------------------===//

def CIR_AtomicFetchKind : CIR_I32EnumAttr<
  "AtomicFetchKind", "Binary opcode for atomic fetch operations", [
    I32EnumAttrCase<"Add",  0, "add">,
    I32EnumAttrCase<"Sub",  1, "sub">,
    I32EnumAttrCase<"And",  2, "and">,
    I32EnumAttrCase<"Xor",  3, "xor">,
    I32EnumAttrCase<"Or",   4, "or">,
    I32EnumAttrCase<"Nand", 5, "nand">,
    I32EnumAttrCase<"Max",  6, "max">,
    I32EnumAttrCase<"Min",  7, "min">
]>;

def CIR_AtomicFetch : CIR_Op<"atomic.fetch", [
  AllTypesMatch<["result", "val"]>
]> {
  let summary = "Atomic fetch with unary and binary operations";
  let description = [{
    Represents `__atomic_<binop>_fetch` and `__atomic_fetch_<binop>` builtins,
    where `binop` is on of the binary opcodes : `add`, `sub`, `and`, `xor`,
    `or`, `nand`, `max` and `min`.

    `ptr` is an integer or fp pointer, followed by `val`, which must be
    an integer or fp (only supported for `add` and `sub`). The operation
    can also be marked `volatile`.

    If `fetch_first` is present, the operation works like
    `__atomic_fetch_binop` and returns the value that had
    previously been in *ptr, otherwise it returns the final result
    of the computation (`__atomic_binop_fetch`).

    Example:
    %res = cir.atomic.fetch(add, %ptr : !cir.ptr<!s32i>,
                            %val : !s32i, seq_cst) : !s32i
  }];
  let results = (outs CIR_AnyIntOrFloatType:$result);
  let arguments = (ins
    Arg<CIR_PtrToIntOrFloatType, "", [MemRead, MemWrite]>:$ptr,
    CIR_AnyIntOrFloatType:$val,
    CIR_AtomicFetchKind:$binop,
    Arg<CIR_MemOrder, "memory order">:$mem_order,
    UnitAttr:$is_volatile,
    UnitAttr:$fetch_first
  );

  let assemblyFormat = [{
    `(`$binop `,`
    $ptr `:` qualified(type($ptr)) `,`
    $val `:` type($val) `,`
    $mem_order `)`
    (`volatile` $is_volatile^)?
    (`fetch_first` $fetch_first^)?
    `:` type($result) attr-dict
  }];

  let hasVerifier = 1;
}

def CIR_AtomicXchg : CIR_Op<"atomic.xchg", [
  AllTypesMatch<["result", "val"]>
]> {
  let summary = "Atomic exchange";
  let description = [{
    Atomic exchange operations. Implements C/C++ builtins such as
    `__atomic_exchange`and `__atomic_exchange_n`.

    Example:
    %res = cir.atomic.xchg(%ptr : !cir.ptr<!some_record>,
                           %val : !u64i, seq_cst) : !u64i
  }];
  let results = (outs CIR_AnyType:$result);
  let arguments = (ins Arg<CIR_PointerType, "", [MemRead, MemWrite]>:$ptr,
                       CIR_AnyType:$val,
                       Arg<CIR_MemOrder, "memory order">:$mem_order,
                       UnitAttr:$is_volatile);

  let assemblyFormat = [{
    `(`
    $ptr `:` qualified(type($ptr)) `,`
    $val `:` type($val) `,`
    $mem_order `)`
    (`volatile` $is_volatile^)?
    `:` type($result) attr-dict
  }];

  let hasVerifier = 1;
}

def CIR_MemScopeKind : CIR_I32EnumAttr<"MemScopeKind", "memory scope kind", [
  I32EnumAttrCase<"SingleThread", 0, "single_thread">,
  I32EnumAttrCase<"System", 1, "system">
]>;

def CIR_AtomicCmpXchg : CIR_Op<"atomic.cmp_xchg", [
  AllTypesMatch<["old", "expected", "desired"]>
]> {
  let summary = "Atomic compare exchange";
  let description = [{
    C/C++ Atomic compare and exchange operation. Implements builtins like
    `__atomic_compare_exchange_n` and `__atomic_compare_exchange`.

    Example:
    %old, %cmp = cir.atomic.cmp_xchg(%ptr : !cir.ptr<!some_record>,
                                     %expected : !u64i,
                                     %desired : !u64i,
                                     success = seq_cst,
                                     failure = seq_cst) weak
                                     : (!u64i, !cir.bool)

  }];
  let results = (outs CIR_AnyType:$old, CIR_BoolType:$cmp);
  let arguments = (ins Arg<CIR_PointerType, "", [MemRead, MemWrite]>:$ptr,
                       CIR_AnyType:$expected,
                       CIR_AnyType:$desired,
                       Arg<CIR_MemOrder, "success memory order">:$succ_order,
                       Arg<CIR_MemOrder, "failure memory order">:$fail_order,
                       OptionalAttr<CIR_MemScopeKind>:$syncscope,
                       OptionalAttr<I64Attr>:$alignment,
                       UnitAttr:$weak,
                       UnitAttr:$is_volatile);

  let assemblyFormat = [{
    `(`
    $ptr `:` qualified(type($ptr)) `,`
    $expected `:` type($expected) `,`
    $desired `:` type($desired) `,`
    `success` `=`  $succ_order `,`
    `failure` `=`  $fail_order
    `)`
    (`syncscope` `(` $syncscope^ `)`)?
    (`align` `(` $alignment^ `)`)?
    (`weak` $weak^)?
    (`volatile` $is_volatile^)?
    `:` `(` type($old) `,` type($cmp) `)` attr-dict
  }];

  let hasVerifier = 1;
}

def CIR_AtomicFence : CIR_Op<"atomic.fence"> {
  let summary = "Atomic thread fence";
  let description = [{
    C/C++ Atomic thread fence synchronization primitive. Implements the builtin
    `__atomic_thread_fence` which enforces memory ordering constraints across
    threads within the specified synchronization scope.

    This handles all variations including:
      - `__atomic_thread_fence`
      - `__atomic_signal_fence`
      - `__c11_atomic_thread_fence`
      - `__c11_atomic_signal_fence`

    Example:
    ```mlir
      cir.atomic.fence syncscope(system) seq_cst
      cir.atomic.fence syncscope(single_thread) seq_cst
    ```

  }];

  let arguments = (ins
    Arg<CIR_MemOrder, "memory order">:$ordering,
    OptionalAttr<CIR_MemScopeKind>:$syncscope
  );

  let assemblyFormat = [{
    (`syncscope` `(` $syncscope^ `)`)? $ordering attr-dict
  }];
}

def CIR_SignBitOp : CIR_Op<"signbit", [Pure]> {
  let summary = "Checks the sign of a floating-point number";
  let description = [{
    It returns whether the sign bit (i.e. the highest bit) of the input operand
    is set.
  }];
  let arguments = (ins CIR_AnyFloatType:$input);
  let results = (outs CIR_BoolType:$res);
  let assemblyFormat = [{
      $input attr-dict `:` type($input) `->` qualified(type($res))
  }];
}

//===----------------------------------------------------------------------===//
// LinkerOptionsOp
//===----------------------------------------------------------------------===//

def CIR_LinkerOptionsOp : CIR_Op<"linker_options", [
  HasParent<"mlir::ModuleOp">
]> {
  let summary = "Options to pass to the linker when the object file is linked";
  let description = [{
    Pass the given options to the linker when the resulting object file
    is linked.
    This is used extensively on Windows to determine the C runtime that the
    object files should link against.

    Examples:
    ```mlir
    // Link against the MSVC static threaded CRT.
    cir.linker_options ["/DEFAULTLIB:", "libcmt"]

    // Link against aarch64 compiler-rt builtins
    cir.linker_options ["-l", "clang_rt.builtins-aarch64"]
  }];

  let arguments = (ins StrArrayAttr:$options);

  let assemblyFormat = [{
    $options attr-dict
  }];
}

//===----------------------------------------------------------------------===//
// Standard library function calls
//===----------------------------------------------------------------------===//

include "clang/CIR/Dialect/IR/CIRStdOps.td"

#endif // LLVM_CLANG_CIR_DIALECT_IR_CIROPS
